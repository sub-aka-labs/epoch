import{PrivyClientError as e}from"../Error.mjs";import{isUnifiedWallet as t}from"../wallet-api/unified-wallet.mjs";class r{async sign({message:e}){return await this.request({method:"sign",params:{message:new TextDecoder("utf8").decode(e)}})}async signTransaction({psbt:e}){return await this.request({method:"signTransaction",params:{psbt:e}})}async request(r){if(t(this._account))throw new e({code:"unsupported_wallet_type",error:"Bitcoin wallet providers are only supported for on-device execution and this app uses TEE execution. Use the useSignRawHash hook from @privy-io/expo/extended-chains to sign over a hash with this wallet. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide"});if(!await this._privyInternal.getAccessTokenInternal())throw new e({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});return this.handleIFrameRpc(r)}async handleIFrameRpc(t){try{let e=await this._privyInternal.getAccessTokenInternal();if(!e)throw Error("Missing access token. User must be authenticated.");return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:t.method,address:this._account.address}),(await this._proxy.rpcWallet({accessToken:e,request:t,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,hdWalletIndex:this._account.wallet_index,chainType:this._account.chain_type})).response.data}catch(r){console.error(r);let s=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:t.method,address:this._account.address,error:s}),new e({code:"embedded_wallet_request_error",error:s})}}toJSON(){return`PrivyEmbeddedBitcoinProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:e,privyInternal:t,account:r,entropyId:s,entropyIdVerifier:a}){this._proxy=e,this._privyInternal=t,this._account=r,this._entropyId=s,this._entropyIdVerifier=a}}export{r as EmbeddedBitcoinWalletProvider};
