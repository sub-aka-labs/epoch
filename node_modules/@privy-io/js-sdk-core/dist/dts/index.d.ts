import * as _privy_io_api_types from '@privy-io/api-types';
import { MfaPasskeyVerifyRequestBody, LinkedAccountEmbeddedWallet, LinkedAccountEthereumEmbeddedWallet, LinkedAccountSolanaEmbeddedWallet, User, SmartWalletConfiguration, OAuthTokens, LinkedAccountBitcoinSegwitEmbeddedWallet, LinkedAccountBitcoinTaprootEmbeddedWallet, AuthenticatedUser, OAuthProviderID, SmartWalletType, CoinbaseOnRampInitInput, MoonpayOnRampSignInput, MfaPasskeyInitRequestBody, MfaSMSInitRequestBody, LinkedAccount, LinkedAccountSmartWallet, CoinbaseOnRampInitResponse, WalletCreateParams, Wallet, WalletRpcParams, WalletRpcResponse, WalletRawSignParams, WalletRawSignResponse, WalletUpdateParams, LinkedAccountEmbeddedWalletWithID } from '@privy-io/api-types';
export { OAuthProviderID, SmartWalletType } from '@privy-io/api-types';
import { Chain, RpcConfig } from '@privy-io/chains';
export * from '@privy-io/chains';
import { Route } from '@privy-io/routes';
import EventEmitter from 'eventemitter3';
import { PrivyErrorCode } from '@privy-io/api-base';
import { Transaction, VersionedTransaction, Connection, SendOptions } from '@solana/web3.js';
import { AuthenticationResponseJSON, RegistrationResponseJSON } from '@simplewebauthn/types';
import { CountryCode, CountryCallingCode, AsYouType } from 'libphonenumber-js/min';
export { CountryCallingCode, CountryCode, getCountryCallingCode } from 'libphonenumber-js/min';
import { Hex, TypedDataDefinition } from 'viem';
import { SolanaSignMessageFeature, SolanaSignTransactionFeature, SolanaSignAndSendTransactionFeature, SolanaSignInFeature } from '@solana/wallet-standard-features';
import { WalletWithFeatures } from '@wallet-standard/base';
import { StandardConnectFeature, StandardDisconnectFeature, StandardEventsFeature } from '@wallet-standard/features';
import { WalletAccount } from '@wallet-standard/core';

type LogLevel = 'NONE' | 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
/**
 * Interface for a logger for the privy client SDK
 */
type Logger = {
    readonly level: LogLevel;
    readonly info: Console['log'];
    readonly warn: Console['warn'];
    readonly error: Console['error'];
    readonly debug: Console['debug'];
};

declare enum PrivyEmbeddedWalletErrorCode {
    MISSING_OR_INVALID_PRIVY_APP_ID = "missing_or_invalid_privy_app_id",
    MISSING_OR_INVALID_PRIVY_ACCOUNT_ID = "missing_or_invalid_privy_account_id",
    INVALID_DATA = "invalid_data",
    LINKED_TO_ANOTHER_USER = "linked_to_another_user",
    ALLOWLIST_REJECTED = "allowlist_rejected",
    OAUTH_USER_DENIED = "oauth_user_denied",
    UNKNOWN_AUTH_ERROR = "unknown_auth_error",
    USER_EXITED_AUTH_FLOW = "exited_auth_flow",
    MUST_BE_AUTHENTICATED = "must_be_authenticated",
    UNKNOWN_CONNECT_WALLET_ERROR = "unknown_connect_wallet_error",
    GENERIC_CONNECT_WALLET_ERROR = "generic_connect_wallet_error",
    CLIENT_REQUEST_TIMEOUT = "client_request_timeout",
    INVALID_CREDENTIALS = "invalid_credentials"
}
declare abstract class PrivyError extends Error {
    /**
     * Privy error type.
     */
    abstract type: string;
    /**
     * Original Error object, it the error originated client-side.
     */
    cause?: Error;
    /**
     * An optional error code, often included in Privy API responses.
     */
    privyErrorCode?: PrivyEmbeddedWalletErrorCode;
    /**
     * @param type Privy error type.
     * @param message Human-readable message.
     * @param cause Source of this error.
     */
    protected constructor(message: string, cause?: unknown, privyErrorCode?: PrivyEmbeddedWalletErrorCode);
    toString(): string;
}
/**
 * A ProviderRpcError combines the necessary bits of the {PrivyError} with the
 * EIP-compliant ProviderRpcError. This is meant to be a type around errors raised
 * by the ethereum provider.
 */
declare class ProviderRpcError extends PrivyError {
    type: string;
    readonly code: number;
    readonly data?: unknown;
    constructor(message: string, code: number, data?: unknown);
}
declare class PrivyIframeError extends Error {
    type: PrivyIframeErrorTypesType;
    constructor(type: PrivyIframeErrorTypesType, message: string);
}
declare class PrivyConnectorError extends PrivyError {
    type: string;
    constructor(message: string, cause?: unknown, privyErrorCode?: PrivyEmbeddedWalletErrorCode);
}
declare class EmbeddedProviderError extends Error {
    code: number;
    data?: unknown;
    constructor(message: string, code: number, data?: unknown);
}
declare const ProviderErrors: {
    E32002_CONNECTION_ALREADY_PENDING: {
        eipCode: number;
        message: string;
        detail: string;
        retryable: boolean;
    };
    E32002_REQUEST_ALREADY_PENDING: {
        eipCode: number;
        message: string;
        detail: string;
        retryable: boolean;
    };
    E32002_WALLET_LOCKED: {
        eipCode: number;
        message: string;
        detail: string;
        retryable: boolean;
    };
    E4001_USER_REJECTED_REQUEST: {
        eipCode: number;
        message: string;
        detail: string;
        retryable: boolean;
    };
    E4001_DEFAULT_USER_REJECTED_REQUEST: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E4100_DEFAULT_UNAUTHORIZED: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E4200_DEFAULT_UNSUPPORTED_METHOD: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E4900_DEFAULT_DISCONNECTED: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E4901_DEFAULT_CHAIN_DISCONNECTED: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32700_DEFAULT_PARSE_ERROR: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32600_DEFAULT_INVALID_REQUEST: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32601_DEFAULT_METHOD_NOT_FOUND: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32602_DEFAULT_INVALID_PARAMS: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32603_DEFAULT_INTERNAL_ERROR: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32000_DEFAULT_INVALID_INPUT: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32001_DEFAULT_RESOURCE_NOT_FOUND: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32002_DEFAULT_RESOURCE_UNAVAILABLE: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32003_DEFAULT_TRANSACTION_REJECTED: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32004_DEFAULT_METHOD_NOT_SUPPORTED: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32005_DEFAULT_LIMIT_EXCEEDED: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    E32006_DEFAULT_JSON_RPC_VERSION_NOT_SUPPORTED: {
        eipCode: number;
        message: string;
        detail: string;
        default: boolean;
        retryable: boolean;
    };
    UNKNOWN_ERROR: {
        eipCode: number;
        message: string;
        detail: string;
        retryable: boolean;
    };
};
declare function errorIndicatesRecoveryIsNeeded(error: unknown): error is PrivyIframeError;
declare function errorIndicatesMfaTimeout(error: unknown): error is PrivyIframeError;
declare function errorIndicatesMfaVerificationFailed(error: unknown): error is PrivyIframeError;
declare function errorIndicatesMaxMfaRetries(error: unknown): error is PrivyIframeError;
declare function errorIndicatesMfaRateLimit(error: unknown): error is PrivyIframeError;
/**
 * Represents an error message meant to display within the UI
 */
type UiErrorMessage = {
    /**
     * Main message to convey, one line
     */
    message: string;
    /**
     * Additional detail that may be relevant if it cannot be conveyed in the message
     */
    detail: string;
    /**
     * Whether this error is expected to be retryable
     */
    retryable: boolean;
};
type ProviderError = UiErrorMessage & {
    /**
     * The EIP code, either [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193#provider-errors)
     * or [EIP-1474](https://eips.ethereum.org/EIPS/eip-1474#error-codes)
     */
    eipCode: number;
    /**
     * Whether the contents (message & detail) are the default specified by the
     * EIP or if this is a custom message from our own semantic understanding of
     * the error.
     */
    default?: boolean;
};
/**
 * A PrivyProviderRpcError is a classified {ProviderRpcError}. When relevant,
 * we will attempt to replace the original messaging with our best guess of what
 * is going on.
 */
declare class PrivyProviderRpcError extends ProviderRpcError {
    details: ProviderError;
    constructor(error: unknown);
}

type ProviderConnectInfo = {
    chainId: string;
};
type OnConnectEventHandler = (connectInfo: ProviderConnectInfo) => void;
type OnDisconnectEventHandler = (error: ProviderRpcError) => void;
type OnChainChangedEventHandler = (chainId: string | number) => void;
type OnAccountsChangedEventHandler = (accounts: string[]) => void;
type ProviderMessage = {
    type: string;
    data: unknown;
};
type OnMessageEventHandler = (message: ProviderMessage) => void;
type EIP1193OnEventHandler = OnConnectEventHandler | OnDisconnectEventHandler | OnChainChangedEventHandler | OnAccountsChangedEventHandler | OnMessageEventHandler;
interface EIP1193Provider {
    request: (request: {
        method: string;
        params?: Array<unknown> | undefined;
    }) => Promise<unknown>;
    on: (eventName: string, listener: EIP1193OnEventHandler) => unknown;
    removeListener: (eventName: string | symbol, listener: (...args: unknown[]) => void) => unknown;
}
type RequestArguments = {
    method: string;
    params?: Array<any> | undefined;
};
type OnNeedsRecovery = (input: {
    recoveryMethod: EmbeddedWalletRecoveryOptions;
    onRecovered: () => void;
}) => Promise<void> | void;
declare class EmbeddedWalletProvider extends EventEmitter implements EIP1193Provider {
    request(request: RequestArguments): Promise<any>;
    /**
     * Backfills a transaction that may not specify a `chainId` with the provider's `this._chianId`
     */
    private ensureChainId;
    /**
     * If a chainId is provided that differs from the current `this._chainId`,
     * the new chain and StaticJsonRpcProvider will be set
     */
    private internalSwitchEthereumChain;
    private handlePopulateTransaction;
    private handleSignTransaction;
    private handleSendTransaction;
    private handleEstimateGas;
    private handleSwitchEthereumChain;
    private handleIFrameRpc;
    private handleJsonRpc;
    toJSON(): string;
}

type AuthAction = 'login' | 'link';
type Method = 'email' | 'sms' | 'oauth' | 'siwe' | 'passkey' | 'farcaster' | 'siws';
type ClientErrorCode = `failed_to_complete_${AuthAction}_with_oauth` | `${AuthAction}_with_oauth_returned_with_invalid_credentials` | `${AuthAction}_with_oauth_was_cancelled_by_user` | 'attempted_rpc_call_before_logged_in' | 'attempted_submit_otp_before_sending' | 'attempted_to_set_password_before_connected' | 'attempted_to_set_password_but_password_already_set' | `attempted_login_with_${Method}_while_already_logged_in` | `attempted_link_${Method}_before_logged_in` | 'attempted_link_cross_app_before_logged_in' | 'attempted_login_with_cross_app_while_already_logged_in' | 'attempted_cross_app_request_before_logged_in' | 'attempted_update_before_logged_in' | 'attempted_update_email_without_a_linked_email' | 'attempted_update_phone_without_a_linked_phone' | 'cross_app_invalid_app' | 'cross_app_read_only' | 'cross_app_invalid_wallet' | 'cross_app_request_error' | `attempted_unlink_siwe_before_logged_in` | 'oauth_session_failed' | 'oauth_session_timeout' | 'user_signer_sign_error' | 'invalid_input' | 'embedded_wallet_before_logged_in' | 'embedded_wallet_needs_recovery' | 'embedded_wallet_creation_error' | 'embedded_wallet_recovery_error' | 'embedded_wallet_set_password_error' | 'embedded_wallet_set_recovery_error' | 'unknown_embedded_wallet_error' | 'embedded_wallet_does_not_exist' | 'embedded_wallet_already_exists' | 'embedded_wallet_webview_not_loaded' | 'embedded_wallet_request_error' | 'delegated_actions_before_logged_in' | 'delegated_actions_wallet_not_found' | 'delegated_actions_no_wallet_to_revoke' | 'no_passkey_found_for_challenge' | 'pkce_state_code_mismatch' | 'failed_to_create_passkey' | 'failed_to_generate_farcaster_uri' | 'failed_to_generate_farcaster_channel_token' | 'farcaster_polling_timeout' | 'farcaster_polling_canceled' | 'unsupported_recovery_method' | 'attempted_to_create_guest_account_for_logged_in_user' | 'attempted_to_read_storage_before_client_initialized' | 'third_party_auth_error' | 'invalid_native_app_id' | 'unsupported_mfa_method' | 'unsupported_chain_type' | 'invalid_mfa_code' | 'invalid_passkey_response' | 'storage_error' | 'smart_wallet_client_error' | 'chain_not_supported' | 'mfa_canceled' | 'configuration_error' | 'failed_to_fetch_moonpay_transaction_status' | 'unsupported_wallet_type';
type ErrorBody<T extends PrivyErrorCode | ClientErrorCode> = {
    error: string;
    code: T;
};
type ServerErrorBody = ErrorBody<PrivyErrorCode>;
declare class PrivyApiError extends Error {
    error: string;
    code: PrivyErrorCode;
    constructor({ error, code }: ServerErrorBody);
}
declare class PrivyClientError extends Error {
    error: string;
    code: ClientErrorCode;
    constructor({ error, code }: ErrorBody<ClientErrorCode>);
}
declare class MoonpayApiError extends Error {
    error: string;
    code: ClientErrorCode;
    response: Response;
    constructor({ error, code, response }: ErrorBody<ClientErrorCode> & {
        response: Response;
    });
}
/**
 * This type converts the {@link PrivyErrorCode} enum into a string literal union type,
 * in order to match the structure of {@link ClientErrorCode}.
 *
 * Note this is valid because the {@link PrivyErrorCode} enum is a string enum.
 */
type PrivyApiErrorCode = `${PrivyErrorCode}`;
/**
 * All possible error codes, be it from the API or the client, plus an `'unknown_error'`
 * code for unexpected errors.
 */
type ErrorCode = PrivyApiErrorCode | ClientErrorCode | 'unknown_error';
/**
 * A partial map of error codes to error messages, with a `default` message as a fallback.
 */
type ErrorMessageMap = Partial<Record<ErrorCode, string>> & {
    default: string;
};
/**
 * Takes a message map and return an error formatter, that takes an error and
 * returns the corresponding error message.
 *
 * Valid errors are all those in the classes {@link PrivyApiError} and {@link PrivyClientError}.
 * Any other error will be treated as an unknown error.
 *
 * @param messageMap The partial map used to format error messages by their error code.
 * @returns
 */
declare const createErrorFormatter: (messageMap: ErrorMessageMap) => (error: unknown) => string;
declare function errorIndicatesMfaCanceled(error: unknown): unknown;

type MfaMethod = 'sms' | 'totp' | 'passkey';
type MfaSubmitArgs = {
    mfaMethod: MfaMethod;
    mfaCode: string | MfaPasskeyVerifyRequestBody.AuthenticatorResponse;
    relyingParty: string;
};
type MfaPromise = {
    current: {
        resolve: (args: MfaSubmitArgs) => void;
        reject: (error: PrivyClientError) => void;
    } | null;
};
type MfaSubmitPromise = {
    current: {
        resolve: (x: undefined) => void;
        reject: (error: PrivyIframeError) => void;
    } | null;
};

/**
 * We support a subset of the provider methods found here:
 *
 *     https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods
 *
 * For now, we're focused on signing-related methods because the iframe (this code)
 * is the only place that has access to the private key and thus is the only one
 * who can create signatures. All other methods do not need the private key and
 * can therefore be implemented by clients of the iframe.
 */

type Quantity = string | number | bigint;
type UnsignedTransactionRequest = {
    from?: string;
    to?: string;
    nonce?: Quantity;
    gasLimit?: Quantity;
    gasPrice?: Quantity;
    data?: ArrayLike<number> | string;
    value?: Quantity;
    chainId?: number;
    type?: number;
    accessList?: Array<{
        address: string;
        storageKeys: Array<string>;
    }> | Array<[string, Array<string>]> | Record<string, Array<string>>;
    maxPriorityFeePerGas?: Quantity;
    maxFeePerGas?: Quantity;
};
/**
 * {@link UnsignedTransactionRequest} specifies the `chainId` field as optional,
 * which matches ethers, wagmi, and a bunch of other libraries.
 *
 * However, we need the transaction's `chainId` to ensure it does price conversion, quote
 * labeling, etc. importantly.
 *
 * > Note:
 * > If the developer does not set a `chainId` in their `UnsignedTransactionRequest`,
 * > we default to the embedded provider's  current `chainId`
 */
type UnsignedTransactionRequestWithChainId = UnsignedTransactionRequest & {
    chainId: number;
};
interface eth_populateTransactionRequestResponse {
    method: 'eth_populateTransactionRequest';
    data: UnsignedTransactionRequest;
}
interface eth_signResponse {
    method: 'eth_sign';
    data: string;
}
interface personal_signResponse {
    method: 'personal_sign';
    data: string;
}
interface eth_signTransactionResponse {
    method: 'eth_signTransaction';
    data: string;
}
interface eth_signTypedData_v4Response {
    method: 'eth_signTypedData_v4';
    data: string;
}
interface csw_signUserOperationResponse {
    method: 'csw_signUserOperation';
    data: string;
}
interface secp256k1_signResponse {
    method: 'secp256k1_sign';
    data: `0x${string}`;
}
type RpcResponseType = eth_signTransactionResponse | eth_populateTransactionRequestResponse | eth_signResponse | personal_signResponse | eth_signTypedData_v4Response | csw_signUserOperationResponse | secp256k1_signResponse;
interface SolanaRpcResponseType {
    data: {
        signature: string;
    };
}
type BaseBitcoinRpcResponseType = {
    method: string;
    data: any;
};
/**
 * The Privy SDK(s) will return the signature as a `Uint8Array`, but the iframe must serialize it to
 * a `string` in order to pass it over the message bus. You can see how this is done in the signature handler.
 *
 * The Privy SDK(s) themselves must then deserialize the `string` to a `Uint8Array` before
 * returning the signature to the caller.
 */
interface bitcoin_signResponse extends BaseBitcoinRpcResponseType {
    method: 'sign';
    data: {
        signature: string;
    };
}
interface bitcoin_signTransactionResponse extends BaseBitcoinRpcResponseType {
    method: 'signTransaction';
    data: {
        signedTransaction: string;
    };
}
type BitcoinRpcResponseType = bitcoin_signResponse | bitcoin_signTransactionResponse;
type PrivyEventType = 'privy:iframe:ready' | 'privy:user-signer:sign' | 'privy:wallets:create' | 'privy:wallets:add' | 'privy:wallets:set-recovery' | 'privy:wallets:connect' | 'privy:wallets:recover' | 'privy:wallets:rpc' | 'privy:wallet:create' | 'privy:wallet:connect' | 'privy:wallet:recover' | 'privy:wallet:rpc' | 'privy:solana-wallet:create' | 'privy:solana-wallet:create-additional' | 'privy:solana-wallet:connect' | 'privy:solana-wallet:recover' | 'privy:solana-wallet:rpc' | 'privy:delegated-actions:consent' | 'privy:mfa:verify' | 'privy:mfa:init-enrollment' | 'privy:mfa:submit-enrollment' | 'privy:mfa:unenroll' | 'privy:mfa:clear';
type EmbeddedWalletRecoveryOptions = LinkedAccountEmbeddedWallet['recovery_method'];
type IEmbeddedWalletRecoveryOptions = EmbeddedWalletRecoveryOptions | 'icloud-native';
type PasswordRecoveryInput = {
    recoveryMethod: 'user-passcode';
    password: string;
};
type AppKeyRecoveryInput = {
    recoveryMethod: 'recovery-encryption-key';
    recoveryKey: string;
};
type CloudRecoveryInput = {
    recoveryMethod: 'google-drive' | 'icloud';
    recoveryAccessToken: string;
};
type ICloudNativeRecoveryInput = {
    recoveryMethod: 'icloud-native';
    recoverySecretOverride: string;
    iCloudRecordNameOverride: string;
};
type SetRecoveryInput = {
    wallet: LinkedAccountEthereumEmbeddedWallet | LinkedAccountSolanaEmbeddedWallet;
} & (PasswordRecoveryInput | CloudRecoveryInput | ICloudNativeRecoveryInput | PrivyRecoveryInput | AppKeyRecoveryInput);
interface SetRecoveryOutput {
    /** User object with the updated embedded wallet */
    user: User;
    /**
     * Provider for the embedded ethereum wallet.
     *
     * This value will be `null` if and only if the wallet passed in the input is not an Ethereum wallet.
     * @deprecated Get the provider instance from the `getProvider(...)` method instead.
     */
    provider: EmbeddedWalletProvider | null;
}
type BaseProxyRequest = {
    accessToken: string;
} & Partial<MfaSubmitArgs>;
type PrivyResponseBaseEventType<E extends PrivyEventType, D extends PrivyResponseDataType> = {
    id: string;
    event: E;
    data: D;
};
type ChainType = 'ethereum' | 'solana' | 'bitcoin-taproot' | 'bitcoin-segwit';
type BaseWalletsRequestData = BaseProxyRequest;
type IframeReadyResponseDataType = Record<string, never>;
type IframeReadyResponseEventType = PrivyResponseBaseEventType<'privy:iframe:ready', IframeReadyResponseDataType>;
type WalletsCreateResponseDataType = {
    address: string;
};
type WalletsCreateResponseEventType = PrivyResponseBaseEventType<'privy:wallets:create', WalletsCreateResponseDataType>;
type EntropyIdVerifier = 'ethereum-address-verifier' | 'solana-address-verifier';
type UserSignerSignResponseDataType = {
    /** The signature */
    signature: string;
};
type UserSignerSignResponseEventType = PrivyResponseBaseEventType<'privy:user-signer:sign', UserSignerSignResponseDataType>;
type WalletsAddResponseDataType = {
    address: string;
};
type WalletsAddResponseEventType = PrivyResponseBaseEventType<'privy:wallets:add', WalletsAddResponseDataType>;
type WalletsSetRecoveryBaseRequestDataType = BaseWalletsRequestData & {
    /**
     * Key with which to look up the existing entropy
     */
    entropyId: string;
    /**
     * Source of the `entropyId` property. This field determines how the entropyId will
     * be used. Possible values include:
     * - ethereum-address-verifier: the entropyId is the address of the Ethereum wallet derived
     * at index 0 for this entropy
     * - solana-address-verifier: the entropyId is a the address of the Solana wallet derived
     * at index 0 for this entropy
     *
     * When this field is a wallet address, we can verify reconstitution was successful by
     * deriving the specified wallet and comparing the address to the `entropyId`
     */
    entropyIdVerifier: EntropyIdVerifier;
    existingRecoveryMethod?: EmbeddedWalletRecoveryOptions;
};
type WalletsSetRecoveryPasswordDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'user-passcode';
    recoveryPassword: string;
};
type WalletsSetRecoveryGoogleDriveDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'google-drive';
    recoveryAccessToken: string;
};
type WalletsSetRecoveryICloudDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'icloud';
    recoveryAccessToken: string;
};
type WalletsSetRecoveryICloudNativeDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'icloud-native';
    recoverySecretOverride: string;
    iCloudRecordNameOverride: string;
};
type WalletsRecoveryEncyrptionKeyDataType = WalletsSetRecoveryBaseRequestDataType & {
    recoveryMethod: 'recovery-encryption-key';
    recoveryKey: string;
};
type WalletsSetRecoveryRequestDataType = Omit<WalletsSetRecoveryPasswordDataType, 'chainType'> | Omit<WalletsSetRecoveryGoogleDriveDataType, 'chainType'> | Omit<WalletsSetRecoveryICloudDataType, 'chainType'> | Omit<WalletsSetRecoveryICloudNativeDataType, 'chainType'> | Omit<WalletsRecoveryEncyrptionKeyDataType, 'chainType'>;
type WalletsSetRecoveryResponseDataType = {
    entropyId: string;
    entropyIdVerifier: EntropyIdVerifier;
    recoveryMethod: WalletsSetRecoveryRequestDataType['recoveryMethod'];
};
type WalletsSetRecoveryResponseEventType = PrivyResponseBaseEventType<'privy:wallets:set-recovery', WalletsSetRecoveryResponseDataType>;
type WalletsConnectResponseDataType = {
    entropyId: string;
};
type WalletsConnectResponseEventType = PrivyResponseBaseEventType<'privy:wallets:connect', WalletsConnectResponseDataType>;
type WalletsRecoverResponseDataType = {
    entropyId: string;
};
type WalletsRecoverResponseEventType = PrivyResponseBaseEventType<'privy:wallets:recover', WalletsRecoverResponseDataType>;
type WalletsRpcEthereumResponseDataType = {
    chainType: 'ethereum';
    response: RpcResponseType;
};
type WalletsRpcSolanaResponseDataType = {
    chainType: 'solana';
    response: SolanaRpcResponseType;
};
type WalletsRpcBitcoinResponseDataType = {
    chainType: 'bitcoin-taproot' | 'bitcoin-segwit';
    response: BitcoinRpcResponseType;
};
type WalletsRpcResponseDataType = {
    address: string;
} & (WalletsRpcEthereumResponseDataType | WalletsRpcSolanaResponseDataType | WalletsRpcBitcoinResponseDataType);
type WalletsRpcResponseEventType = PrivyResponseBaseEventType<'privy:wallets:rpc', WalletsRpcResponseDataType>;
type WalletCreateResponseDataType = {
    address: string;
};
type WalletCreateResponseEventType = PrivyResponseBaseEventType<'privy:wallet:create', WalletCreateResponseDataType>;
type WalletConnectResponseDataType = {
    address: string;
};
type WalletConnectResponseEventType = PrivyResponseBaseEventType<'privy:wallet:connect', WalletConnectResponseDataType>;
type WalletRecoverResponseDataType = {
    address: string;
};
type WalletRecoverResponseEventType = PrivyResponseBaseEventType<'privy:wallet:recover', WalletRecoverResponseDataType>;
type WalletRpcResponseDataType = {
    address: string;
    response: RpcResponseType;
};
type WalletRpcResponseEventType = PrivyResponseBaseEventType<'privy:wallet:rpc', WalletRpcResponseDataType>;
type SolanaWalletCreateResponseDataType = {
    publicKey: string;
};
type SolanaWalletCreateResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:create', SolanaWalletCreateResponseDataType>;
type SolanaWalletCreateAdditionalResponseDataType = {
    publicKey: string;
};
type SolanaWalletCreateAdditionalResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:create-additional', SolanaWalletCreateAdditionalResponseDataType>;
type SolanaWalletConnectResponseDataType = {
    publicKey: string;
};
type SolanaWalletConnectResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:connect', SolanaWalletConnectResponseDataType>;
type SolanaWalletRecoverResponseDataType = {
    publicKey: string;
};
type SolanaWalletRecoverResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:recover', SolanaWalletRecoverResponseDataType>;
type SolanaWalletRpcResponseDataType = {
    publicKey: string;
    response: SolanaRpcResponseType;
};
type SolanaWalletRpcResponseEventType = PrivyResponseBaseEventType<'privy:solana-wallet:rpc', SolanaWalletRpcResponseDataType>;
type RootWalletForDelegation = {
    /** Address of the root wallet for the entropy being delegated. */
    address: string;
    /** Chain type of the root wallet for the entropy being delegated. */
    chainType: 'ethereum' | 'solana';
    /** Whether or not the root wallet for the entropy being delegated is imported. */
    imported: boolean;
};
type DelegatedWallet = {
    /** Address for a wallet to delegate. */
    address: string;
    /** Chain type for a wallet to delegate. */
    chainType: 'ethereum' | 'solana';
    /** HD index for the wallet to delegate. */
    walletIndex: number;
};
type DelegatedActionsConsentResponseDataType = {
    success: boolean;
};
type DelegatedActionsConsentResponseEventType = PrivyResponseBaseEventType<'privy:delegated-actions:consent', DelegatedActionsConsentResponseDataType>;
type MfaVerifyResponseDataType = Record<string, never>;
type MfaVerifyResponseEventType = PrivyResponseBaseEventType<'privy:mfa:verify', MfaVerifyResponseDataType>;
type MfaInitEnrollmentResponseDataType = {
    method: string;
    secret?: string;
    authUrl?: string;
};
type MfaInitEnrollmentResponseEventType = PrivyResponseBaseEventType<'privy:mfa:init-enrollment', MfaInitEnrollmentResponseDataType>;
type MfaSubmitEnrollmentResponseDataType = Record<string, never>;
type MfaSubmitEnrollmentResponseEventType = PrivyResponseBaseEventType<'privy:mfa:submit-enrollment', MfaSubmitEnrollmentResponseDataType>;
type MfaUnenrollResponseDataType = Record<string, never>;
type MfaUnenrollResponseEventType = PrivyResponseBaseEventType<'privy:mfa:unenroll', MfaUnenrollResponseDataType>;
type MfaClearResponseDataType = Record<string, never>;
type MfaClearResponseEventType = PrivyResponseBaseEventType<'privy:mfa:clear', MfaClearResponseDataType>;
type PrivyResponseDataType = IframeReadyResponseDataType | UserSignerSignResponseDataType | WalletsCreateResponseDataType | WalletsAddResponseDataType | WalletsSetRecoveryResponseDataType | WalletsConnectResponseDataType | WalletsRecoverResponseDataType | WalletsRpcResponseDataType | WalletCreateResponseDataType | WalletConnectResponseDataType | WalletRecoverResponseDataType | WalletRpcResponseDataType | SolanaWalletCreateResponseDataType | SolanaWalletConnectResponseDataType | SolanaWalletRecoverResponseDataType | SolanaWalletRpcResponseDataType | DelegatedActionsConsentResponseDataType | MfaVerifyResponseDataType | MfaInitEnrollmentResponseDataType | MfaSubmitEnrollmentResponseDataType | MfaUnenrollResponseDataType | MfaClearResponseDataType;
declare const PrivyIframeErrorTypes: readonly ["error", "invalid_request_arguments", "wallet_not_on_device", "invalid_recovery_pin", "insufficient_funds", "mfa_timeout", "missing_or_invalid_mfa", "mfa_verification_max_attempts_reached"];
type PrivyIframeErrorTypesType = (typeof PrivyIframeErrorTypes)[number];
type PrivyErrorResponseEventType = PrivyResponseBaseEventType<PrivyEventType, PrivyResponseDataType> & {
    error: {
        type: PrivyIframeErrorTypesType;
        message: string;
    };
};
type PrivyResponseEvent = IframeReadyResponseEventType | PrivyErrorResponseEventType | UserSignerSignResponseEventType | WalletsCreateResponseEventType | WalletsAddResponseEventType | WalletsSetRecoveryResponseEventType | WalletsConnectResponseEventType | WalletsRecoverResponseEventType | WalletsRpcResponseEventType | WalletCreateResponseEventType | WalletConnectResponseEventType | WalletRecoverResponseEventType | WalletRpcResponseEventType | SolanaWalletCreateResponseEventType | SolanaWalletCreateAdditionalResponseEventType | SolanaWalletConnectResponseEventType | SolanaWalletRecoverResponseEventType | SolanaWalletRpcResponseEventType | DelegatedActionsConsentResponseEventType | MfaVerifyResponseEventType | MfaInitEnrollmentResponseEventType | MfaSubmitEnrollmentResponseEventType | MfaUnenrollResponseEventType | MfaClearResponseEventType;
type EmbeddedWalletMessagePoster = {
    postMessage: (message: any, targetOrigin: string, transfer?: Transferable) => void;
    reload: () => void;
};
type PreparedTransactionRequestEIP1559 = UnsignedTransactionRequest & {
    from: string;
    to: string;
    nonce: Quantity;
    chainId: number;
    gasLimit: Quantity;
    type: 2;
    maxFeePerGas: Quantity;
};
type PreparedTransactionRequestLegacy = UnsignedTransactionRequest & {
    from: string;
    to: string;
    nonce: Quantity;
    chainId: number;
    gasLimit: Quantity;
    type: 0 | 1;
    gasPrice: Quantity;
};
type PreparedTransactionRequest = PreparedTransactionRequestEIP1559 | PreparedTransactionRequestLegacy;

interface Storage {
    get(key: string): unknown | Promise<unknown>;
    put(key: string, value: unknown): void | Promise<void>;
    del(key: string): void | Promise<void>;
    getKeys(): string[] | Promise<string[]>;
}

type NonEmptyArray<T> = [T, ...T[]];

declare class AppApi {
    private _smartWalletConfig;
    getConfig(): _privy_io_api_types.AppResponse | undefined;
    getSmartWalletConfig(): Promise<SmartWalletConfiguration>;
    get appId(): string;
}

declare class CrossAppApi {
    /** Defines the format of the storage key for provider access tokens */
    private static providerAccessTokenStorageKey;
    /**
     * Updates the stored token information of a given cross-app provider.
     * @param providerAppId the Privy app ID to which the oauth tokens correspond.
     * @param tokens should be the result of cross app authentication (be it login or linking).
     */
    updateOnCrossAppAuthentication(providerAppId: string, tokens: OAuthTokens): Promise<void>;
    /**
     * Returns the last known access token for a given cross-app provider.
     * @param providerAppId the Privy app ID on which you want to act.
     */
    getProviderAccessToken(providerAppId: string): Promise<string | null>;
    /**
     * Fetches the metadata of all cross-app connections for the current app.
     */
    getCrossAppConnections(): Promise<_privy_io_api_types.CrossAppConnectionsResponse>;
}

declare class DelegatedWalletsApi {
    /**
     * Revokes delegation permission of all the wallets associated with the user.
     */
    revoke(): Promise<void>;
}

type SignMessageRequestArguments = {
    method: 'signMessage';
    params: {
        message: string;
    };
};
type SignAndSendTransactionRequestArguments = {
    method: 'signAndSendTransaction';
    params: {
        transaction: Transaction | VersionedTransaction;
        connection: Connection;
        options?: SendOptions;
    };
};
type SignTransactionRequestArguments<T extends Transaction | VersionedTransaction = Transaction> = {
    method: 'signTransaction';
    params: {
        transaction: T;
    };
};
/**
 * Privy embedded wallet provider for Solana accounts.
 *
 * Currently only supports signing messages.
 */
declare class EmbeddedSolanaWalletProvider {
    request(request: SignMessageRequestArguments): Promise<{
        signature: string;
    }>;
    request(request: SignAndSendTransactionRequestArguments): Promise<{
        signature: string;
    }>;
    request<T extends Transaction | VersionedTransaction>(request: SignTransactionRequestArguments<T>): Promise<{
        signedTransaction: T;
    }>;
    /**
     * Legacy API for reading the public key for this provider.
     *
     * @deprecated
     */
    get _publicKey(): string;
    /**
     * Preemptively check if the wallet is connected and trigger recovery if needed,
     * either automatically or via an onNeedsRecovery callback.
     */
    private connectAndRecover;
    private signMessageRpc;
    private handleIFrameRpc;
    private handleSignAndSendTransaction;
    private handleSignTransaction;
    /**
     * Pretty log output for when an instance of this class is `console.log`'d
     */
    toJSON(): string;
}

/**
 * Privy embedded wallet provider for Bitcoin accounts.
 *
 * Currently only supports signing messages.
 */
declare class EmbeddedBitcoinWalletProvider {
    /**
     * Sign an arbitrary message
     *
     * @param o the input object
     * @param o.message a byte array to sign
     *
     * @returns a base64-endoed signature
     */
    sign({ message }: {
        message: Uint8Array;
    }): Promise<{
        signature: string;
    }>;
    /**
     * Sign an encoded transaction
     *
     * @param o the input object
     * @param o.txPSBT a bitcoin transaction in PSBT format, hex-encoded
     *
     * @returns a hex-encoded signed transaction
     */
    signTransaction({ psbt }: {
        psbt: string;
    }): Promise<{
        signedTransaction: string;
    }>;
    private request;
    private handleIFrameRpc;
    /**
     * Pretty log output for when an instance of this class is `console.log`'d
     */
    toJSON(): string;
}

/** Options for creating the Solana embedded wallet */
type CreateSolanaOpts = {
    /**
     * The user's existing Ethereum embedded wallet if they have one. This parameter
     * MUST be set if the user has an Ethereum embedded wallet, otherwise Solana creation
     * will fail in the iframe.
     */
    ethereumAccount?: LinkedAccountEthereumEmbeddedWallet;
    /** Optional idempotency key for automatic wallet creation */
    idempotencyKey?: string;
};
declare class EmbeddedWalletApi {
    /**
     * Add a new embedded wallet account.
     *
     * Requires that the user already have created an embedded wallet via `create`.
     *
     * @param o input options
     * @param o.chainType the type of wallet to create
     * @param o.hdWalletIndex the index of the wallet to create
     * @param o.entropyId the key used to look up the existing wallet
     * @param o.entropyIdVerifier the method used to verify the entropy ID
     *
     * @returns the updated user
     */
    add(opts: {
        chainType: ChainType;
        hdWalletIndex: number;
        entropyId: string;
        entropyIdVerifier: EntropyIdVerifier;
    }): Promise<{
        user: _privy_io_api_types.User;
    }>;
    getBitcoinProvider({ wallet, entropyId, entropyIdVerifier, recoveryPassword, recoveryAccessToken, recoverySecretOverride, }: {
        wallet: LinkedAccountBitcoinSegwitEmbeddedWallet | LinkedAccountBitcoinTaprootEmbeddedWallet;
        entropyId: string;
        entropyIdVerifier: EntropyIdVerifier;
        recoveryPassword?: string;
        recoveryAccessToken?: string;
        recoverySecretOverride?: string;
    }): Promise<EmbeddedBitcoinWalletProvider>;
    /**
     * Creates an embedded wallet
     *
     * @param password Recovery password for the embedded wallet
     * @param recoveryMethod recovery method to create the wallet with
     * @param recoveryToken access token for recovery
     * @param recoverySecretOverride override for the recovery secret used to encrypt the recovery shares
     * @param iCloudRecordNameOverride override for the icloud record name where the recovery secret is stored in cloud recovery
     * @param solanaAccount The user's existing Solana embedded wallet if they have one. This parameter
     * MUST be set if the user has an Solana embedded wallet, otherwise Ethereum creation
     * will fail in the iframe.
     * @param skipCallbacks whether or not to skip user update callbacks when refreshing the user object
     *
     * @returns the updated user
     */
    create({ password, recoveryMethod, recoveryToken, recoveryKey, recoverySecretOverride, iCloudRecordNameOverride, solanaAccount, skipCallbacks, idempotencyKey, }: {
        password?: string;
        recoveryMethod?: IEmbeddedWalletRecoveryOptions;
        recoveryToken?: string;
        recoveryKey?: string;
        recoverySecretOverride?: string;
        iCloudRecordNameOverride?: string;
        solanaAccount?: LinkedAccountSolanaEmbeddedWallet;
        skipCallbacks?: boolean;
        /** Optional idempotency key for automatic wallet creation */
        idempotencyKey?: string;
    }): Promise<Omit<AuthenticatedUser, 'session_update_action'>>;
    /**
     * Creates an embedded Solana wallet
     *
     * @param opts.ethereumAccount the user's existing embedded wallet account if they have one. This parameter
     * MUST be passed if the user has an existing Ethereum embedded wallet otherwise Solana wallet creation will fail.
     *
     * @returns the updated user
     */
    createSolana(opts?: CreateSolanaOpts): Promise<Omit<AuthenticatedUser, 'session_update_action'>>;
    delegateWallets({ delegatedWallets, rootWallet, }: {
        delegatedWallets: DelegatedWallet[];
        rootWallet: RootWalletForDelegation;
    }): Promise<void>;
    /**
     * Retrieve this user's embedded wallet.
     * If the wallet has never been used on this device recover.
     *
     * @param password Recovery password for the embedded wallet
     * @returns EmbeddedWalletProvider implementing EIP1193Provider
     */
    getProvider(wallet: LinkedAccountEthereumEmbeddedWallet, recoveryPassword?: string, recoveryAccessToken?: string, recoverySecretOverride?: string, recoveryKey?: string): Promise<EmbeddedWalletProvider>;
    /**
     * Load this user's embedded ethereum wallet through the given entropy.
     * If the wallet has never been used on this device recover.
     *
     * @returns EmbeddedWalletProvider implementing EIP1193Provider
     */
    getEthereumProvider({ wallet, entropyId, entropyIdVerifier, recoveryPassword, recoveryAccessToken, recoverySecretOverride, recoveryKey, onNeedsRecovery, }: {
        wallet: LinkedAccountEthereumEmbeddedWallet;
        entropyId: string;
        entropyIdVerifier: EntropyIdVerifier;
        recoveryPassword?: string;
        recoveryAccessToken?: string;
        recoverySecretOverride?: string;
        recoveryKey?: string;
        /**
         * A function that will get called anytime the secure context throws an error that
         * indicates recover is required (i.e. on-demand recovery)
         *
         * @example
         * const provider = await getEthereumProvider({
         *   onNeedsRecovery: async ({recoveryMethod, onRecovered}) => {
         *     await promptRecovery({recoveryMethod})
         *     onRecovered();
         *   },
         * })
         */
        onNeedsRecovery?: OnNeedsRecovery;
    }): Promise<EmbeddedWalletProvider>;
    /**
     * Retrieve this users embedded Solana wallet.
     * If the wallet has never been used on this device recover.
     *
     * @returns EmbeddedSolanaWalletProvider
     */
    getSolanaProvider(account: LinkedAccountSolanaEmbeddedWallet, entropyId: string, entropyIdVerifier: EntropyIdVerifier, recoveryPassword?: string, recoveryAccessToken?: string, recoverySecretOverride?: string, 
    /**
     * A function that will get called anytime the secure context throws an error that
     * indicates recover is required (i.e. on-demand recovery)
     *
     * @example
     * const provider = await getEthereumProvider({
     *   onNeedsRecovery: async ({recoveryMethod, onRecovered}) => {
     *     await promptRecovery({recoveryMethod})
     *     onRecovered();
     *   },
     * })
     */
    onNeedsRecovery?: OnNeedsRecovery): Promise<EmbeddedSolanaWalletProvider>;
    /**
     * Add or change the recovery method used to recover an embedded wallet.
     *
     * @param password New recovery password
     * @param currentPassword Current recovery password used to recover the embedded wallet
     * @returns User the user object with the updated embedded wallet.
     * @returns EmbeddedWalletProvider implementing EIP1193Provider if the input wallet is an Ethereum wallet.
     */
    setRecovery(setRecoveryInput: SetRecoveryInput): Promise<SetRecoveryOutput>;
    /**
     * @returns URL to load in the embedded wallet iframe
     */
    getURL(): string;
    /**
     * @deprecated Require higher level SDKs to pass in the chain configuration
     */
    get chains(): NonEmptyArray<Chain>;
    /**
     * Handles messages from the embedded wallet secure contexts
     *
     * @example
     * const onMessage = async (e: WebViewMessageEvent) => {
     *   const {data} = e.nativeEvent;
     *   client.embeddedWallet.onMessage(JSON.parse(data));
     * }
     */
    onMessage(event: PrivyResponseEvent): void;
    reload(): void;
    ping(timeoutMs: number): Promise<boolean>;
}

declare class MfaPromises extends EventEmitter<{
    mfaRequired: [];
}> {
    /**
     * This is the root promise for MFA flows. It is resolved or rejected when MFA is complete.
     */
    readonly rootPromise: MfaPromise;
    /**
     * This is the promise for MFA attempts. It is resolved or rejected for every attempt to verify MFA.
     */
    readonly submitPromise: MfaSubmitPromise;
}

declare class UserApi {
    /**
     * Get the logged in user.
     */
    get(): Promise<{
        user: _privy_io_api_types.User;
    }>;
    acceptTerms(): Promise<{
        user: _privy_io_api_types.User;
    }>;
}

type CreateOnLogin = 'off' | 'users-without-wallets' | 'all-users';
type EmbeddedWalletConfig = {
    createOnLogin: CreateOnLogin;
};
type LoginOptions = {
    embedded?: {
        ethereum?: EmbeddedWalletConfig;
        solana?: EmbeddedWalletConfig;
    };
};

declare class CustomProviderApi {
    /**
     * Logs a user in via a custom JWT from another (non-Privy) service
     *
     * @param token The JWT from the non-Privy service
     */
    syncWithToken(token: string, opts?: LoginOptions, mode?: 'login-or-sign-up' | 'no-signup'): Promise<Omit<_privy_io_api_types.AuthenticatedUser, "session_update_action">>;
}

declare class EmailApi {
    /**
     * Sends a one time login code to a user's email address
     *
     * @param email The email address to send the one time login code
     * @param token A CAPTCHA token
     */
    sendCode(email: string, token?: string): Promise<{
        success: boolean;
    }>;
    /**
     * Logs a user in via an email address and one time code
     *
     * @param email The email address that the one time code was sent to
     * @param code The one time code
     * @param mode Optional Whether or not to block sign ups (only allow existing users to log in).
     */
    loginWithCode(email: string, code: string, mode?: 'login-or-sign-up' | 'no-signup', opts?: LoginOptions): Promise<Omit<_privy_io_api_types.AuthenticatedUser, "session_update_action">>;
    /**
     * Links an email address to an existing user
     *
     * @param email The email address that the one time code was sent to
     * @param code The one time code
     */
    linkWithCode(email: string, code: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Updates an email address on an existing user
     *
     * @param input.oldEmailAddress The currently linked email address, that will be removed
     * @param input.newEmailAddress The email address the user will be updated to
     * @param input.code The one time code received on the `newEmailAddress`
     */
    updateEmail({ oldEmailAddress, newEmailAddress, code, }: {
        oldEmailAddress: string;
        newEmailAddress: string;
        code: string;
    }): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    unlink(email: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
}

declare class FarcasterApi {
    /**
     * Begin a login / link flow with a farcaster.
     */
    initializeAuth({ relyingParty, redirectUrl, token, }: {
        relyingParty?: string;
        redirectUrl?: string;
        token?: string;
    }): Promise<_privy_io_api_types.FarcasterConnectInitResponseBody>;
    /**
     * Get the status of a user's SIWF request.
     */
    getFarcasterStatus({ channel_token }: {
        channel_token: string;
    }): Promise<NonNullable<_privy_io_api_types.FarcasterConnectStatusCompletedResponseBody | _privy_io_api_types.FarcasterConnectStatusPendingResponseBody | undefined>>;
    /**
     * Authenticate with Privy via the Sign-In With Farcaster spec [FIP-11: Sign in with Farcaster](https://github.com/farcasterxyz/protocol/discussions/110).
     */
    authenticate({ channel_token, message, signature, fid, mode, }: {
        channel_token: string;
        message: string;
        signature: string;
        fid: number;
        mode?: 'login-or-sign-up' | 'no-signup';
    }, opts?: LoginOptions): Promise<Omit<_privy_io_api_types.AuthenticatedUser, "session_update_action">>;
    /**
     * Link with Privy via the Sign-In With Farcaster spec [FIP-11: Sign in with Farcaster](https://github.com/farcasterxyz/protocol/discussions/110).
     */
    link({ channel_token, message, signature, fid, }: {
        channel_token: string;
        message: string;
        signature: string;
        fid: number;
    }): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Unlink with Privy via the Sign-In With Farcaster spec.
     */
    unlink({ fid }: {
        fid: number;
    }): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
}

declare class FarcasterV2Api {
    /**
     * Begin a login / link flow with a farcaster.
     */
    initializeAuth(): Promise<_privy_io_api_types.FarcasterV2InitResponseBody>;
    /**
     * Authenticate with Privy via the Sign-In With Farcaster spec [FIP-11: Sign in with Farcaster](https://github.com/farcasterxyz/protocol/discussions/110).
     */
    authenticate({ message, signature, fid, }: {
        message: string;
        signature: string;
        fid: number;
        mode?: 'login-or-sign-up' | 'no-signup';
    }, opts?: LoginOptions): Promise<Omit<_privy_io_api_types.AuthenticatedUser, "session_update_action">>;
}

declare class GuestApi {
    /**
     * Sends a one time login code to a user's email address
     *
     * @param email The email address to send the one time login code
     * @param token A CAPTCHA token
     */
    create(opts?: LoginOptions): Promise<Omit<_privy_io_api_types.AuthenticatedUser, "session_update_action">>;
}

declare class OAuthApi {
    /**
     * Starts an OAuth flow with a specific provider
     * Sends a one time login code to a user's email address
     *
     * @param provider The OAuth provider
     * @param redirectURI The URL to redirect to after a successful OAuth flow
     */
    generateURL(provider: OAuthProviderID, redirectURI: string): Promise<_privy_io_api_types.OAuthInitResponseBody>;
    /**
     * Logs a user in via successfull OAuth flow codes
     *
     * @param authorizationCode The code generated by the authorization server
     * @param returnedStateCode The state value initially set in the request by Privy to the authorization server
     * @param provider The OAuth provider (e.g. google, apple)
     * @param codeType The string literal `raw` indicating this the authorizationCode is unhashed, from a native sign in flow.
     * @param mode Optional Whether or not to block sign ups (only allow existing users to log in).
     */
    loginWithCode(authorizationCode: string, returnedStateCode: string, provider?: OAuthProviderID, codeType?: 'raw', mode?: 'login-or-sign-up' | 'no-signup', opts?: LoginOptions): Promise<Omit<_privy_io_api_types.AuthenticatedUser, "session_update_action">>;
    /**
     * Links an OAuth account to an existing user
     *
     * @param authorizationCode The code generated by the authorization server
     * @param returnedStateCode The state value initially set in the request by Privy to the authorization server
     */
    linkWithCode(authorizationCode: string, returnedStateCode: string, provider?: OAuthProviderID, codeType?: 'raw'): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Un-links an OAuth account from an existing user
     *
     * @param provider The OAuth provider
     * @param subject The subject of the OAuth account, usually an email or username
     */
    unlink(provider: OAuthProviderID, subject: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
}

declare class PasskeyApi {
    /**
     * Begin a link flow with a passkey.
     */
    generateRegistrationOptions(relyingParty?: string): Promise<_privy_io_api_types.PasskeyInitLinkResponseBody>;
    /**
     * Begin a login flow with a passkey.
     */
    generateAuthenticationOptions(relyingParty?: string): Promise<_privy_io_api_types.PasskeyInitAuthenticateResponseBody>;
    /**
     * Begin a sign up flow with a passkey.
     */
    generateSignupOptions(relyingParty?: string): Promise<_privy_io_api_types.PasskeyInitRegisterResponseBody>;
    /**
     * Log a user in via a passkey.
     *
     * Does _NOT_ create a new passkey account for the current user.
     */
    loginWithPasskey(input: AuthenticationResponseJSON, challenge: string, relyingParty?: string, opts?: LoginOptions): Promise<Omit<AuthenticatedUser, 'session_update_action'>>;
    /**
     * Sign up into a new user account via a passkey.
     *
     * Creates a new user with a passkey account.
     */
    signupWithPasskey(input: RegistrationResponseJSON, relyingParty?: string, opts?: LoginOptions): Promise<Omit<AuthenticatedUser, 'session_update_action'>>;
    /**
     * Links a passkey to an existing user.
     *
     * Creates a new passkey account for the current user.
     */
    linkWithPasskey(input: RegistrationResponseJSON, relyingParty?: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    private _transformRegistrationResponseToSnakeCase;
    private _transformAuthenticationResponseToSnakeCase;
}

declare class PhoneApi {
    /**
     * Sends a one time login code to a user's phone number via sms
     *
     * @param phoneNumber The phone number to send the one time login code
     * @param token A CAPTCHA token
     */
    sendCode(phoneNumber: string, token?: string): Promise<{
        success: boolean;
    }>;
    /**
     * Logs a user in via a phone number and one time code
     *
     * @param phoneNumber The phone number that the one time code was sent to
     * @param code The one time code
     * @param mode Optional Whether or not to block sign ups (only allow existing users to log in).
     */
    loginWithCode(phoneNumber: string, code: string, mode?: 'login-or-sign-up' | 'no-signup', opts?: LoginOptions): Promise<Omit<_privy_io_api_types.AuthenticatedUser, "session_update_action">>;
    /**
     * Links a phone number to an existing user
     *
     * @param phoneNumber The phone number that the one time code was sent to
     * @param code The one time code
     */
    linkWithCode(phoneNumber: string, code: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Updates a phone number on an existing user
     *
     * @param input.oldPhoneNumber The currently linked phone number, that will be removed
     * @param input.newPhoneNumber The phone number the user will be updated to
     * @param input.code The one time code received on the `newPhoneNumber`
     */
    updatePhone({ oldPhoneNumber, newPhoneNumber, code, }: {
        oldPhoneNumber: string;
        newPhoneNumber: string;
        code: string;
    }): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    unlink(phoneNumber: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
}

type PrivyEmbeddedWalletProvider = EmbeddedWalletProvider;
type PrivyEmbeddedSolanaWalletProvider = EmbeddedSolanaWalletProvider;

declare const EMBEDDED_WALLET_CLIENT_TYPES: readonly ["privy"];
type EmbeddedWalletClientType = (typeof EMBEDDED_WALLET_CLIENT_TYPES)[number];
declare const INJECTED_WALLET_CLIENT_TYPES: readonly ["metamask", "phantom", "brave_wallet", "rainbow"];
type InjectedWalletClientType = (typeof INJECTED_WALLET_CLIENT_TYPES)[number];
declare const COINBASE_WALLET_CLIENT_TYPES: readonly ["coinbase_wallet"];
type CoinbaseWalletClientType = (typeof COINBASE_WALLET_CLIENT_TYPES)[number];
type WalletConnectWalletClientType = (typeof WALLET_CONNECT_WALLET_CLIENT_TYPES)[number];
declare const UNKNOWN_WALLET_CLIENT_TYPES: readonly ["unknown"];
type UnknownWalletClientType = (typeof UNKNOWN_WALLET_CLIENT_TYPES)[number];
declare const ALL_WALLET_CLIENT_TYPES: ("safe" | "unknown" | "privy" | "metamask" | "phantom" | "brave_wallet" | "rainbow" | "coinbase_wallet" | "trust" | "uniswap" | "zerion" | "argent" | "spot" | "omni" | "cryptocom" | "blockchain" | "safepal" | "bitget_wallet" | "zengo" | "1inch" | "binance" | "exodus" | "mew_wallet" | "alphawallet" | "keyring_pro" | "mathwallet" | "unstoppable" | "obvious" | "ambire" | "internet_money_wallet" | "coin98" | "abc_wallet" | "arculus_wallet" | "haha" | "cling_wallet" | "broearn" | "copiosa" | "burrito_wallet" | "enjin_wallet" | "plasma_wallet" | "avacus" | "bee" | "pitaka" | "pltwallet" | "minerva" | "kryptogo" | "prema" | "slingshot" | "kriptonio" | "timeless" | "secux" | "bitizen" | "blocto" | "safemoon")[];
type WalletClientType = InjectedWalletClientType | CoinbaseWalletClientType | WalletConnectWalletClientType | EmbeddedWalletClientType | UnknownWalletClientType;
declare const SUPPORTED_CONNECTOR_TYPES: readonly ["injected", "wallet_connect", "wallet_connect_v2", "coinbase_wallet", "embedded"];
type ConnectorType = (typeof SUPPORTED_CONNECTOR_TYPES)[number];
type WalletBranding = {
    /** The display name for the wallet. */
    name: string;
    /** Unique identifier for this wallet, can be RDNS or other unique data. */
    id: string;
    /** Wallet brand icon url. */
    icon?: string;
};
type ExternalWalletMetadata = {
    /** The wallet name (e.g. MetaMask). */
    name: string;
    /** The wallet RDNS, falls back to the wallet name if none is available. */
    id: string;
    /** The wallet logo */
    icon?: string;
};
/**
 * Wallet to request a [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) signature from
 */
type ExternalWallet = {
    /** [EIP-55](https://eips.ethereum.org/EIPS/eip-55) mixed-case checksum-encoded address */
    address: string;
    /** [EIP-155](https://eips.ethereum.org/EIPS/eip-155) Chain ID with [CAIP-2](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md) formatting */
    chainId: string;
    /**
     * The wallet client where this key-pair is stored.
     * e.g. `metamask`, `rainbow`, `coinbase_wallet`, etc.
     */
    walletClientType?: WalletClientType;
    /**
     * The connector used to initiate the connection with the wallet client.
     * e.g. `injected`, `wallet_connect`, `coinbase_wallet`, etc.
     */
    connectorType?: ConnectorType;
    meta?: ExternalWalletMetadata;
};

/**
 * [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) auth flow.
 *
 * Privy's backend is able to issue access tokens using the [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) spec.
 * This enables developers to use Privy for reading/writing user *without* hosting their own backend to handle authentication. A big win for reducing operational complexity!
 */
declare class SiweApi {
    /**
     * Unlink a wallet account from a user. Note that you can only unlink a wallet account if the user has at least one other account.
     *
     * @returns The user object.
     */
    unlinkWallet(
    /**
     * The address of the wallet to be unlinked
     */
    address: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Link a new wallet via the [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) spec.
     *
     * @returns The user object.
     */
    linkWithSiwe(
    /**
     * Signature generated against standard [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message
     */
    signature: string, 
    /**
     * Optional `ExternalWallet`, only needed if the wallet differs from the one cached during previous call to `generateMessage`
     */
    walletOverride?: ExternalWallet, 
    /**
     * Optional [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message, only needed if the message differs from the one in memory that was cached in previous call to `generateMessage`
     */
    messageOverride?: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Authenticate with Privy via the [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) spec.
     *
     * @returns Session information.
     */
    loginWithSiwe(
    /**
     * Signature generated against standard [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message
     */
    signature: string, 
    /**
     * Optional `ExternalWallet`, only needed if the wallet differs from the one cached during previous call to `generateMessage`
     */
    walletOverride?: ExternalWallet, 
    /**
     * Optional [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message, only needed if the message differs from the one in memory that was cached in previous call to `generateMessage`
     */
    messageOverride?: string, 
    /**
     * Optional Whether or not to block sign ups (only allow existing users to log in).
     */
    mode?: 'login-or-sign-up' | 'no-signup', opts?: LoginOptions): Promise<Omit<AuthenticatedUser, 'session_update_action'>>;
    /**
     * Begin a login or link flow according to the [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) spec.
     *
     * @returns [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message and nonce used to create it
     */
    init(
    /** Wallet to request a [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) signature from */
    wallet: ExternalWallet, 
    /** [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) authority that is requesting the signing */
    domain: string, 
    /** [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) URI referring to the resource that is the subject of the signing */
    uri: string): Promise<{
        nonce: string;
        message: string;
    }>;
}

declare class SiwsApi {
    /**
     * Unlink a wallet account from a user.
     *
     * @returns the user object.
     */
    unlink({ address, }: {
        /**
         * The address of the wallet to be unlinked
         */
        address: string;
    }): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Link a wallet via Sign-In With Solana spec.
     *
     * @returns the user object
     */
    link({ message, signature, walletClientType, connectorType, }: {
        /**
         * The SIWS message
         */
        message: string;
        /**
         * Signature generated against the SIWS message
         */
        signature: string;
        /**
         * Metadata for the wallet account
         */
        walletClientType?: string;
        /**
         * Metadata for the wallet account
         */
        connectorType?: string;
    }): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Authenticate with a wallet via the Sign-In With Solana spec.
     *
     * @returns the user object
     */
    login({ mode, message, signature, walletClientType, connectorType, opts, }: {
        /**
         * The SIWS message
         */
        message: string;
        /**
         * Signature generated against the SIWS message
         */
        signature: string;
        /**
         * Metadata for the wallet account
         */
        walletClientType?: string;
        /**
         * Metadata for the wallet account
         */
        connectorType?: string;
        /**
         * Optional Whether or not to block sign ups (only allow existing users to log in).
         */
        mode?: 'login-or-sign-up' | 'no-signup';
        opts?: LoginOptions;
    }): Promise<Omit<AuthenticatedUser, 'session_update_action'>>;
    /**
     * Begin a "Sign-In With Solana" login or link flow
     *
     * @returns SIWS message to be signed
     */
    fetchNonce({ address, }: {
        /** Address of the wallet requesting sign in */
        address: string;
    }): Promise<{
        nonce: string;
    }>;
}

/**
 * [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) auth flow.
 *
 * Privy's backend is able to issue access tokens using the [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) spec.
 * This enables developers to use Privy for reading/writing user *without* hosting their own backend to handle authentication. A big win for reducing operational complexity!
 */
declare class SmartWalletApi {
    /**
     * Link a smart wallet via the [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) spec.
     *
     * @returns The user object.
     */
    link(
    /**
     * Signature generated against standard [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message
     */
    message: string, signature: string, smartWalletType: SmartWalletType, smartWalletVersion?: string): Promise<{
        user: _privy_io_api_types.User;
        identity_token: string | undefined;
    }>;
    /**
     * Begin a link flow according to the [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) spec for
     * a smart wallet.
     *
     * @returns [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message and nonce used to create it
     */
    init(
    /** Wallet to request a [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) signature from */
    wallet: {
        address: string;
        chainId: string;
    }): Promise<{
        nonce: string;
        message: string;
    }>;
}

declare class AuthApi {
    /**
     * APIs for login with a custom JWT
     */
    readonly customProvider: CustomProviderApi;
    /**
     * APIs for passwordless login with sms
     */
    readonly phone: PhoneApi;
    /**
     * APIs for passwordless login with email
     */
    readonly email: EmailApi;
    /**
     * APIs for login with OAuth
     */
    readonly oauth: OAuthApi;
    /**
     * APIs for login with wallets
     */
    readonly siwe: SiweApi;
    /**
     * APIs for login with wallets
     */
    readonly siws: SiwsApi;
    /**
     * APIs for linking smart wallets
     */
    readonly smartWallet: SmartWalletApi;
    /**
     * APIs for login with Passkeys
     */
    readonly passkey: PasskeyApi;
    /**
     * APIs for login with Farcaster
     */
    readonly farcaster: FarcasterApi;
    /**
     * @experimental
     * APIs for bare metal login with Farcaster
     */
    readonly farcasterV2: FarcasterV2Api;
    /**
     * APIs for guest login
     */
    readonly guest: GuestApi;
    /**
     * Logs the current user out.
     */
    logout(o?: {
        userId: string;
    }): Promise<void>;
}

declare class CoinbaseOnRampApi {
    /**
     * Creates a new on-ramp session in coinbase.
     * @returns the session information for this on-ramp flow
     */
    initOnRampSession(args: CoinbaseOnRampInitInput): Promise<_privy_io_api_types.CoinbaseOnRampInitResponse>;
    /**
     * Fetch the status of a Coinbase on-ramp flow
     */
    getStatus(partnerUserId: string): Promise<_privy_io_api_types.CoinbaseOnRampStatusResponse>;
}

/**
 * Funding method type.
 */
type FundingMethod = 'card' | 'payment-request' | 'exchange' | 'wallets' | 'manual';
/**
 * Funding provider type.
 */
type FundingProvider = 'coinbase' | 'moonpay';
/**
 * Payment option type.
 */
type PaymentOption = {
    method: FundingMethod;
    provider: FundingProvider;
};

type MoonpayTransactionStatusWithoutFailures = 'pending' | 'waitingAuthorization' | 'completed';
type MoonpayTransactionStatus = MoonpayTransactionStatusWithoutFailures | 'failed' | 'serviceFailure';
/**
 * Cryptocurrency codes for the MoonPay fiat on-ramp. These codes
 * follow the format {TOKEN_NAME}_{NETWORK_NAME}.
 */
type MoonpayCurrencyCode = 'AVAX_CCHAIN' | 'CELO_CELO' | 'CUSD_CELO' | 'DAI_ETHEREUM' | 'ETH_ETHEREUM' | 'ETH_ARBITRUM' | 'ETH_POLYGON' | 'ETH_BASE' | 'FIL_FVM' | 'MATIC_ETHEREUM' | 'MATIC_POLYGON' | 'POL_POLYGON' | 'POL_ETHEREUM' | 'USDC_ETHEREUM' | 'USDC_ARBITRUM' | 'USDC_OPTIMISM' | 'USDC_POLYGON' | 'USDC_BASE' | 'USDC_CCHAIN' | 'USDC_SOL' | 'USDT_ETHEREUM' | 'USDT_POLYGON' | 'WETH_POLYGON' | 'WBTC_ETHEREUM' | 'BNB_BNB' | 'BNB_BSC' | 'SOL';
type MoonpayTransactionStatusResponse = {
    status?: MoonpayTransactionStatus;
    paymentMethod?: string;
    cardPaymentType?: string;
    currency?: {
        code: string;
    };
    baseCurrencyAmount?: string;
    quoteCurrencyAmount?: string;
    feeAmount?: string;
    extraFeeAmount?: string;
    networkFeeAmount?: string;
    getValidQuote?: {
        quoteCurrencyAmount?: number;
    };
};
declare function isSupportedChainIdForMoonpay(chainId: number, asset: 'native-currency' | 'USDC'): boolean;
/**
 * Maps the privy chain to the moonpay currency. We currently only support ETH, which is hardcoded here.
 * When we support multiple tokens, they will need to be taken into account as input here.
 */
declare function chainToMoonpayCurrency(chainId: number, asset: 'native-currency' | 'USDC'): MoonpayCurrencyCode;
declare function fundingMethodToMoonpayPaymentMethod(method: FundingMethod): MoonpayOnRampSignInput['config']['paymentMethod'];

declare class MoonpayOnRampApi {
    /**
     * Sign Moonpay OnRamp arguments for a new flow
     */
    sign(args: MoonpayOnRampSignInput): Promise<_privy_io_api_types.MoonpayOnRampSignResponse>;
    /**
     * Fetch the status of a Moonpay transaction
     * @param transactionId
     * @param useSandbox
     * @returns
     */
    getTransactionStatus({ transactionId, useSandbox, }: {
        transactionId: string;
        useSandbox: boolean;
    }): Promise<MoonpayTransactionStatusResponse | undefined>;
}

declare class FundingApi {
    /**
     * API for Moonpay On-ramp
     */
    readonly moonpay: MoonpayOnRampApi;
    /**
     * API for Coinbase On-ramp
     */
    readonly coinbase: CoinbaseOnRampApi;
}

declare class MfaPasskeyApi {
    /**
     * Initiate Passkey MFA flow
     */
    generateAuthenticationOptions(args: MfaPasskeyInitRequestBody): Promise<_privy_io_api_types.MfaPasskeyInitResponseBody>;
}

declare class MfaSmsApi {
    /**
     * Initiate SMS MFA flow
     */
    sendCode(args: MfaSMSInitRequestBody): Promise<{
        success: boolean;
    }>;
}

type InitMfaEnrollmentParams = {
    method: 'sms';
    phoneNumber: string;
} | {
    method: 'totp';
};
type SubmitMfaEnrollmentParams = {
    method: 'sms';
    code: string;
    phoneNumber: string;
} | {
    method: 'totp';
    code: string;
} | {
    method: 'passkey';
    credentialIds: string[];
    removeForLogin?: boolean;
};
declare class MfaApi {
    /**
     * API for SMS MFA
     */
    readonly sms: MfaSmsApi;
    /**
     * API for Passkey MFA
     */
    readonly passkey: MfaPasskeyApi;
    /**
     * Sends privy:mfa:verify event to the embedded wallet iframe. If MFA is required, the proxy will emit an
     * event through the MfaApi instance.
     */
    verifyMfa(): Promise<MfaVerifyResponseDataType>;
    /**
     * Sends privy:mfa:init-enrollment event to the embedded wallet iframe. If MFA is required, the proxy will emit an
     * event through the MfaApi instance.
     */
    initEnrollMfa(args: InitMfaEnrollmentParams): Promise<MfaInitEnrollmentResponseDataType>;
    /**
     * Sends privy:mfa:submit-enrollment event to the embedded wallet iframe. If MFA is required, the proxy will emit an
     * event through the MfaApi instance.
     */
    submitEnrollMfa(args: SubmitMfaEnrollmentParams): Promise<MfaSubmitEnrollmentResponseDataType>;
    /**
     * Sends privy:mfa:unenroll event to the embedded wallet iframe. If MFA is required, the proxy will emit an
     * event through the MfaApi instance.
     */
    unenrollMfa(method: 'sms' | 'totp'): Promise<MfaUnenrollResponseDataType>;
    /**
     * Sends privy:mfa:clear event to the embedded wallet iframe.
     */
    clearMfa(args: {
        userId: string;
    }): Promise<MfaClearResponseDataType>;
}

declare class RecoveryICloudApi {
    /**
     * Starts a Recovery iCloud flow
     *
     * @param provider The OAuth provider
     * @param redirectURI The URL to redirect to after a successful OAuth flow
     */
    init(client_type: 'web' | 'expo-ios'): Promise<_privy_io_api_types.OAuthInitResponseBody>;
    /**
     * Pulls the iCloud configuration for recovery
     *
     * @param client_type The querying client (web | expo-ios)
     */
    getICloudConfiguration(client_type: 'web' | 'expo-ios'): Promise<_privy_io_api_types.RecoveryConfigurationICloudResponseBody>;
}

declare class RecoveryOAuthApi {
    /**
     * Starts a Recovery OAuth flow with a specific provider
     *
     * @param provider The OAuth provider
     * @param redirectURI The URL to redirect to after a successful OAuth flow
     */
    generateURL(redirectURI: string): Promise<_privy_io_api_types.OAuthInitResponseBody>;
    /**
     * Completes the recovery OAuth login flow for user
     *
     * @param authorizationCode The code generated by the authorization server
     * @param returnedStateCode The state value initially set in the request by Privy to the authorization server
     */
    authorize(authorizationCode: string, returnedStateCode: string): Promise<_privy_io_api_types.RecoveryOAuthAuthenticateResponseBody>;
}

declare class RecoveryApi {
    /**
     * APIs for recovery auth with OAuth
     */
    readonly auth: RecoveryOAuthApi;
    /**
     * APIs for recovery auth with iCloud
     */
    readonly icloudAuth: RecoveryICloudApi;
    /**
     * Pulls the recovery material
     *
     * @param address The embedded wallet's address
     * @param chain_type The chain_type to fetch the recovery material for
     */
    getRecoveryKeyMaterial(address: string, chain_type?: string): Promise<_privy_io_api_types.RecoveryKeyMaterialResponseBody>;
}

/**
 * `PrivyOptions` to setup the `Privy` SDK
 */
type PrivyOptions = {
    /** The `Storage` instance to be used */
    storage: Storage;
    /** The application ID */
    appId: string;
    /** The client ID */
    clientId?: string;
    /** A reference the the embedded wallet iframe content window */
    embeddedWalletMessagePoster?: EmbeddedWalletMessagePoster;
    /**
     * A list of supported chains, used to specify which chains should be used throughout the application.
     * **Overrides the default list of supported chains.** Calling `sendTransaction` or `switchChain` on
     * an unsupported network will throw an error.
     *
     * For embedded wallets, the wallet will automatically default to the first supplied `supportedChain`.
     */
    supportedChains?: NonEmptyArray<Chain>;
};
/**
 * Privy API Client SDK
 */
declare class Privy {
    /**
     * APIs for interacting with a user's embedded wallet
     */
    readonly auth: AuthApi;
    /**
     * APIs for fetching user data
     */
    readonly user: UserApi;
    /**
     * APIs for interacting with a user's embedded wallet
     */
    readonly embeddedWallet: EmbeddedWalletApi;
    /**
     * APIs for recovery auth with OAuth
     */
    readonly recovery: RecoveryApi;
    /**
     * APIs for MFA auth
     */
    readonly mfa: MfaApi;
    /**
     * APIs for App configurations
     */
    readonly app: AppApi;
    /**
     * Promises for MFA flows
     */
    readonly mfaPromises: MfaPromises;
    /**
     * APIs for Funding
     */
    readonly funding: FundingApi;
    /**
     * APIs for Wallet Delegated Actions
     */
    readonly delegated: DelegatedWalletsApi;
    /**
     * APIs for Cross App Connections
     */
    readonly crossApp: CrossAppApi;
    /** Create a new `Privy` Client */
    constructor({ clientId, ...o }: PrivyOptions);
    /**
     * Initialize the SDK
     *
     * @returns void
     * @throws if there are errors
     */
    initialize(): Promise<void>;
    setMessagePoster(poster: EmbeddedWalletMessagePoster): void;
    getAccessToken(): Promise<string | null>;
    getIdentityToken(): Promise<string | null>;
    getCompiledPath<const T extends Route<U, V>, const U, const V>(r: T, opts: {
        body?: T['body'];
        params?: Record<string, string | number>;
        headers?: HeadersInit;
    }): string;
    fetchPrivyRoute<const T extends Route<U, V>, const U, const V>(r: T, opts: {
        body?: T['body'];
        params?: Record<string, string | number>;
        headers?: HeadersInit;
    }): Promise<NonNullable<T['response']>>;
    /**
     * Internal logger for the Privy client.
     */
    get logger(): Logger;
}

declare class LocalStorage implements Storage {
    get(key: string): Promise<any>;
    put(key: string, val: unknown): void;
    del(key: string): void;
    getKeys(): string[];
}

declare class InMemoryCache implements Storage {
    private _cache;
    get(key: string): unknown;
    put(key: string, val: unknown): void;
    del(key: string): void;
    getKeys(): string[];
}

/**
 * @description Finds the embedded wallet account (if it exists) for a given user.
 *
 * @param user A privy user object
 *
 * @returns The user's embedded wallet account
 *
 * @example
 * const account = getUserEmbeddedWallet(user)
 * console.log(account.address)
 */
declare const getUserEmbeddedEthereumWallet: (user: User | null) => LinkedAccountEthereumEmbeddedWallet | null;
/**
 * @deprecated use `getUserEmbeddedEthereumWallet` instead
 */
declare const getUserEmbeddedWallet: (user: User | null) => LinkedAccountEthereumEmbeddedWallet | null;

/**
 * @description Finds all of the embedded ethereum wallet accounts for a user.
 *
 * @param user A privy user object
 *
 * @returns The user's embedded ethereum wallet accounts, sorted by wallet_index.
 *
 * @example
 * const accounts = getAllUserEmbeddedEthereumWallet(user)
 */
declare const getAllUserEmbeddedEthereumWallets: (user: User | null) => LinkedAccountEthereumEmbeddedWallet[];

/**
 * @description Finds all of the embedded Solana wallet accounts for a user.
 *
 * @param user A privy user object
 *
 * @returns The user's embedded Solana wallet accounts, sorted by wallet_index.
 *
 * @example
 * const accounts = getAllUserEmbeddedSolanaWallet(user)
 */
declare const getAllUserEmbeddedSolanaWallets: (user: User | null) => LinkedAccountSolanaEmbeddedWallet[];

/**
 * @description Finds all of the embedded Bitcoin wallet accounts for a user.
 *
 * @param user A privy user object
 *
 * @returns The user's embedded Bitcoin wallet accounts, sorted by wallet_index.
 *
 * @example
 * const accounts = getAllUserEmbeddedBitcoinWallets(user)
 */
declare const getAllUserEmbeddedBitcoinWallets: (user: User | null) => (LinkedAccountBitcoinSegwitEmbeddedWallet | LinkedAccountBitcoinTaprootEmbeddedWallet)[];

/**
 * Determines if a given wallet account is an embedded wallet account.
 *
 * @param account a linked account
 * @returns whether the account is an embedded wallet account
 */
declare const isEmbeddedWalletAccount: (account: LinkedAccount) => account is LinkedAccountEmbeddedWallet;

type EmbeddedWalletAccount = LinkedAccountEthereumEmbeddedWallet | LinkedAccountSolanaEmbeddedWallet;
/**
 * Get the entropyId and entropyIdVerifier given a privy user and an optional account.
 *
 * @param user the privy user
 * @param signingAccount (optional) the signing wallet
 *
 * @returns the entropy ID and entropy ID verifier for the account
 */
declare const getEntropyDetailsFromUser: (user: User | null, signingAccount?: EmbeddedWalletAccount) => {
    entropyId: string;
    entropyIdVerifier: EntropyIdVerifier;
} | null;
/**
 * Get the entropyId and entropyIdVerifier given an Ethereum or Solana account.
 *
 * @param account the embedded wallet account
 *
 * @returns the correct entropy ID and entropy ID verifier for the account
 */
declare const getEntropyDetailsFromAccount: (account: LinkedAccountEthereumEmbeddedWallet | LinkedAccountSolanaEmbeddedWallet) => {
    entropyId: string;
    entropyIdVerifier: EntropyIdVerifier;
};

/**
 * @description Finds the embedded smart wallet account for a given user.
 *
 * @param user A privy user object
 *
 * @returns The user's smart wallet account
 *
 * @example
 * const account = getUserSmartWallet(user)
 */
declare const getUserSmartWallet: (user: User | null) => LinkedAccountSmartWallet | null;

/**
 * Build a JSON RPC endpoint for a given chainId if it is one of our
 * supported chains.
 */
declare const getJsonRpcEndpointFromChain: (chain: Chain, rpcConfig: RpcConfig, privyAppId: string) => string;
/**
 * Ensure that the recovery upgrade path is valid.
 *
 * @param currentRecoveryType The existing wallet's recovery type
 * @param upgradeToRecoveryType The desired recovery type
 */
declare function throwIfInvalidRecoveryUpgradePath({ currentRecoveryMethod, upgradeToRecoveryMethod, }: {
    currentRecoveryMethod: EmbeddedWalletRecoveryOptions;
    upgradeToRecoveryMethod: IEmbeddedWalletRecoveryOptions;
}): boolean;

/**
 * Do a lightweight validation of phone number. We'll do much heavier validation
 * on the backend, so this just needs to be sensible. This hints a default country
 * code of the US/+1, but will work for international numbers, provided they give
 * the country code in the number (ie +49 123123123).
 */
declare const validatePhoneNumber: (phoneNumber: string, countryCode: CountryCode) => boolean;
declare const formatPhoneNumber: (phoneNumber: string, countryCode: CountryCode) => string;
declare const lastFourDigits: (phoneNumber: string) => string;
declare const phoneNumberTypingFormatter: (countryCode: CountryCode) => AsYouType;
declare const countryCodesAndNumbers: {
    code: CountryCode;
    callCode: CountryCallingCode;
}[];
declare const getPlaceholderPhoneNumber: (countryCode: CountryCode) => string | undefined;
declare const getPhoneCountryCodeAndNumber: (phoneNumber: string) => {
    countryCode: CountryCode;
    phone: string;
};

/**
 * @description Finds the primary (HD index = 0) embedded Solana wallet account for a given user.
 *
 * @param user A privy user object
 *
 * @returns The user's primary embedded Solana wallet account
 *
 * @example
 * const account = getUserEmbeddedSolanaWallet(user)
 */
declare const getUserEmbeddedSolanaWallet: (user: User | null) => LinkedAccountSolanaEmbeddedWallet | null;

/**
 * Given an array, convert it into an object with a supplied value per key
 */
declare const toObjectKeys: <TArray extends Array<string>, TValue = true>(array: TArray, value?: TValue) => Record<TArray[number], TValue>;

type Cluster = 'devnet' | 'testnet' | 'mainnet-beta';
type SolanaCluster = {
    /**
     * The network name
     * Refer to {@link https://solana-foundation.github.io/solana-web3.js/types/Cluster.html Cluster} for more information
     * */
    name: Cluster;
    /** The RPC endpoint */
    rpcUrl?: string;
};
/**
 * Helper type for defining a Standard Wallet with a union of Solana features.
 */
type SolanaStandardWallet = WalletWithFeatures<{
    'standard:connect'?: StandardConnectFeature['standard:connect'];
    'standard:disconnect'?: StandardDisconnectFeature['standard:disconnect'];
    'standard:events'?: StandardEventsFeature['standard:events'];
    'solana:signMessage'?: SolanaSignMessageFeature['solana:signMessage'];
    'solana:signTransaction'?: SolanaSignTransactionFeature['solana:signTransaction'];
    'solana:signAndSendTransaction'?: SolanaSignAndSendTransactionFeature['solana:signAndSendTransaction'];
    'solana:signIn'?: SolanaSignInFeature['solana:signIn'];
}>;
/**
 * Helper type for defining a Standard Wallet with a union of Solana features.
 */
type IdentifierString = `${string}:${string}`;
/** Input for signing a message. */
type SolanaSignMessageInput = {
    /** Message to sign, as raw bytes. */
    message: Uint8Array;
};
/** Output of signing a message. */
type SolanaSignMessageOutput = {
    /**
     * Message bytes that were signed.
     * The wallet may prefix or otherwise modify the message before signing it.
     */
    signedMessage: Uint8Array;
    /**
     * Message signature produced.
     * If the signature type is provided, the signature must be Ed25519.
     */
    signature: Uint8Array;
    /**
     * Optional type of the message signature produced.
     * If not provided, the signature must be Ed25519.
     */
    signatureType?: 'ed25519';
};
/** Input for signing a transaction. */
type SolanaSignTransactionInput = {
    /** Serialized transaction, as raw bytes. */
    transaction: Uint8Array;
    /** Chain to use. */
    chain?: IdentifierString;
    /** Options for signing a transaction. */
    options?: SolanaSignTransactionOptions;
};
/** Output of signing a transaction. */
type SolanaSignTransactionOutput = {
    /**
     * Signed, serialized transaction, as raw bytes.
     * Returning a transaction rather than signatures allows multisig wallets, program wallets, and other wallets that
     * use meta-transactions to return a modified, signed transaction.
     */
    signedTransaction: Uint8Array;
};
/** Options for signing a transaction. */
type SolanaSignTransactionOptions = {
    /** Preflight commitment level. */
    preflightCommitment?: SolanaTransactionCommitment;
    /** The minimum slot that the request can be evaluated at. */
    minContextSlot?: number;
};
/** Commitment level for transactions. */
type SolanaTransactionCommitment = 'processed' | 'confirmed' | 'finalized';
/** Input for signing and sending a transaction. */
type SolanaSignAndSendTransactionInput = SolanaSignTransactionInput & {
    /** Chain to use. */
    chain: IdentifierString;
    /** Options for signing and sending a transaction. */
    options?: SolanaSignAndSendTransactionOptions;
};
/** Output of signing and sending a transaction. */
type SolanaSignAndSendTransactionOutput = {
    /** Transaction signature, as raw bytes. */
    signature: Uint8Array;
};
/** Options for signing and sending a transaction. */
type SolanaSignAndSendTransactionOptions = SolanaSignTransactionOptions & {
    /** Mode for signing and sending transactions. */
    mode?: SolanaSignAndSendTransactionMode;
    /** Desired commitment level. If provided, confirm the transaction after sending. */
    commitment?: SolanaTransactionCommitment;
    /** Disable transaction verification at the RPC. */
    skipPreflight?: boolean;
    /** Maximum number of times for the RPC node to retry sending the transaction to the leader. */
    maxRetries?: number;
};
/** Mode for signing and sending transactions. */
type SolanaSignAndSendTransactionMode = 'parallel' | 'serial';

declare const UsdcAddressMap: Record<number, Hex>;
declare const SolanaUsdcAddressMap: Record<Cluster, string>;
/**
 * Helper function to determine if a token address is one of our known USDC addresses
 *
 * @param address {string} token address
 * @param chain {Chain} chain where token lives
 * @returns {boolean}
 */
declare function getIsTokenUsdc(address: string, chain: Chain): boolean;

/**
 * Generates a SHA-256 idempotency key for automatic wallet creation.
 *
 * The key is scoped to the user and chain type to prevent duplicate wallet
 * creation from concurrent calls while allowing different users and chain
 * types to create wallets independently.
 *
 * Input: `${userId}-auto-${eth|sol}`
 * Output: SHA-256 hash (hex string)
 *
 * @param userId The user's ID
 * @param chainType The chain type ('ethereum' or 'solana')
 * @returns The hashed idempotency key
 */
declare function generateWalletIdempotencyKey(userId: string, chainType: 'ethereum' | 'solana'): Promise<string>;

declare const ASSET_ID_MAP: {
    readonly USDC: "2b92315d-eab7-5bef-84fa-089a131333f5";
    readonly ETH: "d85dce9b-5b73-5c3c-8978-522ce1d1c1b4";
    readonly BTC: "5b71fc48-3dd3-540c-809b-f8c94d0e68b5";
    readonly SOL: "4f039497-3af8-5bb3-951c-6df9afa9be1c";
    readonly POL: "026bcc1e-9163-591c-a709-34dd18b2e7a1";
};
type CoinbaseAssetId = keyof typeof ASSET_ID_MAP;
type SupportedBlockchains = CoinbaseOnRampInitInput['addresses'][0]['blockchains'][0];
declare function getCoinbaseOnRampUrl({ appId, input, amount, blockchain, asset, experience, }: {
    appId: string;
    input: CoinbaseOnRampInitResponse;
    amount: string;
    blockchain: SupportedBlockchains;
    asset: CoinbaseAssetId;
    experience: 'buy' | 'send';
}): {
    url: URL;
};
declare const isSupportedChainIdForCoinbaseOnramp: (chainId: number, asset: "native-currency" | "USDC") => boolean;
/**
 * Returns the Coinbase blockchain name given a chain ID. Currently unsupported chains
 * include: solana, bitcoin, stellar
 */
declare function toCoinbaseBlockchainFromChainId(chainId: number): SupportedBlockchains | undefined;
declare function toCoinbaseAssetId(chainId: number, asset: 'USDC' | 'native-currency'): CoinbaseAssetId;

declare class SolanaClient {
    cluster: SolanaCluster & {
        rpcUrl: string;
    };
    constructor(cluster: SolanaCluster & {
        rpcUrl: string;
    });
    private invokeRpc;
    getBalance(address: string): Promise<bigint | null>;
    getTokenAccountsByOwner(address: string, mintAddress: string): Promise<{
        amount: bigint;
        decimals: number;
    } | null>;
    getAccountInfo(address: string): Promise<{
        decimals: number;
    } | null>;
}

type CreateSiwsMessageOpts = {
    /**
     * Address of the wallet
     */
    address: string;
    /**
     * [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) authority that is requesting the signature
     */
    domain: string;
    /**
     *[RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) URI referring to the resource that is the subject of the signature
     */
    uri: string;
    /**
     * Randomized token used to prevent replay attacks
     */
    nonce: string;
};
/**
 * Creates an EIP-4361 message for signing that is retrofitted for Solana
 *
 * @returns message for signing
 */
declare const createSiwsMessage: ({ address, nonce, domain, uri }: CreateSiwsMessageOpts) => string;

declare function getSolanaRpcEndpointForCluster({ name, rpcUrl }: SolanaCluster): string;

declare function getSolanaUsdcMintAddressForCluster({ name }: SolanaCluster): "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" | "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU";

/**
 * Get the display name for a Solana cluster. This is used in the UI to show the cluster name.
 * Users don't know/care what mainnet-beta is, they just want to see "Solana".
 * "Testnet" and "Devnet" are meant for devs, they will know what it means (hopefully)
 *
 * @param name The cluster name
 */
declare function getSolanaClusterDisplayName(name: Cluster): "Solana" | "Testnet" | "Devnet";

/**
 * Formats a wallet address by showing the first 5 characters, followed by an ellipsis,
 * and then the last 4 characters.
 * @param address
 */
declare function formatWalletAddress(address: string | undefined): string;
/**
 * Converts a wei value into a native currency price, given the token symbol of the native
 * currency. Returns a string with the native currency price of the wei value, rounded to 3
 * decimals.
 */
declare function formatWeiAmount({ wei, precision }: {
    wei: bigint;
    precision?: number;
}): string;
/**
 * Format token amount with a given number of decimal.
 */
declare function formatTokenAmount({ amount, decimals }: {
    amount: bigint | number;
    decimals: number;
}): string;
/**
 * Format a Solana amount in lamports.
 */
declare function formatLamportsAmount({ lamports }: {
    lamports: bigint;
}): string;

interface DelegateWalletInput {
    /** address of the wallet to delegate */
    address: string;
    /** chain type for the wallet to delegate */
    chainType: 'solana' | 'ethereum';
}
/**
 * Delegates access to the wallet to allow an app to transact on behalf of a user within a set of
 * pre-defined permissions.
 *
 * Users should be visible prompted for it, and always given the option to decline or revoke
 * delegation.
 *
 * @param address {string} address of the wallet to delegate
 * @param chainType {'solana' | 'ethereum'} chain type for the wallet to delegate
 */
declare const delegateWallet: (client: Privy) => ({ address, chainType }: DelegateWalletInput) => Promise<{
    user: _privy_io_api_types.User;
}>;

/**
 * Revokes the wallet API's ability to transact with a user's delegated wallets. This will revoke
 * ALL wallets that have been delegated by the user, in case the user has delegated multiple
 * embedded wallets.
 *
 * @returns Promise that resolves if the revocation was successful, with the updated user object,
 * and errors otherwise
 */
declare const revokeWallets: (client: Privy) => () => Promise<{
    user: _privy_io_api_types.User;
}>;

declare const index$2_delegateWallet: typeof delegateWallet;
declare const index$2_revokeWallets: typeof revokeWallets;
declare namespace index$2 {
  export { index$2_delegateWallet as delegateWallet, index$2_revokeWallets as revokeWallets };
}

interface LoginWithCrossAppAuthDependencies {
    client: Privy;
    openAuthSession: (url: string, redirectUrl?: string) => Promise<Record<string, string>>;
}
interface LoginWithCrossAppAuthInput {
    providerAppId: string;
    redirectUrl: string;
}
type LoginWithCrossAppAuthOutput = Omit<AuthenticatedUser, 'session_update_action'>;
/**
 * Logs a user into your app through an account on **another Privy app**.
 *
 * @param options.providerAppId the Privy app ID to which the external account should belong.
 * @param options.redirectUrl a URL path used to redirect back to your app after successful authentication
 * @returns a promise that resolves with the new session
 */
declare const loginWithCrossAppAuth: ({ client, openAuthSession }: LoginWithCrossAppAuthDependencies) => ({ providerAppId, redirectUrl, }: LoginWithCrossAppAuthInput) => Promise<LoginWithCrossAppAuthOutput>;

interface LinkWithCrossAppAuthDependencies {
    client: Privy;
    openAuthSession: (url: string, redirectUrl?: string) => Promise<Record<string, string>>;
}
interface LinkWithCrossAppAuthInput {
    providerAppId: string;
    redirectUrl: string;
}
type LinkWithCrossAppAuthOutput = User;
/**
 * Links an account on **another Privy app** to the currently logged-in user in your app.
 *
 * @param options.providerAppId the Privy app ID from which the external account should be linked
 * @param options.redirectUrl a URL path used to redirect back to your app after successful authentication
 * @returns a promise that resolves with the user object
 */
declare const linkWithCrossAppAuth: ({ client, openAuthSession }: LinkWithCrossAppAuthDependencies) => ({ providerAppId, redirectUrl, }: LinkWithCrossAppAuthInput) => Promise<LinkWithCrossAppAuthOutput>;

interface SignMessageDependencies {
    client: Privy;
    openAuthSession: (url: string) => Promise<Record<string, string>>;
}
interface SignMessageInput {
    /** The logged in user object */
    user: User | null;
    /** An arbitrary message to be signed */
    message: string;
    /** Wallet address of the cross-app wallet to sign the message with */
    address: string;
    /** Return url for the auth session */
    redirectUrl: string;
}
interface SignMessageOutput {
    /** The resulting signature of the provided message */
    signature: string;
}
/**
 * Requests a cross-app wallet to sign a message, returning the resulting signature.
 */
declare const signMessage: ({ client, openAuthSession }: SignMessageDependencies) => ({ user, address, message, redirectUrl, }: SignMessageInput) => Promise<SignMessageOutput>;

interface SignTypedDataDependencies {
    client: Privy;
    openAuthSession: (url: string) => Promise<Record<string, string>>;
}
interface SignTypedDataInput {
    /** The logged in user object */
    user: User | null;
    /** The typed data to be signed */
    typedData: TypedDataDefinition;
    /** Wallet address of the cross-app wallet to sign the message with */
    address: string;
    /** Return url for the auth session */
    redirectUrl: string;
}
interface SignTypedDataOutput {
    /** The resulting signature of the provided typed data */
    signature: string;
}
/**
 * Requests a cross-app wallet to sign a typed data object, returning the resulting signature.
 */
declare const signTypedData: ({ client, openAuthSession }: SignTypedDataDependencies) => ({ user, typedData, address, redirectUrl, }: SignTypedDataInput) => Promise<SignTypedDataOutput>;

interface SendTransactionDependencies {
    client: Privy;
    openAuthSession: (url: string) => Promise<Record<string, string>>;
}
interface SendTransactionInput {
    /** The logged in user object */
    user: User | null;
    /** The transaction to execute */
    transaction: UnsignedTransactionRequest;
    /** Wallet address of the cross-app wallet to make the transaction with */
    address: string;
    /** Return url for the auth session */
    redirectUrl: string;
}
interface SendTransactionOutput {
    /** The hash of the resulting transaction */
    transactionHash: string;
}
/**
 * Requests a cross-app wallet to send a transaction, returning the resulting transaction hash.
 */
declare const sendTransaction: ({ client, openAuthSession }: SendTransactionDependencies) => ({ user, transaction, address, redirectUrl, }: SendTransactionInput) => Promise<SendTransactionOutput>;

type index$1_SendTransactionDependencies = SendTransactionDependencies;
type index$1_SendTransactionInput = SendTransactionInput;
type index$1_SendTransactionOutput = SendTransactionOutput;
type index$1_SignMessageDependencies = SignMessageDependencies;
type index$1_SignMessageInput = SignMessageInput;
type index$1_SignMessageOutput = SignMessageOutput;
type index$1_SignTypedDataDependencies = SignTypedDataDependencies;
type index$1_SignTypedDataInput = SignTypedDataInput;
type index$1_SignTypedDataOutput = SignTypedDataOutput;
declare const index$1_sendTransaction: typeof sendTransaction;
declare const index$1_signMessage: typeof signMessage;
declare const index$1_signTypedData: typeof signTypedData;
declare namespace index$1 {
  export { type index$1_SendTransactionDependencies as SendTransactionDependencies, type index$1_SendTransactionInput as SendTransactionInput, type index$1_SendTransactionOutput as SendTransactionOutput, type index$1_SignMessageDependencies as SignMessageDependencies, type index$1_SignMessageInput as SignMessageInput, type index$1_SignMessageOutput as SignMessageOutput, type index$1_SignTypedDataDependencies as SignTypedDataDependencies, type index$1_SignTypedDataInput as SignTypedDataInput, type index$1_SignTypedDataOutput as SignTypedDataOutput, index$1_sendTransaction as sendTransaction, index$1_signMessage as signMessage, index$1_signTypedData as signTypedData };
}

type index_LinkWithCrossAppAuthDependencies = LinkWithCrossAppAuthDependencies;
type index_LinkWithCrossAppAuthInput = LinkWithCrossAppAuthInput;
type index_LinkWithCrossAppAuthOutput = LinkWithCrossAppAuthOutput;
type index_LoginWithCrossAppAuthDependencies = LoginWithCrossAppAuthDependencies;
type index_LoginWithCrossAppAuthInput = LoginWithCrossAppAuthInput;
type index_LoginWithCrossAppAuthOutput = LoginWithCrossAppAuthOutput;
declare const index_linkWithCrossAppAuth: typeof linkWithCrossAppAuth;
declare const index_loginWithCrossAppAuth: typeof loginWithCrossAppAuth;
declare namespace index {
  export { type index_LinkWithCrossAppAuthDependencies as LinkWithCrossAppAuthDependencies, type index_LinkWithCrossAppAuthInput as LinkWithCrossAppAuthInput, type index_LinkWithCrossAppAuthOutput as LinkWithCrossAppAuthOutput, type index_LoginWithCrossAppAuthDependencies as LoginWithCrossAppAuthDependencies, type index_LoginWithCrossAppAuthInput as LoginWithCrossAppAuthInput, type index_LoginWithCrossAppAuthOutput as LoginWithCrossAppAuthOutput, index_linkWithCrossAppAuth as linkWithCrossAppAuth, index_loginWithCrossAppAuth as loginWithCrossAppAuth, index$1 as wallet };
}

interface SignWalletRequestInput {
    /**
     * The base64 encoded payload to sign.
     */
    message: string;
}
interface SignWalletRequestOutput {
    /**
     * The base64 encoded signature of the input message.
     */
    signature: string;
}
/**
 * Signs a wallets API request for authorization.
 */
type SignWalletRequest = (input: SignWalletRequestInput) => Promise<SignWalletRequestOutput>;

interface GenerateAuthorizationSignatureInput {
    version: 1;
    method: 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    url: string;
    body: any;
    timestamp?: number;
    headers: {
        'privy-app-id': string;
        'privy-idempotency-key'?: string;
    };
}
interface GenerateAuthorizationSignatureOutput {
    signature: string;
}
/**
 * Generates an authorization signature for a given wallet API request,
 * with the user's authorization key.
 *
 * @see {@link https://docs.privy.io/api-reference/authorization-signatures |Authorization signatures}
 *
 * @param sign A function that signs a wallet request
 * @param payload The request payload to sign.
 * @returns The user's authorization signature over the API request.
 */
declare function generateAuthorizationSignature(sign: SignWalletRequest, payload: GenerateAuthorizationSignatureInput): Promise<GenerateAuthorizationSignatureOutput>;

/**
 * The values and methods that Wallet API actions need access to.
 */
interface WalletApiActionContext {
    fetchPrivyRoute: Privy['fetchPrivyRoute'];
    getCompiledPath: Privy['getCompiledPath'];
    app: {
        appId: Privy['app']['appId'];
    };
}

type Input$3 = {
    request: WalletCreateParams;
    headers?: HeadersInit;
};
/**
 * Creates a new wallet through the Wallet API.
 *
 * @param context The context needed to execute the action
 * @param request The input to the Wallet API create request
 * @param headers Optional headers to include in the request
 * @returns The Response from the Wallet API create request
 */
declare function create(context: WalletApiActionContext, { request, headers }: Input$3): Promise<Wallet>;

type Input$2 = WalletRpcParams & {
    wallet_id: string;
};
/**
 * Executes a Wallet API RPC request.
 *
 * @param context The context needed to execute the action
 * @param sign A function that signs a wallet request
 * @param input The input to the Wallet API RPC request
 * @returns The response from the Wallet API RPC request
 */
declare function rpc(context: WalletApiActionContext, sign: SignWalletRequest, { wallet_id, ...request }: Input$2): Promise<WalletRpcResponse>;

type Input$1 = WalletRawSignParams & {
    wallet_id: string;
};
/**
 * Executes a Wallet API raw sign request.
 *
 * This is only available on extended chains and not Ethereum or Solana.
 *
 * @param context The context needed to execute the action
 * @param sign A function that signs a wallet request
 * @param input The input to the Wallet API raw sign request
 * @returns The response from the Wallet API raw sign request
 */
declare function rawSign(context: WalletApiActionContext, sign: SignWalletRequest, { wallet_id, ...request }: Input$1): Promise<WalletRawSignResponse>;

/**
 * Fetches a wallet through the Wallet API.
 *
 * @param context The context needed to execute the action
 * @param wallet_id The ID of the wallet to fetch
 * @returns The response from the Wallet API get request
 */
declare function getWallet(context: WalletApiActionContext, { wallet_id }: {
    wallet_id: string;
}): Promise<Wallet>;

type Input = Pick<WalletUpdateParams, 'additional_signers'>;
/**
 * Updates a wallet through the Wallet API.
 *
 * @param context The context needed to execute the action
 * @param wallet_id The ID of the wallet to update
 * @param sign A function that signs a wallet request
 * @param input The input to the Wallet API update request
 * @returns The response from the Wallet API update request
 */
declare function updateWallet(context: WalletApiActionContext, { wallet_id }: {
    wallet_id: string;
}, sign: SignWalletRequest, input: Input): Promise<Wallet>;

/**
 * Determines if a given wallet account is built on the unified stack.
 *
 * @param account an embedded wallet account linked to the user
 * @returns whether the wallet is a user-owned server wallet
 */
declare const isUnifiedWallet: (account: LinkedAccountEmbeddedWallet) => account is LinkedAccountEmbeddedWalletWithID;

interface SessionSigner {
    signer_id: string;
    override_policy_ids: string[];
}
interface AddSessionSignersInput {
    client: Privy;
    wallet: LinkedAccountEmbeddedWallet;
    signers: SessionSigner[];
}
interface AddSessionSignersOutput {
    user: User;
}
/**
 * Grants access of the wallet to a specified key quorum.
 *
 * @param client the Privy client
 * @param wallet wallet to add signers to
 * @param signers array of signers to add as session signers to the wallet
 * @returns Promise that resolves with the updated user if adding signers was successful, and rejects otherwise
 */
declare function addSessionSigners({ client, wallet, signers, }: AddSessionSignersInput): Promise<AddSessionSignersOutput>;
interface RemoveSessionSignersInput {
    client: Privy;
    wallet: LinkedAccountEmbeddedWallet;
}
interface RemoveSessionSignersOutput {
    user: User;
}
/**
 * Removes all session signers from a user wallet.
 *
 * @param client the Privy client
 * @param wallet wallet to remove signers from
 * @returns Promise that resolves with the updated user if the revocation was successful, and rejects otherwise
 */
declare function removeSessionSigners({ client, wallet, }: RemoveSessionSignersInput): Promise<RemoveSessionSignersOutput>;

/**
 * Class that represents a connected standard Solana wallet.
 *
 * This class is used to interact with a standard Solana wallet that is connected to the user's account.
 * It is used to sign messages, transactions, and send transactions.
 *
 * @param wallet - The standard Solana wallet that is connected to the user's account.
 * @param account - The account that is connected to the user's account.
 *
 */
declare class ConnectedStandardSolanaWallet {
    #private;
    /**
     * The standard wallet instance that is connected.
     */
    get standardWallet(): SolanaStandardWallet;
    /**
     * The address of the account that is connected.
     */
    get address(): string;
    constructor({ wallet, account }: {
        wallet: SolanaStandardWallet;
        account: WalletAccount;
    });
    /**
     * Disconnects the wallet.
     * This is a wrapper around the standard:disconnect feature.
     */
    disconnect(): Promise<void>;
    /**
     * Signs a message.
     * This is a wrapper around the solana:signMessage feature.
     */
    signMessage(input: SolanaSignMessageInput): Promise<SolanaSignMessageOutput>;
    signMessage(...inputs: SolanaSignMessageInput[]): Promise<SolanaSignMessageOutput[]>;
    /**
     * Signs a transaction.
     * This is a wrapper around the solana:signTransaction feature.
     */
    signTransaction(input: SolanaSignTransactionInput): Promise<SolanaSignTransactionOutput>;
    signTransaction(...inputs: SolanaSignTransactionInput[]): Promise<SolanaSignTransactionOutput[]>;
    /**
     * Signs and sends a transaction.
     * This is a wrapper around the solana:signAndSendTransaction feature.
     */
    signAndSendTransaction(input: SolanaSignAndSendTransactionInput): Promise<SolanaSignAndSendTransactionOutput>;
    signAndSendTransaction(...inputs: SolanaSignAndSendTransactionInput[]): Promise<SolanaSignAndSendTransactionOutput[]>;
    /**
     * Signs and sends multiple transactions.
     * This is a wrapper around the solana:signAndSendTransaction feature.
     */
    signAndSendAllTransactions(inputs: SolanaSignAndSendTransactionInput[]): Promise<SolanaSignAndSendTransactionOutput[]>;
}

/** @deprecated Use OAuthProviderID instead */
type OAuthProviderType = OAuthProviderID;

/** @deprecated {@link SmartWalletType} is a well-typed union, use the `'biconomy'` literal instead */
declare const BICONOMY: "biconomy";
/** @deprecated {@link SmartWalletType} is a well-typed union, use the `'coinbase_smart_wallet'` literal instead */
declare const COINBASE_SMART_WALLET: "coinbase_smart_wallet";
/** @deprecated {@link SmartWalletType} is a well-typed union, use the `'kernel'` literal instead */
declare const KERNEL: "kernel";
/** @deprecated {@link SmartWalletType} is a well-typed union, use the `'light_account'` literal instead */
declare const LIGHT_ACCOUNT: "light_account";
/** @deprecated {@link SmartWalletType} is a well-typed union, use the `'safe'` literal instead */
declare const SAFE: "safe";
/** @deprecated {@link SmartWalletType} is a well-typed union, use the `'thirdweb'` literal instead */
declare const THIRDWEB: "thirdweb";

export { ALL_WALLET_CLIENT_TYPES, BICONOMY, COINBASE_SMART_WALLET, type Cluster, type CoinbaseAssetId, type CoinbaseWalletClientType, ConnectedStandardSolanaWallet, type ConnectorType, type CreateSiwsMessageOpts, type EIP1193Provider, EmbeddedBitcoinWalletProvider, EmbeddedProviderError, type EmbeddedWalletClientType, type EmbeddedWalletConfig, type EmbeddedWalletRecoveryOptions, type EntropyIdVerifier, type ErrorMessageMap, type ExternalWallet, type ExternalWalletMetadata, type FundingMethod, type FundingProvider, type GenerateAuthorizationSignatureInput, type GenerateAuthorizationSignatureOutput, type IdentifierString, InMemoryCache, type InjectedWalletClientType, KERNEL, LIGHT_ACCOUNT, LocalStorage, type LogLevel, type MfaMethod, type MfaPromise, type MfaSubmitArgs, type MfaSubmitPromise, MoonpayApiError, type MoonpayTransactionStatus, type MoonpayTransactionStatusResponse, type OAuthProviderType, type OnNeedsRecovery, type PaymentOption, type PreparedTransactionRequest, PrivyApiError, PrivyClientError, PrivyConnectorError, type PrivyEmbeddedSolanaWalletProvider, PrivyEmbeddedWalletErrorCode, type PrivyEmbeddedWalletProvider, PrivyProviderRpcError, ProviderErrors, type Quantity, SAFE, SUPPORTED_CONNECTOR_TYPES, type SetRecoveryInput, SolanaClient, type SolanaCluster, type SolanaSignAndSendTransactionInput, type SolanaSignAndSendTransactionMode, type SolanaSignAndSendTransactionOptions, type SolanaSignAndSendTransactionOutput, type SolanaSignMessageInput, type SolanaSignMessageOutput, type SolanaSignTransactionInput, type SolanaSignTransactionOptions, type SolanaSignTransactionOutput, type SolanaStandardWallet, type SolanaTransactionCommitment, SolanaUsdcAddressMap, type Storage, THIRDWEB, type UnknownWalletClientType, type UnsignedTransactionRequest, type UnsignedTransactionRequestWithChainId, UsdcAddressMap, type WalletBranding, type WalletClientType, type WalletConnectWalletClientType, addSessionSigners, chainToMoonpayCurrency, countryCodesAndNumbers, create, createErrorFormatter, createSiwsMessage, index as crossApp, Privy as default, index$2 as delegatedActions, errorIndicatesMaxMfaRetries, errorIndicatesMfaCanceled, errorIndicatesMfaRateLimit, errorIndicatesMfaTimeout, errorIndicatesMfaVerificationFailed, errorIndicatesRecoveryIsNeeded, formatLamportsAmount, formatPhoneNumber, formatTokenAmount, formatWalletAddress, formatWeiAmount, fundingMethodToMoonpayPaymentMethod, generateAuthorizationSignature, generateWalletIdempotencyKey, getAllUserEmbeddedBitcoinWallets, getAllUserEmbeddedEthereumWallets, getAllUserEmbeddedSolanaWallets, getCoinbaseOnRampUrl, getEntropyDetailsFromAccount, getEntropyDetailsFromUser, getIsTokenUsdc, getJsonRpcEndpointFromChain, getPhoneCountryCodeAndNumber, getPlaceholderPhoneNumber, getSolanaClusterDisplayName, getSolanaRpcEndpointForCluster, getSolanaUsdcMintAddressForCluster, getUserEmbeddedEthereumWallet, getUserEmbeddedSolanaWallet, getUserEmbeddedWallet, getUserSmartWallet, getWallet, isEmbeddedWalletAccount, isSupportedChainIdForCoinbaseOnramp, isSupportedChainIdForMoonpay, isUnifiedWallet, lastFourDigits, phoneNumberTypingFormatter, rawSign, removeSessionSigners, rpc, throwIfInvalidRecoveryUpgradePath, toCoinbaseAssetId, toCoinbaseBlockchainFromChainId, toObjectKeys, updateWallet, validatePhoneNumber };
