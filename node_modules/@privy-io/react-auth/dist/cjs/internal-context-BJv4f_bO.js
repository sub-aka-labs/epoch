"use strict";var e,t=require("ofetch"),r=require("react");class s extends Error{toString(){return`${this.type}${this.privyErrorCode?`-${this.privyErrorCode}`:""}: ${this.message}${this.cause?` [cause: ${this.cause}]`:""}`}constructor(e,t,r){super(e),t instanceof Error&&(this.cause=t),this.privyErrorCode=r}}class i extends s{constructor(e,t,r,s,i,n){super(r,s,i),this.type=e,this.status=t,this.data=n}}class n extends s{constructor(e,t,r){super(e,t,r),this.type="client_error"}}class a extends s{constructor(e,t,r){super(e,t,r),this.type="connector_error"}}const o=e=>e instanceof s?e:e instanceof Error?new n(e.message,e):new n(`Internal error: ${e}`);var _=((e={}).OAUTH_ACCOUNT_SUSPENDED="oauth_account_suspended",e.MISSING_OR_INVALID_PRIVY_APP_ID="missing_or_invalid_privy_app_id",e.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID="missing_or_invalid_privy_account_id",e.MISSING_OR_INVALID_TOKEN="missing_or_invalid_token",e.INVALID_DATA="invalid_data",e.INVALID_CAPTCHA="invalid_captcha",e.LINKED_TO_ANOTHER_USER="linked_to_another_user",e.CANNOT_LINK_MORE_OF_TYPE="cannot_link_more_of_type",e.FAILED_TO_LINK_ACCOUNT="failed_to_link_account",e.FAILED_TO_UPDATE_ACCOUNT="failed_to_update_account",e.USER_EXITED_UPDATE_FLOW="exited_update_flow",e.ALLOWLIST_REJECTED="allowlist_rejected",e.OAUTH_USER_DENIED="oauth_user_denied",e.OAUTH_UNEXPECTED="oauth_unexpected",e.UNKNOWN_AUTH_ERROR="unknown_auth_error",e.USER_EXITED_AUTH_FLOW="exited_auth_flow",e.USER_EXITED_LINK_FLOW="exited_link_flow",e.USER_EXITED_SET_PASSWORD_FLOW="user_exited_set_password_flow",e.MUST_BE_AUTHENTICATED="must_be_authenticated",e.UNKNOWN_CONNECT_WALLET_ERROR="unknown_connect_wallet_error",e.GENERIC_CONNECT_WALLET_ERROR="generic_connect_wallet_error",e.CLIENT_REQUEST_TIMEOUT="client_request_timeout",e.INVALID_CREDENTIALS="invalid_credentials",e.MISSING_MFA_CREDENTIALS="missing_or_invalid_mfa",e.UNKNOWN_MFA_ERROR="unknown_mfa_error",e.EMBEDDED_WALLET_ALREADY_EXISTS="embedded_wallet_already_exists",e.EMBEDDED_WALLET_NOT_FOUND="embedded_wallet_not_found",e.EMBEDDED_WALLET_CREATE_ERROR="embedded_wallet_create_error",e.UNKNOWN_EMBEDDED_WALLET_ERROR="unknown_embedded_wallet_error",e.EMBEDDED_WALLET_PASSWORD_UNCONFIRMED="embedded_wallet_password_unconfirmed",e.EMBEDDED_WALLET_PASSWORD_ALREADY_EXISTS="embedded_wallet_password_already_exists",e.EMBEDDED_WALLET_RECOVERY_ALREADY_EXISTS="embedded_wallet_recovery_already_exists",e.TRANSACTION_FAILURE="transaction_failure",e.UNSUPPORTED_CHAIN_ID="unsupported_chain_id",e.NOT_SUPPORTED="not_supported",e.CAPTCHA_TIMEOUT="captcha_timeout",e.INVALID_MESSAGE="invalid_message",e.UNABLE_TO_SIGN="unable_to_sign",e.CAPTCHA_FAILURE="captcha_failure",e.CAPTCHA_DISABLED="captcha_disabled",e.SESSION_STORAGE_UNAVAILABLE="session_storage_unavailable",e.TOO_MANY_REQUESTS="too_many_requests",e.USER_LIMIT_REACHED="max_accounts_reached",e.DISALLOWED_LOGIN_METHOD="disallowed_login_method",e.DISALLOWED_PLUS_EMAIL="disallowed_plus_email",e.PASSKEY_NOT_ALLOWED="passkey_not_allowed",e.USER_DOES_NOT_EXIST="user_does_not_exist",e.INSUFFICIENT_BALANCE="insufficient_balance",e.ACCOUNT_TRANSFER_REQUIRED="account_transfer_required",e.BUFFER_NOT_DEFINED="buffer_not_defined",e.UNSUPPORTED_WALLET_TYPE="unsupported_wallet_type",e.NO_SOLANA_ACCOUNTS="no_solana_accounts",e.UNKNOWN_FUNDING_ERROR="unknown_funding_error",e);const l=()=>{throw Error("You need to wrap your application with the <PrivyProvider> initialized with your app id.")},d=/*#__PURE__*/r.createContext({setAuthenticated:l,setUser:l,setIsNewUser:l,isNewUserThisSession:!1,walletConnectionStatus:null,setWalletConnectionStatus:l,connectors:[],rpcConfig:{rpcUrls:{}},showFiatPrices:!0,chains:[],clientAnalyticsId:null,pendingTransaction:null,client:null,privy:null,appId:"notAdded",hideWalletUIs:{current:!1},nativeTokenSymbolForChainId:l,initializeWalletProxy:l,getAuthMeta:l,getAuthFlow:l,closePrivyModal:l,openPrivyModal:l,connectWallet:l,initLoginWithWallet:l,loginWithWallet:l,initLoginWithFarcaster:l,loginWithFarcaster:l,loginWithCode:l,initLoginWithEmail:l,initLoginWithSms:l,initUpdateEmail:l,initUpdatePhone:l,resendEmailCode:l,resendSmsCode:l,initLoginWithHeadlessOAuth:l,loginWithHeadlessOAuth:l,crossAppAuthFlow:l,initLoginWithOAuth:l,loginWithOAuth:l,passkeyAuthState:{status:"initial"},setPasskeyAuthState:l,initSignupWithPasskey:l,signupWithPasskey:l,initLoginWithPasskey:l,loginWithPasskey:l,initLinkWithPasskey:l,linkWithPasskey:l,refreshSessionAndUser:l,walletProxy:null,createAnalyticsEvent:l,acceptTerms:l,getUsdTokenPrice:l,getUsdPriceForSol:l,getSplTokenMetadata:l,recoverEmbeddedWallet:l,updateWallets:l,fundWallet:l,openModal:l,setReadyToTrue:l,requestFarcasterSignerStatus:l,initLoginWithTelegram:l,loginWithTelegram:l,generateSiweMessage:l,generateSiweMessageForSmartWallet:l,loginWithSiwe:l,linkWithSiwe:l,linkSmartWallet:l,delegateWallet:l,revokeDelegatedWallets:l,connectCoinbaseSmartWallet:l,connectBaseAccount:l,initiateAccountTransfer:l,emailOtpState:{status:"initial"},setEmailOtpState:l,smsOtpState:{status:"initial"},setSmsOtpState:l,siweState:{status:"initial"},setSiweState:l,oAuthState:{status:"initial"},setOAuthState:l,telegramAuthState:{status:"initial"},setTelegramAuthState:l,isHeadlessOAuthLoading:!1,isHeadlessSigning:l,inProgressAuthFlowRef:{current:null},inProgressLoginOrLinkMethodRef:{current:null},baseAccountSdk:void 0,setBaseAccountSdk:l});exports.InternalPrivyContext=d,exports.PrivyApiError=i,exports.PrivyClientError=n,exports.PrivyConnectorError=a,exports.PrivyEmbeddedWalletError=class extends n{constructor(e="Embedded wallet error",t){super(e,t,"unknown_embedded_wallet_error")}},exports.PrivyError=s,exports.PrivyErrorCode=_,exports.PrivyNoSolanaAccountsError=class extends a{constructor(){super("No Solana accounts found in wallet",void 0,"no_solana_accounts")}},exports.PrivyNotReadyError=class extends n{constructor(){super("Method called before `ready`. Ensure you wait until `ready` is true before calling.")}},exports.PrivyTimeoutError=class extends n{constructor(){super("Request timed out",void 0,"client_request_timeout")}},exports.PrivyUnauthenticatedError=class extends n{constructor(e="User must be authenticated"){super(e,void 0,"must_be_authenticated")}},exports.PrivyUserLimitReachedError=class extends n{constructor(e){super("This application is in development mode and must be upgraded to production to log in new users.",e,"max_accounts_reached")}},exports.formatApiError=e=>{if(e instanceof s)return e;if(!(e instanceof t.FetchError))return o(e);if(!e.response)return new i("api_error",null,e.message,e);let{type:r,message:n,error:a,code:_}=e.data;return new i(r||"ApiError",e.response.status,n||a,e,_,e.data)},exports.formatPrivyError=o,exports.noop=()=>{},exports.notImplemented=l,exports.notImplementedWithMessage=e=>()=>{throw Error(e.trim())},exports.usePrivyInternal=()=>r.useContext(d);
