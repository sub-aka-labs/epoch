"use strict";var e=require("react"),r=require("@privy-io/js-sdk-core"),t=require("./internal-context-BJv4f_bO.js"),i=require("./get-is-unified-wallet-BwdzQwn_.js"),a=require("./context-BeSQM-Ma.js"),n=require("./use-sign-with-user-signer-Cu_6Bx7m.js");require("ofetch"),require("viem"),require("react/jsx-runtime"),require("tinycolor2");exports.useCreateWallet=()=>{let{refreshSessionAndUser:i,privy:a}=t.usePrivyInternal();return e.useMemo((()=>({async createWallet(e){let t=await r.create(a,{request:{chain_type:e.chainType}}),n=await i();if(!n)throw Error("User must be authenticated before creating a Privy wallet");return{user:n,wallet:t}}})),[i,a])},exports.useExportWallet=function(){let{user:r,getAccessToken:n}=i.usePrivyContext(),{walletProxy:s,openModal:l,client:o}=t.usePrivyInternal(),{setModalData:d}=i.usePrivyModal(),u=a.useAppConfig();return e.useMemo((()=>({exportWallet:e=>new Promise((async(a,c)=>{if(!r)return void c(new t.PrivyClientError("User must be authenticated before exporting their Privy wallet"));let p=i.getPrivyWalletWithAddress(r,e.address);p?"spark"===p.chainType&&i.getIsUnifiedWallet(p)?await n()?s?(d({connectWallet:{recoveryMethod:p.recoveryMethod,connectingWalletAddress:p.address,isUnifiedWallet:!0,onCompleteNavigateTo:"EmbeddedWalletKeyExportScreen",onFailure:c,shouldForceMFA:!0},keyExport:{appId:u.id,appClientId:u.appClientId,origin:o.apiUrl,address:p.address,hdWalletIndex:p.walletIndex,chainType:p.chainType,walletId:p.id,isUnifiedWallet:!0,imported:p.imported,onSuccess:a,onFailure:c}}),l("EmbeddedWalletConnectingScreen")):c(new t.PrivyClientError("Wallet not ready for export")):c(new t.PrivyClientError("Must have valid access token.")):c(Error("Export via extended-chains is only supported for unified stack wallets")):c(new t.PrivyClientError("User must have an embedded wallet."))}))})),[r,n,s,l,o,d,u])},exports.useSignRawHash=()=>{let{user:a}=i.usePrivyContext(),{privy:s}=t.usePrivyInternal(),{signWithUserSigner:l}=n.useSignWithUserSigner();return e.useMemo((()=>({async signRawHash({address:e,chainType:t,hash:n}){if(!a)throw Error("User must be authenticated before signing");let o=i.getAllPrivyWalletsForChainType(a,t).filter((e=>i.getIsUnifiedWallet(e))).find((r=>r.address===e));if(!o)throw Error("Wallet not found");let d=await r.rawSign(s,l,{wallet_id:o.id,params:{hash:n}});if(d.data&&"signature"in d.data&&"hex"===d.data.encoding)return{signature:d.data.signature};throw Error("Failed to sign")}})),[s,l,a])};
