"use strict";var e=require("@solana/kit"),t=require("react"),n=require("@privy-io/js-sdk-core"),i=require("./internal-context-BJv4f_bO.js"),s=require("./get-is-unified-wallet-BwdzQwn_.js"),a=require("./usePrivy-Bx2PKTrU.js"),r=require("./useWallets-DMyuB5aJ.js"),o=require("eventemitter3"),l=require("@scure/base"),d=require("./context-BeSQM-Ma.js"),c=require("./use-sign-with-user-signer-Cu_6Bx7m.js"),u=require("./prepareFundingModalData-DDf6xLze.js"),g=require("./useSolanaRpcClient-CYMWkK7E.js");function h(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var p=/*#__PURE__*/h(n),y=/*#__PURE__*/h(o);const f=["solana:mainnet","solana:devnet","solana:testnet"];function v(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}var A=0,w="__private_"+A+++"__implementation";class E extends y.default{setImplementation(e){v(this,w)[w]=e}async signMessage(e){return v(this,w)[w].signMessage(e)}async signAndSendTransaction(e){return v(this,w)[w].signAndSendTransaction(e)}async signTransaction(e){return v(this,w)[w].signTransaction(e)}constructor(e){super(),Object.defineProperty(this,w,{writable:!0,value:void 0}),v(this,w)[w]=e}}function T(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}var b=0;function m(e){return"__private_"+b+++"_"+e}var S=/*#__PURE__*/m("_address"),P=/*#__PURE__*/m("_publicKey"),I=/*#__PURE__*/m("_chains"),O=/*#__PURE__*/m("_features"),W=/*#__PURE__*/m("_label"),C=/*#__PURE__*/m("_icon");class _{get address(){return T(this,S)[S]}get publicKey(){return T(this,P)[P].slice()}get chains(){return T(this,I)[I].slice()}get features(){return T(this,O)[O].slice()}get label(){return T(this,W)[W]}get icon(){return T(this,C)[C]}constructor({address:e,publicKey:t,label:n,icon:i}){Object.defineProperty(this,S,{writable:!0,value:void 0}),Object.defineProperty(this,P,{writable:!0,value:void 0}),Object.defineProperty(this,I,{writable:!0,value:void 0}),Object.defineProperty(this,O,{writable:!0,value:void 0}),Object.defineProperty(this,W,{writable:!0,value:void 0}),Object.defineProperty(this,C,{writable:!0,value:void 0}),T(this,S)[S]=e,T(this,P)[P]=t,T(this,I)[I]=f,T(this,W)[W]=n,T(this,C)[C]=i,T(this,O)[O]=["solana:signAndSendTransaction","solana:signTransaction","solana:signMessage"],new.target===_&&Object.freeze(this)}}function M(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}var F=0;function j(e){return"__private_"+F+++"_"+e}var U=/*#__PURE__*/j("_listeners"),D=/*#__PURE__*/j("_version"),N=/*#__PURE__*/j("_name"),B=/*#__PURE__*/j("_icon"),x=/*#__PURE__*/j("_injection"),R=/*#__PURE__*/j("_isPrivyWallet"),L=/*#__PURE__*/j("_accounts"),V=/*#__PURE__*/j("_on"),q=/*#__PURE__*/j("_emit"),Q=/*#__PURE__*/j("_off"),G=/*#__PURE__*/j("_connected"),H=/*#__PURE__*/j("_connect"),K=/*#__PURE__*/j("_disconnect"),J=/*#__PURE__*/j("_signMessage"),Y=/*#__PURE__*/j("_signAndSendTransaction"),k=/*#__PURE__*/j("_signTransaction");function Z(e,...t){M(this,U)[U][e]?.forEach((e=>e.apply(null,t)))}function z(e,t){M(this,U)[U][e]=M(this,U)[U][e]?.filter((e=>t!==e))}function X(t,n,i){let s=structuredClone(e.getTransactionDecoder().decode(t)),a=e.address(n);return a in s.signatures&&(s.signatures[a]=i),new Uint8Array(e.getTransactionEncoder().encode(s))}function $(){let{isHeadlessSigning:e,walletProxy:t,initializeWalletProxy:o,recoverEmbeddedWallet:l,openModal:d,privy:u,client:h}=i.usePrivyInternal(),{user:p}=a.usePrivy(),{setModalData:y}=s.usePrivyModal(),{signWithUserSigner:f}=c.useSignWithUserSigner();return{signMessage:({message:a,address:c,options:v})=>new Promise((async(A,w)=>{let E=s.getPrivyWalletWithAddress(p,c);if("privy"!==E?.walletClientType)return void w(new i.PrivyClientError("Wallet is not a Privy wallet",void 0,i.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:T,entropyIdVerifier:b}=r.getEntropyDetailsForUser(p,E),m=s.getIsUnifiedWallet(E),S=g.bufferFrom(a).toString("base64");if(S.length<1)return void w(new i.PrivyClientError("Message must be a non-empty string",void 0,i.PrivyErrorCode.INVALID_MESSAGE));let P=async()=>{let e;if(!p)throw Error("User must be authenticated before signing with a Privy wallet");let i=await h.getAccessToken();if(!i)throw Error("User must be authenticated to use their embedded wallet.");let s=t??await o(15e3);if(!s)throw Error("Failed to initialize embedded wallet proxy.");if(!await l({address:E.address}))throw Error("Unable to connect to wallet");if(m){let t=await n.rpc(u,f,{chain_type:"solana",method:"signMessage",params:{message:S,encoding:"base64"},wallet_id:E.id});if(!t.data||!("signature"in t.data))throw Error("Failed to sign message");e=t.data.signature}else{let{response:t}=await s.rpc({accessToken:i,entropyId:T,entropyIdVerifier:b,chainType:"solana",hdWalletIndex:E.walletIndex??0,requesterAppId:v?.uiOptions?.requesterAppId,request:{method:"signMessage",params:{message:S}}});e=t.data.signature}return e};if(e({showWalletUIs:v?.uiOptions?.showWalletUIs}))try{let e=await P(),t=new Uint8Array(g.bufferFrom(e,"base64"));A({signature:t})}catch(e){w(e)}else y({signMessage:{method:"solana_signMessage",data:S,confirmAndSign:P,onSuccess:e=>{A({signature:new Uint8Array(g.bufferFrom(e,"base64"))})},onFailure:e=>{w(e)},uiOptions:v?.uiOptions??{}},connectWallet:{recoveryMethod:E.recoveryMethod,connectingWalletAddress:E.address,entropyId:T,entropyIdVerifier:b,isUnifiedWallet:m,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{w(new i.PrivyClientError("Failed to connect to wallet",e,i.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR))}}}),d("EmbeddedWalletConnectingScreen")}))}}function ee(){let{isHeadlessSigning:e,openModal:t}=i.usePrivyInternal(),{setModalData:n}=s.usePrivyModal(),{signMessage:o}=$(),{user:l}=a.usePrivy();return{signTransaction:async({transaction:a,options:d,chain:c="solana:mainnet",address:u})=>{async function h(e){let{signature:t}=await o({message:g.getTransactionMessageBytes(e),address:u,options:{...d,uiOptions:{...d?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:X(e,u,t)}}return e({showWalletUIs:d?.uiOptions?.showWalletUIs})?h(a):new Promise((async(e,o)=>{let g=s.getPrivyWalletWithAddress(l,u);if("privy"!==g?.walletClientType)return void o(new i.PrivyClientError("Wallet is not a Privy wallet",void 0,i.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:p,entropyIdVerifier:y}=r.getEntropyDetailsForUser(l,g),f=s.getIsUnifiedWallet(g);function v(e){return t=>{t instanceof i.PrivyClientError?o(t):o(new i.PrivyClientError("Failed to connect to wallet",t,e))}}let A={account:g,transaction:a,chain:c,signOnly:!0,uiOptions:d?.uiOptions||{},onConfirm:h,onSuccess:e,onFailure:v(i.PrivyErrorCode.TRANSACTION_FAILURE)};n({connectWallet:{recoveryMethod:g.recoveryMethod,connectingWalletAddress:g.address,entropyId:p,entropyIdVerifier:y,isUnifiedWallet:f,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:v(i.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:A}),t("EmbeddedWalletConnectingScreen")}))}}}let te=new E({signTransaction:i.notImplementedWithMessage("signTransaction was not injected"),signAndSendTransaction:i.notImplementedWithMessage("signAndSendTransaction was not injected"),signMessage:i.notImplementedWithMessage("signMessage was not injected")}),ne=new class{get version(){return M(this,D)[D]}get name(){return M(this,N)[N]}get icon(){return M(this,B)[B]}get chains(){return f.slice()}get features(){return{"standard:connect":{version:"1.0.0",connect:M(this,H)[H]},"standard:disconnect":{version:"1.0.0",disconnect:M(this,K)[K]},"standard:events":{version:"1.0.0",on:M(this,V)[V]},"solana:signAndSendTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:M(this,Y)[Y]},"solana:signTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:M(this,k)[k]},"solana:signMessage":{version:"1.0.0",signMessage:M(this,J)[J]},"privy:":{privy:{signMessage:M(this,x)[x].signMessage,signTransaction:M(this,x)[x].signTransaction,signAndSendTransaction:M(this,x)[x].signAndSendTransaction}}}}get accounts(){return M(this,L)[L].slice()}get isPrivyWallet(){return M(this,R)[R]}constructor({name:e,icon:t,version:n,injection:i,wallets:s}){Object.defineProperty(this,q,{value:Z}),Object.defineProperty(this,Q,{value:z}),Object.defineProperty(this,U,{writable:!0,value:void 0}),Object.defineProperty(this,D,{writable:!0,value:void 0}),Object.defineProperty(this,N,{writable:!0,value:void 0}),Object.defineProperty(this,B,{writable:!0,value:void 0}),Object.defineProperty(this,x,{writable:!0,value:void 0}),Object.defineProperty(this,R,{writable:!0,value:void 0}),Object.defineProperty(this,L,{writable:!0,value:void 0}),Object.defineProperty(this,V,{writable:!0,value:void 0}),Object.defineProperty(this,G,{writable:!0,value:void 0}),Object.defineProperty(this,H,{writable:!0,value:void 0}),Object.defineProperty(this,K,{writable:!0,value:void 0}),Object.defineProperty(this,J,{writable:!0,value:void 0}),Object.defineProperty(this,Y,{writable:!0,value:void 0}),Object.defineProperty(this,k,{writable:!0,value:void 0}),M(this,U)[U]={},M(this,V)[V]=(e,t)=>(M(this,U)[U][e]?.push(t)||(M(this,U)[U][e]=[t]),()=>M(this,Q)[Q](e,t)),M(this,G)[G]=e=>{null!=e&&(M(this,L)[L]=e.map((({address:e})=>new _({address:e,publicKey:l.base58.decode(e)})))),M(this,q)[q]("change",{accounts:this.accounts})},M(this,H)[H]=async()=>(M(this,q)[q]("change",{accounts:this.accounts}),{accounts:this.accounts}),M(this,K)[K]=async()=>{M(this,q)[q]("change",{accounts:this.accounts})},M(this,J)[J]=async(...e)=>{let t=[];for(let{account:n,...i}of e){let{signature:e}=await M(this,x)[x].signMessage({...i,address:n.address});t.push({signedMessage:i.message,signature:e})}return t},M(this,Y)[Y]=async(...e)=>{let t=[];for(let n of e){let{signature:e}=await M(this,x)[x].signAndSendTransaction({...n,transaction:n.transaction,address:n.account.address,chain:n.chain||"solana:mainnet",options:n.options});t.push({signature:e})}return t},M(this,k)[k]=async(...e)=>{let t=[];for(let{transaction:n,account:i,options:s,chain:a}of e){let{signedTransaction:e}=await M(this,x)[x].signTransaction({transaction:n,address:i.address,chain:a||"solana:mainnet",options:s});t.push({signedTransaction:e})}return t},M(this,N)[N]=e,M(this,B)[B]=t,M(this,D)[D]=n,M(this,x)[x]=i,M(this,L)[L]=[],M(this,R)[R]=!0,i.on("accountChanged",M(this,G)[G],this),M(this,G)[G](s)}}({name:"Privy",version:"1.0.0",icon:"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==",wallets:[],injection:te});function ie(){let{ready:e}=r.useWallets(),{user:o}=a.usePrivy(),{signMessage:h}=$(),{signTransaction:y}=ee(),{signAndSendTransaction:f}=function(){let e=d.useAppConfig(),{isHeadlessSigning:t,openModal:o}=i.usePrivyInternal(),{setModalData:h}=s.usePrivyModal(),{signTransaction:y}=ee(),f=g.useSolanaRpcClient(),{user:v}=a.usePrivy(),{signWithUserSigner:A}=c.useSignWithUserSigner();return{signAndSendTransaction:async({transaction:a,address:d,chain:c="solana:mainnet",options:w})=>{let E=s.getPrivyWalletWithAddress(v,d);if("privy"!==E?.walletClientType)throw new i.PrivyClientError("Wallet is not a Privy wallet",void 0,i.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND);let T=s.getIsUnifiedWallet(E);async function b(t){if(w?.sponsor)return await(async t=>{if(!T)throw new i.PrivyClientError("Sponsoring transactions is only supported for wallets on the TEE stack",i.PrivyErrorCode.INVALID_DATA);let s=new p.default({appId:e.id,clientId:e.appClientId,storage:u.u}),a=await n.rpc(s,A,{chain_type:"solana",method:"signAndSendTransaction",sponsor:!0,params:{transaction:g.bufferFrom(t).toString("base64"),encoding:"base64"},caip2:`solana:${(await f(c).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:E.id});if(a.data&&"hash"in a.data)return{signature:l.base58.decode(a.data.hash)};throw Error("Failed to sign and send transaction")})(t);let{signedTransaction:s}=await y({transaction:t,address:d,chain:c,options:{...w,uiOptions:{...w?.uiOptions,showWalletUIs:!1}}}),{signature:a}=await f(c).sendAndConfirmTransaction(s);return{signature:a}}return t({showWalletUIs:w?.uiOptions?.showWalletUIs})?b(a):new Promise((async(t,n)=>{let s,l,{entropyId:g,entropyIdVerifier:p}=r.getEntropyDetailsForUser(v,E);function y(e){return t=>{t instanceof i.PrivyClientError?n(t):n(new i.PrivyClientError("Failed to connect to wallet",t,e))}}let f={account:E,transaction:a,chain:c,signOnly:!1,uiOptions:w?.uiOptions||{},onConfirm:b,onSuccess:t,onFailure:y(i.PrivyErrorCode.TRANSACTION_FAILURE),isSponsored:!!w?.sponsor},A={recoveryMethod:E.recoveryMethod,connectingWalletAddress:E.address,entropyId:g,entropyIdVerifier:p,isUnifiedWallet:T,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:y(i.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR)};e.fundingConfig&&(s=u.prepareSolanaFundingModalData({address:d,appConfig:e,methodScreen:"FundingMethodSelectionScreen",fundWalletConfig:{...w,asset:"native-currency",chain:c},externalSolanaFundingScreen:"FundSolWalletWithExternalSolanaWallet"}),l={amount:e.fundingConfig.defaultRecommendedAmount,asset:"SOL",chain:c,destinationAddress:d,afterSuccessScreen:"StandardSignAndSendTransactionScreen",sourceWalletData:void 0}),h({connectWallet:A,standardSignAndSendTransaction:f,funding:s,solanaFundingData:l}),o("EmbeddedWalletConnectingScreen")}))}}}(),v=t.useMemo((()=>{let e=[...s.getPrivySolanaHDWallets(o).sort(((e,t)=>(e.walletIndex??0)-(t.walletIndex??0)))],t=s.getImportedPrivySolanaWallets(o);return t.length?[...e,...t]:e}),[o]),A=t.useMemo((()=>({signMessage:async({message:e,address:t,options:n})=>await h({message:e,address:t,options:n}),signTransaction:async({transaction:e,address:t,chain:n,options:i})=>await y({transaction:e,address:t,chain:n,options:i}),async signAndSendTransaction({transaction:e,address:t,chain:n,options:i}){let{signature:s}=await f({transaction:e,address:t,chain:n,options:i});return{signature:s}}})),[h,y,f]);return t.useEffect((()=>{te?.setImplementation(A)}),[A]),t.useEffect((()=>{var t;!e||(t=ne.accounts).length===v.length&&t.every(((e,t)=>e.address===v[t]?.address))||te?.emit("accountChanged",v)}),[e,v]),{ready:e,wallet:ne}}function se(){let{client:e}=i.usePrivyInternal(),{ready:n,wallet:s}=ie(),[a,r]=t.useState([]),[o,l]=t.useState([]);return t.useEffect((()=>{let e=[s,...a.filter((e=>"solana"===e.chainType&&!!e.wallet.features)).map((e=>e.wallet))];l(e);let t=a.flatMap((t=>{let n=()=>l([...e]);return t.on("walletsUpdated",n),{connector:t,off:n}})),n=e.map((t=>t.features["standard:events"]?.on("change",(()=>{l([...e])}))));return()=>{n.forEach((e=>e?.())),t.forEach((({connector:e,off:t})=>e.off("walletsUpdated",t)))}}),[a]),t.useEffect((()=>{r(e.connectors?.walletConnectors.filter((e=>"solana"===e.chainType))??[]);let t=()=>{r(e.connectors?.walletConnectors.filter((e=>"solana"===e.chainType))??[])};return e.connectors?.on("connectorInitialized",t),()=>{e.connectors?.off("connectorInitialized",t)}}),[n,e.connectors]),{ready:n,wallets:o}}exports.SOLANA_CHAINS=f,exports.getAddressFromBuffer=function(t){return e.getBase58Decoder().decode(t)},exports.useSolanaStandardWallets=se,exports.useWallets=function(){let{ready:e,wallets:i}=se();return{ready:e,wallets:t.useMemo((()=>i.flatMap((e=>e.accounts.map((t=>new n.ConnectedStandardSolanaWallet({wallet:e,account:t})))))),[i])}};
