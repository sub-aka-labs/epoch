"use strict";var e=require("react/jsx-runtime"),t=require("react"),r=require("@privy-io/js-sdk-core"),n=require("uuid"),i=require("jose"),a=require("./get-is-unified-wallet-BwdzQwn_.js"),s=require("eventemitter3"),o=require("./useActiveWallet-vlXeDPzp.js"),l=require("./useWallets-DMyuB5aJ.js"),c=require("./internal-context-BJv4f_bO.js"),d=require("./prepareFundingModalData-DDf6xLze.js"),u=require("@coinbase/wallet-sdk"),h=require("@privy-io/ethereum"),p=require("./context-BeSQM-Ma.js"),y=require("mipd"),w=require("react-device-detect"),m=require("viem/utils"),g=require("@privy-io/popup"),v=require("./paths-DizMb-lU.js"),f=require("./usePrivy-Bx2PKTrU.js"),E=require("@scure/base"),C=require("styled-components"),A=require("./events-context-Di6--rDg.js"),P=require("zustand"),T=require("@headlessui/react"),k=require("@walletconnect/ethereum-provider"),_=require("@privy-io/urls"),S=require("viem"),b=require("./getPublicClient-BsmZyCGX.js"),I=require("ofetch"),W=require("js-cookie"),U=require("./frame-Oz7volks.js"),x=require("@privy-io/routes"),R=require("x402/client"),O=require("@privy-io/api-base"),N=require("viem/accounts"),M=require("./use-sign-with-user-signer-Cu_6Bx7m.js");function F(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function D(e){if(e&&"object"==typeof e&&"default"in e)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}require("./getEmbeddedConnectedWallet-6TsVZJkD.js");var L=/*#__PURE__*/F(t),j=/*#__PURE__*/F(r),q=/*#__PURE__*/D(i),z=/*#__PURE__*/F(s),K=/*#__PURE__*/F(W);class H{static parse(e){try{return new H(e)}catch(e){return null}}static throwIfNotWellFormedJwt(e){return q.decodeJwt(e),e}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(e=0){return Date.now()>=1e3*(this.expiration-e)}constructor(e){this.value=e,this._decoded=q.decodeJwt(e)}}class V extends H{static parse(e){try{return new V(e)}catch(e){return null}}get appId(){return this._decoded.aid?this._decoded.aid:this.audience}}const B="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PScwIDAgMTAyNCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHN0eWxlPSdoZWlnaHQ6MjhweDt3aWR0aDoyOHB4Jz48cmVjdCB3aWR0aD0nMTAyNCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjMDA1MkZGJyByeD0nMTAwJyByeT0nMTAwJz48L3JlY3Q+PHBhdGggZmlsbC1ydWxlPSdldmVub2RkJyBjbGlwLXJ1bGU9J2V2ZW5vZGQnIGQ9J00xNTIgNTEyQzE1MiA3MTAuODIzIDMxMy4xNzcgODcyIDUxMiA4NzJDNzEwLjgyMyA4NzIgODcyIDcxMC44MjMgODcyIDUxMkM4NzIgMzEzLjE3NyA3MTAuODIzIDE1MiA1MTIgMTUyQzMxMy4xNzcgMTUyIDE1MiAzMTMuMTc3IDE1MiA1MTJaTTQyMCAzOTZDNDA2Ljc0NSAzOTYgMzk2IDQwNi43NDUgMzk2IDQyMFY2MDRDMzk2IDYxNy4yNTUgNDA2Ljc0NSA2MjggNDIwIDYyOEg2MDRDNjE3LjI1NSA2MjggNjI4IDYxNy4yNTUgNjI4IDYwNFY0MjBDNjI4IDQwNi43NDUgNjE3LjI1NSAzOTYgNjA0IDM5Nkg0MjBaJyBmaWxsPSd3aGl0ZSc+PC9wYXRoPjwvc3ZnPg==",Y="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAALZJREFUaEPtmjEOhDAMBNc/O14GvOzys3CAKK6eAlmaVGl2Zc+kTOU685vkc9/bnD2prZK5/TZY24z9P+g4F5hNh7/GdoG37WlAA5CATwgCxHENYISwQAMQII5rACOEBRqAAHFcAxghLNAABIjjGsAIYYEGIEAc1wBGCAs0AAHiuAYwQligAQgQxzWAEcICDUCAOK4BjBAWaAACxHENYISwQAMQII6fBjr+VHkW3+u+tfyxMpJaDgYzYxb/ALZVAAAAAElFTkSuQmCC";let G,$;class J extends o.EthereumWalletConnector{async initialize(){await this.importPromise,await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Y,id:"com.coinbase.wallet"}}async promptConnection(){try{await this.importPromise;let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new c.PrivyConnectorError("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw d.formatConnectorError(e)}}constructor(e,t,r,n,i){super("base_account",e,t,r),this.connectorType="base_account",this.walletClientType="base_account",this.displayName="Base",this.setBaseAccountSdk=i,this.proxyProvider=new o.PrivyProxyProvider(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.baseAccountConfig={...n,appChainIds:[t.id].concat(e.map((e=>e.id)))},G?(this.proxyProvider.setWalletProvider(G.getProvider()),this.setBaseAccountSdk(G)):this.importPromise=import("@base-org/account").then((({createBaseAccountSDK:e})=>{G=e(this.baseAccountConfig),this.proxyProvider.setWalletProvider(G.getProvider()),this.setBaseAccountSdk(G)})).catch(console.error)}}let Q=[1,11155111,137,10,8453,84532,42161,7777777,43114,56];class Z extends o.EthereumWalletConnector{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:B,id:"com.coinbase.wallet"}}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new c.PrivyConnectorError("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw d.formatConnectorError(e)}}updateConnectionPreference(e){this.coinbaseWalletConfig={...this.coinbaseWalletConfig,preference:{...this.coinbaseWalletConfig.preference,options:e}},this.walletClientType="smartWalletOnly"===e?"coinbase_smart_wallet":"coinbase_wallet",$=u.createCoinbaseWalletSDK({...this.coinbaseWalletConfig}),this.proxyProvider.setWalletProvider($.getProvider())}constructor(e,t,n,i){if(super("coinbase_wallet",e,t,n),this.connectorType="coinbase_wallet",this.displayName="Coinbase Wallet",this.proxyProvider=new o.PrivyProxyProvider(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.coinbaseWalletConfig={...i,appChainIds:[t.id].concat(e.map((e=>e.id)))},this.walletClientType="smartWalletOnly"===this.coinbaseWalletConfig.preference?.options?"coinbase_smart_wallet":"coinbase_wallet","coinbase_smart_wallet"===this.walletClientType&&(this.displayName="Coinbase Smart Wallet"),!$){let e="eoaOnly"!==this.coinbaseWalletConfig.preference?.options?(this.coinbaseWalletConfig.appChainIds??[]).filter((e=>!Q.includes(e))):[];e.length>0&&!e.every((e=>r.DEFAULT_SUPPORTED_CHAIN_IDS.has(e)))&&console.info(`The configured chains are not supported by Coinbase Smart Wallet: ${e.join(", ")}`),$=u.createCoinbaseWalletSDK(this.coinbaseWalletConfig)}this.proxyProvider.setWalletProvider($.getProvider())}}const X=({...t})=>/*#__PURE__*/e.jsx("svg",{width:"15",height:"15",viewBox:"0 0 15 15",fill:"none",xmlns:"http://www.w3.org/2000/svg",...t,children:/*#__PURE__*/e.jsx("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M2.37126 11.0323C2.37126 12.696 3.90598 13.4421 5.40654 13.4468C8.91753 13.4468 12.8021 11.2897 12.7819 7.67984C12.7673 5.07728 10.3748 2.86167 7.54357 2.88296C4.8495 2.88296 2.21821 4.6411 2.21803 7.03628C2.21803 7.67951 2.58722 8.30178 3.55231 8.37184C2.74763 9.16826 2.37126 10.1225 2.37126 11.0323ZM7.55283 8.68012C8.11562 8.68012 8.57186 8.13217 8.57186 7.45624C8.57186 6.78032 8.11562 6.23237 7.55283 6.23237C6.99003 6.23237 6.53379 6.78032 6.53379 7.45624C6.53379 8.13217 6.99003 8.68012 7.55283 8.68012ZM10.4747 8.68012C11.0375 8.68012 11.4937 8.13217 11.4937 7.45625C11.4937 6.78032 11.0375 6.23237 10.4747 6.23237C9.91186 6.23237 9.45562 6.78032 9.45562 7.45625C9.45562 8.13217 9.91186 8.68012 10.4747 8.68012Z",fill:t.color||"var(--privy-color-foreground-3)"})});class ee extends o.EthereumWalletConnector{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return await this.isConnected()?(await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[o.toHex(e?.chainId||"0x1")]}),this.getConnectedWallet()):null}get walletBranding(){return{name:"Privy Wallet",icon:X,id:"io.privy.wallet"}}disconnect(){this.connected=!1}async promptConnection(){}constructor({provider:e,chains:t,defaultChain:r,rpcConfig:n,imported:i,walletIndex:a}){super("privy",t,r,n),this.connectorType="embedded",this.proxyProvider=e,this.walletIndex=a,i&&(this.connectorType="embedded_imported"),this.subscribeListeners()}}async function te(){let e=Rr();return e?e.getAccessToken():Promise.resolve(d.u.get(p.PRIVY_ACCESS_TOKEN_STORAGE_KEY)||d.u.get(p.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY)||null)}const re=["eth_sign","eth_populateTransactionRequest","eth_signTransaction","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"];function ne(e){return e?{"privy-ui":"t"}:void 0}class ie{async authenticate(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new c.PrivyClientError("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(v.passwordlessAuthenticatePath,{email:this.meta.email,code:this.meta.emailCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw c.formatApiError(e)}}async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new c.PrivyClientError("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(v.passwordlessLinkPath,{email:this.meta.email,code:this.meta.emailCode})}catch(e){throw c.formatApiError(e)}}async sendCodeEmail({email:e,captchaToken:t,withPrivyUi:r}){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(e&&(this.meta.email=e),t&&(this.meta.captchaToken=t),!this.meta.email)throw new c.PrivyClientError("Email must be set when initialzing authentication.");let n=ne(r);try{return await this.api.post(v.passwordlessInitPath,{email:this.meta.email,token:this.meta.captchaToken},{headers:{...n}})}catch(e){throw c.formatApiError(e)}}constructor({email:e,captchaToken:t,disableSignup:r}){this.meta={email:e,captchaToken:t,disableSignup:r??!1}}}class ae extends ie{async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode||!this.meta.oldAddress)throw new c.PrivyClientError("Email, email code, and an old email address must be set prior to calling update.");try{return await this.api.post(v.updateEmailPath,{oldAddress:this.meta.oldAddress,newAddress:this.meta.email,code:this.meta.emailCode})}catch(e){throw c.formatApiError(e)}}constructor(e,t,r){super({email:t,captchaToken:r}),this.meta={email:t,captchaToken:r,oldAddress:e,disableSignup:!1}}}class se{execute(e){return null===this.promise&&(this.promise=(async()=>{try{return await this.fn(e)}finally{this.promise=null}})()),this.promise}constructor(e){this.promise=null,this.fn=e}}class oe{get meta(){return this._meta}async authenticate(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.channelToken)throw new c.PrivyClientError("Auth flow must be initialized first");try{let e=await this.api.post(v.farcasterAuthenticatePath,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});if(!e)throw new c.PrivyClientError("No response from authentication");return e}catch(e){throw c.formatApiError(e)}}async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");try{return await this.api.post(v.farcasterLinkPath,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid})}catch(e){throw c.formatApiError(e)}}async _startChannelOnce(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");let e=await this.api.post(v.farcasterInitPath,{token:this.captchaToken});w.isMobile&&!w.isIOS&&e.connect_uri&&f.openHref(e.connect_uri,"_blank"),this._meta={...this._meta,connectUri:e.connect_uri,channelToken:e.channel_token}}async initializeFarcasterConnect(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");await this.startChannelOnce.execute()}async _pollForReady(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.channelToken)throw new c.PrivyClientError("Auth flow must be initialized first");let e=await this.api.get(v.farcasterStatusPath,{headers:{"farcaster-channel-token":this.meta.channelToken}});return"completed"===e.state&&(this.message=e.message,this.signature=e.signature,this.fid=e.fid,!0)}constructor(e,t=!1){this._meta={disableSignup:!1},this.captchaToken=e,this.startChannelOnce=new se(this._startChannelOnce.bind(this)),this.pollForReady=new se(this._pollForReady.bind(this)),this._meta.disableSignup=t}}function le(){return"undefined"!=typeof window&&"chrome-extension:"===window.location.protocol&&"chrome"in window}function ce(){if(!le())return;let e=window.chrome;return e?.runtime?.id}function de(){if(!le())return!1;let e=window.chrome;return"function"==typeof e?.identity?.launchWebAuthFlow}async function ue(e){return new Promise(((t,r)=>{de()?window.chrome.identity.launchWebAuthFlow({url:e,interactive:!0},(async e=>{try{let r=function(){if(!le())return;let e=window.chrome;return e?.runtime?.lastError?.message}();if(r||!e){let e=`WebAuthFlow failed: ${r||"Response URI missing"}`;throw Error(e)}let n=new URL(e),i=ce();if(!i)throw Error("Invalid extension context");if("chrome-extension:"===n.protocol){if(n.hostname!==i)throw Error("Invalid responseUri origin")}else{if("https:"!==n.protocol)throw Error("Invalid responseUri protocol");{let e=n.hostname.split(".");if(3!==e.length||"chromiumapp"!==e[1]||"org"!==e[2]||e[0]!==i)throw Error("Invalid responseUri origin")}}let a=n.searchParams.get("privy_oauth_state"),s=n.searchParams.get("privy_oauth_code");if(!a||!s)throw Error("Invalid responseUri - missing required parameters");t({privyOAuthState:a,privyOAuthCode:s})}catch(e){r(e)}})):r(Error("Chrome identity API not available"))}))}function he(e){return crypto.getRandomValues(new Uint8Array(e))}function pe(){return i.base64url.encode(he(36))}function ye(){return pe()}async function we(e,t="S256"){if("S256"!=t)return e;{let t=await async function(e){let t=(new TextEncoder).encode(e);return new Uint8Array(await crypto.subtle.digest("SHA-256",t))}(e);return i.base64url.encode(t)}}class me{addCaptchaToken(e){this.meta.captchaToken=e}isActive(){return!!(this.meta.authorizationCode&&this.meta.stateCode&&this.meta.provider)}async authenticate(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new c.PrivyClientError("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenticate.");if("undefined"===this.meta.authorizationCode)throw new c.PrivyClientError("User denied confirmation during OAuth flow");let e=function(){let e=d.u.get(p.CODE_VERIFIER_KEY);if(!e)throw new c.PrivyClientError("Authentication error.");return e}();try{let t=await this.api.post(v.oAuthAuthenticatePath,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});return d.u.del(p.CODE_VERIFIER_KEY),d.u.del(p.HEADLESS_OAUTH_KEY),d.u.del(p.OAUTH_DISABLE_SIGNUP_KEY),t}catch(e){let t=c.formatApiError(e);if(t.privyErrorCode)throw new c.PrivyClientError(t.message||"Invalid code during OAuth flow.",void 0,t.privyErrorCode);if("User denied confirmation during OAuth flow"===t.message)throw new c.PrivyClientError("Invalid code during oauth flow.",void 0,c.PrivyErrorCode.OAUTH_USER_DENIED);throw new c.PrivyClientError("Invalid code during OAuth flow.",void 0,c.PrivyErrorCode.UNKNOWN_AUTH_ERROR)}}async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new c.PrivyClientError("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling link.");if("undefined"===this.meta.authorizationCode)throw new c.PrivyClientError("User denied confirmation during OAuth flow");let e=d.u.get(p.CODE_VERIFIER_KEY);if(!e)throw new c.PrivyClientError("Authentication error.");try{let t=await this.api.post(v.oAuthLinkPath,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e});return d.u.del(p.CODE_VERIFIER_KEY),t}catch(e){throw c.formatApiError(e)}}async getAuthorizationUrl(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.provider)throw new c.PrivyClientError("Provider must be set when initializing OAuth authentication.");let e=pe();d.u.put(p.CODE_VERIFIER_KEY,e);let t=ye();d.u.put(p.STATE_CODE_KEY,t);let r=await we(e);this.meta.withPrivyUi||d.u.put(p.HEADLESS_OAUTH_KEY,!0),this.meta.disableSignup?d.u.put(p.OAUTH_DISABLE_SIGNUP_KEY,!0):d.u.del(p.OAUTH_DISABLE_SIGNUP_KEY);let n=ne(this.meta.withPrivyUi),i=window.location.href,a=function(){let e=ce();if(e)return`https://${e}.chromiumapp.org`}();a&&(i=a);try{return await this.api.post(v.oAuthInitPath,{provider:this.meta.provider,redirect_to:this.meta.customOAuthRedirectUrl||i,token:this.meta.captchaToken,code_challenge:r,state_code:t},{headers:{...n}})}catch(e){throw c.formatApiError(e)}}constructor(e){this.meta=e}}function ge(){let e=new URLSearchParams(window.location.search),t=e.get("privy_oauth_code"),r=e.get("privy_oauth_state"),n=e.get("privy_oauth_provider");if(!t||!r||!n)return{inProgress:!1};let i=!1;try{i=!!window.opener.location.origin}catch{}return{inProgress:!0,authorizationCode:t,stateCode:r,provider:n,withPrivyUi:!d.u.get(p.HEADLESS_OAUTH_KEY),popupFlow:null!==window.opener&&i,disableSignup:!!d.u.get(p.OAUTH_DISABLE_SIGNUP_KEY)}}function ve(){let e=new URL(window.location.href);e.searchParams.delete("privy_oauth_code"),e.searchParams.delete("privy_oauth_provider"),e.searchParams.delete("privy_oauth_state"),d.u.del(p.STATE_CODE_KEY),window.history.replaceState({},"",e)}class fe{async initRegisterFlow(e){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");this.authenticateForRegistration=!0,this.meta.initRegisterResponse=await this.initRegisterOnce.execute(e)}async initAuthenticationFlow(e){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");this.authenticateForRegistration=!1,this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute(e)}async initLinkFlow(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");this.meta.initLinkResponse=await this.initLinkOnce.execute()}async register(){let e=await import("@simplewebauthn/browser");if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new c.PrivyClientError("WebAuthn is not supported in this browser");this.meta.initRegisterResponse||(this.meta.initRegisterResponse=await this.initRegisterOnce.execute());try{let t=this.meta.initRegisterResponse.options,r=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(v.passkeyRegisterPath,{relying_party:this.meta.initRegisterResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(r)})}catch(e){if("NotAllowedError"===e.name)throw new c.PrivyClientError("Passkey request timed out or rejected by user.",void 0,c.PrivyErrorCode.PASSKEY_NOT_ALLOWED);throw c.formatApiError(e)}}async authenticate(){if(this.authenticateForRegistration)return this.register();let e=await import("@simplewebauthn/browser");if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new c.PrivyClientError("WebAuthn is not supported in this browser");this.meta.initAuthenticateResponse||(this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute());let t=this.meta.allowedCredentialsIds?.map((e=>({type:"public-key",id:e})))??this.meta.initAuthenticateResponse.options.allow_credentials;try{let r=await e.startAuthentication({optionsJSON:this._transformInitAuthenticateOptionsToCamelCase({...this.meta.initAuthenticateResponse.options,allow_credentials:t})});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(v.passkeyAuthenticatePath,{relying_party:this.meta.initAuthenticateResponse.relying_party,challenge:this.meta.initAuthenticateResponse.options.challenge,authenticator_response:this._transformAuthenticationResponseToSnakeCase(r)})}catch(e){if("NotAllowedError"===e.name)throw new c.PrivyClientError("Passkey request timed out or rejected by user.",void 0,c.PrivyErrorCode.PASSKEY_NOT_ALLOWED);throw c.formatApiError(e)}}async link(){let e=await import("@simplewebauthn/browser");if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new c.PrivyClientError("WebAuthn is not supported in this browser");this.meta.initLinkResponse||(this.meta.initLinkResponse=await this.initLinkOnce.execute());try{let t=this.meta.initLinkResponse.options,r=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(v.passkeyLinkPath,{relying_party:this.meta.initLinkResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(r)})}catch(e){if("NotAllowedError"===e.name)throw new c.PrivyClientError("Passkey request timed out or rejected by user.",void 0,c.PrivyErrorCode.PASSKEY_NOT_ALLOWED);throw c.formatApiError(e)}}async _initRegisterOnce(e){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");let t=ne(e);return await this.api.post(v.passkeyInitRegisterPath,{token:this.meta.captchaToken},{headers:{...t}})}async _initAuthenticateOnce(e){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");let t=ne(e);return await this.api.post(v.passkeyInitAuthenticatePath,{token:this.meta.captchaToken},{headers:{...t}})}async _initLinkOnce(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");return await this.api.post(v.passkeyInitLinkPath,{})}_transformInitLinkOptionsToCamelCase(e){return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params.map((e=>({type:e.type,alg:e.alg}))),timeout:e.timeout,excludeCredentials:e.exclude_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports}))),authenticatorSelection:{authenticatorAttachment:e.authenticator_selection?.authenticator_attachment,requireResidentKey:e.authenticator_selection?.require_resident_key,residentKey:e.authenticator_selection?.resident_key,userVerification:e.authenticator_selection?.user_verification},attestation:e.attestation,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props?.rk,hmacCreateSecret:e.extensions?.hmac_create_secret},hints:this.meta.hints}}_transformRegistrationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,attestation_object:e.response.attestationObject,authenticator_data:e.response.authenticatorData},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}_transformInitAuthenticateOptionsToCamelCase(e){return{rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification}}_transformAuthenticationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}constructor({captchaToken:e,setPasskeyAuthState:t,hints:r}){this.authenticateForRegistration=!1,this.initRegisterOnce=new se(this._initRegisterOnce.bind(this)),this.initAuthenticateOnce=new se(this._initAuthenticateOnce.bind(this)),this.initLinkOnce=new se(this._initLinkOnce.bind(this)),this.meta={captchaToken:e,setPasskeyAuthState:t,hints:r}}}const Ee=({address:e,chainId:t,nonce:r})=>`${window.location.host} wants you to sign in with your Ethereum account:\n${e}\n\nBy signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.\n\nURI: ${window.location.origin}\nVersion: 1\nChain ID: ${t}\nNonce: ${r}\nIssued At: ${(new Date).toISOString()}\nResources:\n- https://privy.io`;class Ce{get meta(){return{connectorType:this.wallet?.connectorType,walletClientType:this.wallet?.walletClientType,chainId:this.wallet?.chainId,address:this.wallet?.address,disableSignup:this._meta.disableSignup}}async authenticate(){if(!this.client)throw new c.PrivyClientError("SiweFlow has no client instance");try{if(this.preparedMessage&&this.signature)return await this.client.authenticateWithSiweInternal({message:this.preparedMessage,signature:this.signature,chainId:this.wallet?.chainId,walletClientType:this.walletClientType??this.wallet?.walletClientType,connectorType:this.connectorType??this.wallet?.connectorType,mode:this._meta.disableSignup?"no-signup":"login-or-sign-up"});if(!this.wallet)throw new c.PrivyClientError("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw c.formatApiError(e)}}async link(){if(!this.client)throw new c.PrivyClientError("SiweFlow has no client instance");try{if(!this.wallet)throw new c.PrivyClientError("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType})}catch(e){throw c.formatApiError(e)}}async sign(){if(!this.client)throw new c.PrivyClientError("SiweFlow has no client instance");if(await this.buildMessage(),!this.preparedMessage)throw new c.PrivyClientError("Could not prepare SIWE message");if(!this.wallet)throw new c.PrivyClientError("SiweFlow has no wallet instance");let e=await this.wallet.sign(this.preparedMessage);return{message:this.preparedMessage,signature:e}}async _getNonceOnce(){if(!this.client)throw new c.PrivyClientError("SiweFlow has no client instance");if(!this.wallet)throw new c.PrivyClientError("UI SiweFlow has no wallet instance");return await this.client.generateSiweNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new c.PrivyClientError("SiweFlow has no client instance");if(!this.wallet)throw new c.PrivyClientError("SiweFlow has no wallet instance");let e=this.wallet.address,t=this.wallet.chainId.replace("eip155:","");return this.nonce||(this.nonce=await this.getNonceOnce.execute()),this.preparedMessage=Ee({address:e,chainId:t,nonce:this.nonce}),this.preparedMessage}constructor(e,t,r,n=!1,i){this._meta={disableSignup:!1},this.getNonceOnce=new se(this._getNonceOnce.bind(this)),this.wallet=t,this.captchaToken=r,this.client=e,this._meta.disableSignup=n,this.preparedMessage=i?.message,this.signature=i?.signature,this.walletClientType=i?.walletClientType,this.connectorType=i?.connectorType}}class Ae{get meta(){return{connectorType:this.wallet.connectorType,walletClientType:this.wallet.walletClientType,disableSignup:this._meta.disableSignup,messageType:this._meta.messageType,address:this.wallet?.address}}set messageType(e){this._meta.messageType=e}async authenticate(){if(!this.client)throw new c.PrivyClientError("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up",messageType:this.meta.messageType})}catch(e){throw c.formatApiError(e)}}async link(){if(!this.client)throw new c.PrivyClientError("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,messageType:this.meta.messageType})}catch(e){throw c.formatApiError(e)}}async sign(){let e,t;if(!this.client)throw new c.PrivyClientError("SiwsFlow has no client instance");await this.buildMessage();let r="transaction"===this.meta.messageType;if(!this.preparedMessage)throw new c.PrivyClientError("Could not prepare SIWS message");if(!r&&!this.wallet.provider.signMessage||r&&!this.wallet.provider.signTransaction)throw new c.PrivyClientError("Wallet does not support the necessary signing methods");if(r&&this._plugin){let r=await this.wallet.provider.signTransaction({transaction:E.base64.decode(this.preparedMessage)});e=E.base64.encode(r.signedTransaction),t=this._plugin.getSignatureFromTransaction(r.signedTransaction,this.wallet.address)}else{e=this.preparedMessage;let r=await this.wallet.provider.signMessage({message:(new TextEncoder).encode(this.preparedMessage)});t=E.base64.encode(r.signature)}return{message:e,signature:t}}async _getNonceOnce(){if(!this.client)throw new c.PrivyClientError("SiwsFlow has no client instance");return await this.client.generateSiwsNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new c.PrivyClientError("SiwsFlow has no client instance");let e=this.wallet.address;return this.nonce||(this.nonce=await this.getNonceOnce.execute()),"transaction"===this.meta.messageType&&this._plugin?this.preparedMessage=this._plugin.createSiwsMemoTransaction({address:e,nonce:this.nonce}):this.preparedMessage=f.prepareSiwsMessageWithNonce({address:e,nonce:this.nonce}),this.preparedMessage}constructor(e,t,r,n=!1,i="plain",a){this._meta={disableSignup:!1,messageType:"plain"},this.getNonceOnce=new se(this._getNonceOnce.bind(this)),this.wallet=e,this.captchaToken=r,this.client=t,this._meta.disableSignup=n,this._meta.messageType=i,this._plugin=a}}class Pe{async authenticate(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new c.PrivyClientError("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(v.passwordlessSmsAuthenticatePath,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw c.formatApiError(e)}}async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new c.PrivyClientError("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(v.passwordlessSmsLinkPath,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw c.formatApiError(e)}}async sendSmsCode({phoneNumber:e,captchaToken:t,withPrivyUi:r}){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(e&&(this.meta.phoneNumber=e),t&&(this.meta.captchaToken=t),!this.meta.phoneNumber)throw new c.PrivyClientError("phone nNumber must be set when initialzing authentication.");let n=ne(r);try{return await this.api.post(v.passwordlessSmsInitPath,{phoneNumber:this.meta.phoneNumber,token:this.meta.captchaToken},{headers:{...n}})}catch(e){throw c.formatApiError(e)}}constructor({phoneNumber:e,captchaToken:t,disableSignup:r}){this.meta={phoneNumber:e,captchaToken:t,disableSignup:r??!1}}}class Te extends Pe{async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode||!this.meta.oldPhoneNumber)throw new c.PrivyClientError("Phone number, sms code, and an old phone number must be set prior to calling update.");try{return await this.api.post(v.updatePhonePath,{old_phone_number:this.meta.oldPhoneNumber,new_phone_number:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw c.formatApiError(e)}}constructor(e,t,r){super({phoneNumber:t,captchaToken:r}),this.meta={phoneNumber:t,captchaToken:r,oldPhoneNumber:e,disableSignup:!1}}}const ke=/*#__PURE__*/t.createContext({enabled:!1,siteKey:"",provider:void 0,appId:void 0,token:void 0,error:void 0,status:"disabled",setToken:c.notImplemented,setError:c.notImplemented,setExecuting:c.notImplemented,waitForResult:()=>Promise.resolve(""),ref:{current:null},remove:c.noop,reset:c.notImplemented,execute:c.notImplemented});class _e extends c.PrivyError{constructor(e,t,r){super(e||"Captcha failed"),this.type="Captcha",t instanceof Error&&(this.cause=t),this.privyErrorCode=r}}const Se=({children:r,appId:n,captchaSiteKey:i,enabledCaptchaProvider:a})=>{let s=t.useRef(null),l=t.useRef(null),[d,u]=t.useState(),[h,p]=t.useState(),[y,w]=t.useState(!1),m=t.useMemo((()=>a?y||d||h?!y||d||h?d&&!h?{status:"success",token:d}:h?{status:"error",error:h}:{status:"ready"}:{status:"loading"}:{status:"ready"}:{status:"disabled"}),[a,d,h,y]),g=t.useMemo((()=>a?"turnstile"===a?{remove:()=>{s.current?.remove(),w(!1),p(void 0),u(void 0)},reset:()=>{s.current?.reset(),w(!1),p(void 0),u(void 0)},execute:()=>{w(!0),s.current?.execute()},waitForResult:async()=>{try{return await o.pollForResult((()=>s.current?.getResponse()),{interval:200,timeout:2e4})}catch(e){throw new _e("Captcha failed",null,c.PrivyErrorCode.CAPTCHA_TIMEOUT)}}}:{remove:()=>{l.current?.removeCaptcha(),w(!1),p(void 0),u(void 0)},reset:()=>{l.current?.resetCaptcha(),w(!1),p(void 0),u(void 0)},execute:()=>{w(!0),l.current?.execute()},waitForResult:async()=>{try{return await o.pollForResult((()=>{let e=l.current?.getResponse();if(e)return e}),{interval:200,timeout:2e4})}catch(e){throw new _e("Captcha failed",null,c.PrivyErrorCode.CAPTCHA_TIMEOUT)}}}:null),[a]),v=t.useMemo((()=>{if(!a||!g)return{...m,enabled:!1,siteKey:"",appId:n,setToken:c.notImplemented,setError:c.notImplemented,setExecuting:c.notImplemented,waitForResult:()=>Promise.resolve(void 0),remove:c.noop,reset:c.notImplemented,execute:c.notImplemented,provider:void 0,ref:{current:null}};let e={...m,enabled:!0,appId:n,setToken:u,setError:p,setExecuting:w};return"turnstile"===a?{...e,provider:"turnstile",ref:s,siteKey:i.split("t:")[1]??"",...g}:{...e,provider:"hcaptcha",ref:l,siteKey:i.split("h:")[1]??"",...g}}),[m,a,g,n,i]);/*#__PURE__*/return e.jsx(ke.Provider,{value:v,children:r})},be=()=>t.useContext(ke);async function Ie(e){if(e.enabled){if("error"===e.status)throw new _e(e.error,null,c.PrivyErrorCode.CAPTCHA_FAILURE);return"success"===e.status?e.token:(e.execute(),await e.waitForResult())}}class We{async authenticate(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");try{return await this.api.post(v.telegramAccountAuthenticatePath,{captcha_token:this.meta.captchaToken,telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw c.formatApiError(e)}}async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");try{return await this.api.post(v.telegramAccountLinkPath,{telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData})}catch(e){throw c.formatApiError(e)}}constructor(e,t=!1){this.meta={disableSignup:!1},this.meta={captchaToken:e,disableSignup:!1},this.meta.disableSignup=t}}function Ue(e){return Object.fromEntries(decodeURIComponent(e).split("&").map((e=>e.split("=").map(decodeURIComponent))))}function xe(){let e=new URL(window.location.href);e.searchParams.delete("id"),e.searchParams.delete("hash"),e.searchParams.delete("auth_date"),e.searchParams.delete("first_name"),e.searchParams.delete("last_name"),e.searchParams.delete("username"),e.searchParams.delete("photo_url"),e.hash="",window.history.replaceState({},"",e)}let Re=/*#__PURE__*/t.lazy((()=>Promise.resolve().then((function(){return require("./TurnstileWrapper-qLN0G5m7.js")})))),Oe=/*#__PURE__*/t.lazy((()=>Promise.resolve().then((function(){return require("./HCaptchaWrapper-CxqJE5RH.js")}))));const Ne=r=>{let n=be();return t.useEffect((()=>n.remove),[n.remove]),n.enabled&&n.provider?/*#__PURE__*/e.jsx(t.Suspense,{fallback:null,children:/*#__PURE__*/e.jsxs("div",{className:"hidden h-0 w-0",children:["turnstile"===n.provider&&/*#__PURE__*/e.jsx(Re,{...r,captchaContext:n}),"hcaptcha"===n.provider&&/*#__PURE__*/e.jsx(Oe,{...r,captchaContext:n})]})}):null};var Me=/*#__PURE__*/Object.freeze({__proto__:null,AccountNotFoundScreen:()=>Promise.resolve().then((function(){return require("./AccountNotFoundScreen-BBWWze9O.js")})),AffirmativeConsentScreen:()=>Promise.resolve().then((function(){return require("./AffirmativeConsentScreen-CCwAwjH1.js")})),AllowlistRejectionScreen:()=>Promise.resolve().then((function(){return require("./AllowlistRejectionScreen-DEMYbzGA.js")})),AuthenticateWithWalletScreen:()=>Promise.resolve().then((function(){return require("./AuthenticateWithWalletScreen-dBvBC7MB.js")})),AwaitingEvmToSolBridgingScreen:()=>Promise.resolve().then((function(){return require("./AwaitingEvmToSolBridgingScreen-D9NwI47L.js")})),AwaitingExternalEthereumTransferScreen:()=>Promise.resolve().then((function(){return require("./AwaitingExternalEthereumTransferScreen-D_0NulpI.js")})),AwaitingPasswordlessCodeScreen:()=>Promise.resolve().then((function(){return require("./AwaitingPasswordlessCodeScreen-B4HAKL4-.js")})),AwaitingSolToEvmBridgingScreen:()=>Promise.resolve().then((function(){return require("./AwaitingSolToEvmBridgingScreen-CnuLLTC0.js")})),CaptchaScreen:()=>Promise.resolve().then((function(){return require("./CaptchaScreen-N-ueJQF3.js")})),CoinbaseOnrampStatusScreen:()=>Promise.resolve().then((function(){return require("./CoinbaseOnrampStatusScreen-06yaO6r4.js")})),ConnectLedgerScreen:()=>Promise.resolve().then((function(){return require("./ConnectLedgerScreen-C7vGQocf.js")})),ConnectOnlyLandingScreen:()=>Promise.resolve().then((function(){return require("./ConnectOnlyLandingScreen-_9y9kOsT.js")})),ConnectOnlyStatusScreen:()=>Promise.resolve().then((function(){return require("./ConnectOnlyStatusScreen-mZHx4a7S.js")})),ConnectOrCreateScreen:()=>Promise.resolve().then((function(){return require("./ConnectOrCreateScreen-Cp4uExOd.js")})),ConnectionStatusScreen:()=>Promise.resolve().then((function(){return require("./ConnectionStatusScreen-B27DUsGt.js")})),CrossAppAuthScreen:()=>Promise.resolve().then((function(){return require("./CrossAppAuthScreen-BbLFbCdU.js")})),DelegatedActionsConsentScreen:()=>Promise.resolve().then((function(){return require("./DelegatedActionsConsentScreen-DzWruJOn.js")})),DelegatedActionsRevokeScreen:()=>Promise.resolve().then((function(){return require("./DelegatedActionsRevokeScreen-D-TwUXyj.js")})),EmbeddedWalletConnectingScreen:()=>Promise.resolve().then((function(){return require("./EmbeddedWalletConnectingScreen-CYav4Mjb.js")})),EmbeddedWalletCreatedScreen:()=>Promise.resolve().then((function(){return require("./EmbeddedWalletCreatedScreen-m0t_c_AA.js")})),EmbeddedWalletKeyExportScreen:()=>Promise.resolve().then((function(){return require("./EmbeddedWalletKeyExportScreen-_4GMdJuo.js")})),EmbeddedWalletOnAccountCreateScreen:()=>Promise.resolve().then((function(){return require("./EmbeddedWalletOnAccountCreateScreen-B5-JBZRJ.js")})),EmbeddedWalletPasswordCreateScreen:()=>Promise.resolve().then((function(){return require("./RecoveryPasswordCreateScreen-DP0xOBMA.js")})),EmbeddedWalletPasswordUpdateScreen:()=>Promise.resolve().then((function(){return require("./EmbeddedWalletPasswordUpdateScreen-CITAy3i6.js")})),EmbeddedWalletPasswordUpdateSplashScreen:()=>Promise.resolve().then((function(){return require("./EmbeddedWalletPasswordUpdateSplashScreen-DG5LKyjo.js")})),ErrorScreen:()=>Promise.resolve().then((function(){return require("./ErrorScreen-xNDIVXx8.js")})),FarcasterConnectStatusScreen:()=>Promise.resolve().then((function(){return require("./FarcasterConnectStatusScreen-Bzmd4izn.js")})),FarcasterSignerStatusScreen:()=>Promise.resolve().then((function(){return require("./FarcasterSignerStatusScreen-Cxoi54pp.js")})),FundSolWalletWithExternalSolanaWallet:()=>Promise.resolve().then((function(){return require("./FundSolWalletWithExternalSolanaWallet-BCyBv_xe.js")})),FundingAmountEditScreen:()=>Promise.resolve().then((function(){return require("./FundingEditAmountScreen-CDlb4Acx.js")})),FundingMethodSelectionScreen:()=>Promise.resolve().then((function(){return require("./FundingMethodSelectionScreen-DlPxjsJq.js")})),InAppBrowserLoginNotPossible:()=>Promise.resolve().then((function(){return require("./InAppBrowserLoginNotPossible-Bdx0vKyA.js")})),InstallWalletScreen:()=>Promise.resolve().then((function(){return require("./InstallWalletScreen-Cshn01eK.js")})),LandingScreen:()=>Promise.resolve().then((function(){return require("./LandingScreen-0FdwpJ9w.js")})),LinkConflictScreen:()=>Promise.resolve().then((function(){return require("./LinkConflictScreen-BCzS7Szr.js")})),LinkEmailScreen:()=>Promise.resolve().then((function(){return require("./LinkEmailScreen-B7rxdQso.js")})),LinkPasskeyScreen:()=>Promise.resolve().then((function(){return require("./LinkPasskeyScreen-o4qdrAL3.js")})),LinkPhoneScreen:()=>Promise.resolve().then((function(){return require("./LinkPhoneScreen-DweFqlM1.js")})),LoginFailedScreen:()=>Promise.resolve().then((function(){return require("./LoginFailedScreen-mHcvCBEz.js")})),ManualTransferScreen:()=>Promise.resolve().then((function(){return require("./ManualTransferScreen-CfYgtyLD.js")})),MfaAuthEnrollmentFlowScreen:()=>Promise.resolve().then((function(){return require("./MfaAuthEnrollmentFlowScreen-D631h0XW.js")})),MfaAuthVerifyFlowScreen:()=>Promise.resolve().then((function(){return require("./MfaAuthVerifyFlowScreen-BZ3IyqAd.js")})),MfaEnrollmentFlowScreen:()=>Promise.resolve().then((function(){return require("./MfaEnrollmentFlowScreen-_tNeX5lT.js")})),MoonpayStatusScreen:()=>Promise.resolve().then((function(){return require("./MoonpayStatusScreen-DoFbZ_0d.js")})),OAuthStatusScreen:()=>Promise.resolve().then((function(){return require("./OAuthStatusScreen-BZY7BiP5.js")})),PasskeySelectSignupOrLogin:()=>Promise.resolve().then((function(){return require("./PasskeySelectSignupOrLogin-C3k_ixTz.js")})),PasskeyStatusScreen:()=>Promise.resolve().then((function(){return require("./PasskeyStatusScreen-BX-SOBDr.js")})),PasswordRecoveryScreen:()=>Promise.resolve().then((function(){return require("./PasswordRecoveryScreen-VZQDtt5v.js")})),RecoveryOAuthScreen:()=>Promise.resolve().then((function(){return require("./RecoveryOAuthStatusScreen-DKYx6ECd.js")})),RecoverySelectionScreen:()=>Promise.resolve().then((function(){return require("./RecoverySelectionScreen-Bw9_M6y0.js")})),SendTransactionScreen:()=>Promise.resolve().then((function(){return require("./index-0-2WrPDo.js")})),SetAutomaticRecoveryScreen:()=>Promise.resolve().then((function(){return require("./SetAutomaticRecoveryScreen-SUOUjBk4.js")})),SignRequestScreen:()=>Promise.resolve().then((function(){return require("./SignRequestScreen-BNcy6yU_.js")})),StandardSignAndSendTransactionScreen:()=>Promise.resolve().then((function(){return require("./StandardSignAndSendTransactionScreen-z_EUNaeD.js")})),TelegramAuthScreen:()=>Promise.resolve().then((function(){return require("./TelegramAuthScreen-DV8KYJMX.js")})),TransferFromWalletScreen:()=>Promise.resolve().then((function(){return require("./TransferFromWalletScreen-Duk7CEcq.js")})),UpdateEmailScreen:()=>Promise.resolve().then((function(){return require("./UpdateEmailScreen-DRJv5CZs.js")})),UpdatePhoneScreen:()=>Promise.resolve().then((function(){return require("./UpdatePhoneScreen-C3myqOv0.js")})),UserLimitReachedScreen:()=>Promise.resolve().then((function(){return require("./UserLimitReachedScreen-l_e6Vhr0.js")})),WalletInterstitialScreen:()=>Promise.resolve().then((function(){return require("./WalletInterstitialScreen-BgoDwKIp.js")}))});function Fe(e){A.usePrivyEventSubscription("configureMfa",e)}const De=P.create((()=>({inProgressMfaFlow:void 0})));const Le=C.createGlobalStyle`
  :root {
     ${e=>je(e.palette)}
  };
`;const je=e=>{let t=function(e){return{"--privy-color-background":e.background,"--privy-color-background-2":e.background2,"--privy-color-background-3":e.background3,"--privy-color-foreground":e.foreground,"--privy-color-foreground-2":e.foreground2,"--privy-color-foreground-3":e.foreground3,"--privy-color-foreground-4":e.foreground4,"--privy-color-foreground-accent":e.foregroundAccent,"--privy-color-accent":e.accent,"--privy-color-accent-light":e.accentLight,"--privy-color-accent-hover":e.accentHover,"--privy-color-accent-dark":e.accentDark,"--privy-color-accent-darkest":e.accentDarkest,"--privy-color-success":e.success,"--privy-color-success-dark":e.successDark,"--privy-color-success-light":e.successLight,"--privy-color-success-bg":e.successBg,"--privy-color-error":e.error,"--privy-color-error-light":e.errorLight,"--privy-color-error-bg":e.errorBg,"--privy-color-error-bg-hover":e.errorBgHover,"--privy-color-warn":e.warn,"--privy-color-warn-light":e.warnLight,"--privy-color-warn-bg":e.warnBg,"--privy-color-warning-dark":e.warningDark,"--privy-color-error-dark":e.errorDark,"--privy-color-info-bg":e.infoBg,"--privy-color-info-bg-hover":e.infoBgHover,"--privy-color-border-default":e.borderDefault,"--privy-color-border-hover":e.borderHover,"--privy-color-border-focus":e.borderFocus,"--privy-color-border-error":e.borderError,"--privy-color-border-success":e.borderSuccess,"--privy-color-border-warning":e.borderWarning,"--privy-color-border-info":e.borderInfo,"--privy-color-border-interactive":e.borderInteractive,"--privy-color-border-interactive-hover":e.borderInteractiveHover,"--privy-color-background-hover":e.backgroundHover,"--privy-color-background-clicked":e.backgroundClicked,"--privy-color-background-disabled":e.backgroundDisabled,"--privy-color-background-interactive":e.backgroundInteractive,"--privy-color-background-interactive-hover":e.backgroundInteractiveHover,"--privy-color-background-interactive-clicked":e.backgroundInteractiveClicked,"--privy-color-background-interactive-disabled":e.backgroundInteractiveDisabled,"--privy-color-foreground-hover":e.foregroundHover,"--privy-color-foreground-clicked":e.foregroundClicked,"--privy-color-foreground-disabled":e.foregroundDisabled,"--privy-color-foreground-interactive":e.foregroundInteractive,"--privy-color-foreground-interactive-hover":e.foregroundInteractiveHover,"--privy-link-navigation-color":e.linkNavigationColor,"--privy-link-navigation-decoration":e.linkNavigationDecoration,"--privy-accent-has-good-contrast":e.accentHasGoodContrast,"--privy-color-icon-default":e.iconDefault,"--privy-color-icon-muted":e.iconMuted,"--privy-color-icon-subtle":e.iconSubtle,"--privy-color-icon-inverse":e.iconInverse,"--privy-color-icon-success":e.iconSuccess,"--privy-color-icon-warning":e.iconWarning,"--privy-color-icon-error":e.iconError,"--privy-color-icon-interactive":e.iconInteractive,"--privy-color-icon-default-hover":e.iconDefaultHover,"--privy-color-icon-muted-hover":e.iconMutedHover,"--privy-color-icon-subtle-hover":e.iconSubtleHover,"--privy-color-icon-default-clicked":e.iconDefaultClicked,"--privy-color-icon-muted-clicked":e.iconMutedClicked,"--privy-color-icon-subtle-clicked":e.iconSubtleClicked,"--privy-color-icon-default-disabled":e.iconDefaultDisabled,"--privy-color-icon-muted-disabled":e.iconMutedDisabled,"--privy-color-icon-subtle-disabled":e.iconSubtleDisabled,"--privy-color-icon-error-hover":e.iconErrorHover,"--privy-color-icon-interactive-hover":e.iconInteractiveHover,"--privy-color-icon-error-clicked":e.iconErrorClicked,"--privy-color-icon-interactive-clicked":e.iconInteractiveClicked,"--privy-color-icon-muted-disabled-alt":e.iconMutedDisabledAlt,"--privy-color-icon-subtle-disabled-alt":e.iconSubtleDisabledAlt,"--privy-border-radius-xs":"6px","--privy-border-radius-sm":"8px","--privy-border-radius-md":"12px","--privy-border-radius-mdlg":"16px","--privy-border-radius-lg":"24px","--privy-border-radius-full":"9999px","--privy-height-modal-full":"620px","--privy-height-modal-compact":"480px"}}(e);return C.css`
    ${Object.entries(t).map((([e,t])=>`${e}: ${t};`)).join("\n")}
  `},qe=C.styled.div`
  // css normalize only the privy application to avoid conflicts
  // with consuming application
  ${"\n  *,\n  ::before,\n  ::after {\n    box-sizing: border-box;\n    border-width: 0;\n    border-style: solid;\n  }\n\n  line-height: 1.15;\n  -webkit-text-size-adjust: 100%;\n  -moz-tab-size: 4;\n  tab-size: 4;\n  font-feature-settings: normal;\n\n  margin: 0;\n  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n\n  abbr:where([title]) {\n    text-decoration: underline dotted;\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-size: inherit;\n    font-weight: inherit;\n    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n    display: inline;\n  }\n\n  a {\n    color: inherit;\n    text-decoration: inherit;\n  }\n\n  b,\n  strong {\n    font-weight: bolder;\n  }\n\n  code,\n  kbd,\n  samp,\n  pre {\n    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;\n    font-size: 1em;\n  }\n\n  small {\n    font-size: 80%;\n  }\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n\n  button,\n  input,\n  optgroup,\n  select,\n  textarea {\n    font-family: inherit;\n    font-size: 100%;\n    font-weight: inherit;\n    line-height: inherit;\n    color: inherit;\n    margin: 0;\n    padding: 0;\n  }\n\n  button,\n  select {\n    text-transform: none;\n  }\n\n  button,\n  [type='button'],\n  [type='reset'],\n  [type='submit'] {\n    -webkit-appearance: button;\n    background-color: transparent;\n    background-image: none;\n  }\n\n  ::-moz-focus-inner {\n    border-style: none;\n    padding: 0;\n  }\n\n  :-moz-focusring {\n    outline: 1px dotted ButtonText;\n  }\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  ::-webkit-inner-spin-button,\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  [type='search'] {\n    -webkit-appearance: textfield;\n    outline-offset: -2px;\n  }\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  ::-webkit-file-upload-button {\n    -webkit-appearance: button;\n    font: inherit;\n  }\n\n  summary {\n    display: list-item;\n  }\n\n  blockquote,\n  dl,\n  dd,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  hr,\n  figure,\n  p,\n  pre {\n    margin: 0;\n  }\n\n  fieldset {\n    margin: 0;\n    padding: 0;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  ol,\n  ul,\n  menu {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  textarea {\n    resize: vertical;\n  }\n\n  input::placeholder,\n  textarea::placeholder {\n    opacity: 1;\n    color: #9ca3af;\n  }\n\n  button,\n  [role='button'] {\n    cursor: pointer;\n  }\n\n  :disabled {\n    cursor: default;\n  }\n\n  img,\n  svg,\n  video,\n  canvas,\n  audio,\n  iframe,\n  embed,\n  object {\n    display: block;\n  }\n\n  img,\n  video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  [hidden] {\n    display: none;\n  }\n"}

  // Privy styles
  color: var(--privy-color-foreground-2);

  h3 {
    font-size: 16px;
    line-height: 24px;
    font-weight: 500;
    color: var(--privy-color-foreground-2);
  }

  h4 {
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: var(--privy-color-foreground);
  }

  p {
    font-size: 13px;
    line-height: 20px;
    color: var(--privy-color-foreground-2);
  }

  button:focus,
  input:focus,
  optgroup:focus,
  select:focus,
  textarea:focus {
    outline: none;
    border-color: var(--privy-color-accent-light);
    box-shadow: 0 0 0 3px var(--privy-color-border-focus);
  }

  .mobile-only {
    @media (min-width: 441px) {
      display: none;
    }
  }

  /* Animations */

  @keyframes fadein {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
`,ze=({children:t,open:r,onClick:n,...i})=>/*#__PURE__*/e.jsx(T.Transition,{show:r,as:L.default.Fragment,children:/*#__PURE__*/e.jsxs(T.Dialog,{onClose:n,...i,as:He,children:[/*#__PURE__*/e.jsx(T.TransitionChild,{as:L.default.Fragment,enterFrom:"entering",leaveTo:"leaving",children:/*#__PURE__*/e.jsx(Ke,{id:"privy-dialog-backdrop","aria-hidden":"true"})}),/*#__PURE__*/e.jsx(Ve,{children:/*#__PURE__*/e.jsx(T.TransitionChild,{as:L.default.Fragment,enterFrom:"entering",leaveTo:"leaving",children:/*#__PURE__*/e.jsx(T.DialogPanel,{as:Be,children:t})})})]})});let Ke=C.styled.div`
  position: fixed;
  inset: 0;

  transition: backdrop-filter 100ms ease;
  backdrop-filter: blur(3px);
  -webkit-backdrop-filter: blur(3px);

  &.entering,
  &.leaving {
    backdrop-filter: unset;
    -webkit-backdrop-filter: unset;
  }
`,He=C.styled.div`
  position: relative;
  z-index: 999999;
`,Ve=C.styled.div`
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  min-height: 100vh;
`;const Be=C.styled.div`
  // reset some default dialog styles
  padding: 0;
  background: transparent;
  border: none;
  width: 100%;
  pointer-events: auto;

  outline: none;
  display: block;

  /*
   * Normally it is bad to mix media queries like this We are doing
   * this here specifically for animations to avoid weird jank.
   */
  /* Mobile animation is a bottom drawer */
  @media (max-width: 440px) {
    opacity: 1;
    transform: translate3d(0, 0, 0);
    transition: transform 200ms ease-in;
    position: fixed;
    bottom: 0;

    &.entering,
    &.leaving {
      opacity: 0;
      transform: translate3d(0, 100%, 0);
      transition:
        transform 150ms ease-in 0ms,
        opacity 0ms ease 150ms;
    }
  }

  /* Tablet/Desktop animation is a fade in */
  @media (min-width: 441px) {
    opacity: 1;
    transition: opacity 100ms ease-in;

    &.entering,
    &.leaving {
      opacity: 0;
      transition-delay: 5ms;
    }

    margin: auto;
    width: 360px;
    box-shadow: 0px 8px 36px rgba(55, 65, 81, 0.15);
    border-radius: var(--privy-border-radius-lg);
  }
`;C.styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
`;const Ye=()=>{let{ready:e}=a.usePrivyContext(),{currentScreen:r}=a.usePrivyModal(),[n,i]=t.useState(null),[s,o]=t.useState(!1),l=function(e){let[r,n]=t.useState(!1),i=t.useRef(null),a=t.useRef(null),s=t.useRef(null);return t.useEffect((()=>{if(i.current&&(clearTimeout(i.current),i.current=null),a.current&&(clearTimeout(a.current),a.current=null),e)s.current=Date.now(),i.current=setTimeout((()=>{n(!0)}),150);else if(null!==s.current){let e=Date.now()-s.current;if(e>=150){let t=Math.max(0,400-(e-150));a.current=setTimeout((()=>{n(!1),s.current=null}),t)}else i.current&&(clearTimeout(i.current),i.current=null),n(!1),s.current=null}return()=>{i.current&&clearTimeout(i.current),a.current&&clearTimeout(a.current)}}),[e]),r}(s);return t.useEffect((()=>{if(!r)return i(null),void o(!1);o(!0),Me[r]().then((t=>{(!r||e||t.default.isShownBeforeReady)&&(i((()=>t.default.component)),o(!1))})).catch((()=>{i(null),o(!1)}))}),[r,e]),{component:n,isLoading:l}};let Ge=/*#__PURE__*/t.lazy((()=>Promise.resolve().then((function(){return require("./MfaVerifyFlowScreen-D_7nkuBq.js")})))),$e=/*#__PURE__*/t.lazy((()=>(e=>Me[e]().then((e=>({default:e.default.component}))))("MfaAuthVerifyFlowScreen"))),Je=()=>/*#__PURE__*/e.jsx(rt,{children:/*#__PURE__*/e.jsx(o.Loader,{})}),Qe=()=>{let{currentScreen:r}=a.usePrivyModal(),n=De((e=>e.inProgressMfaFlow)),i=()=>De.setState({inProgressMfaFlow:void 0}),{component:s,isLoading:l}=Ye();return function(){let{isModalOpen:e}=a.usePrivyContext(),{headless:r}=p.useAppConfig(),{currentScreen:n}=a.usePrivyModal(),{status:i,execute:s,reset:o,enabled:l}=be(),[c,d]=t.useState(!1);t.useEffect((()=>{!e&&l&&o()}),[e,l,o]),t.useEffect((()=>{n?Me[n]().then((e=>{d(!!e.default.isCaptchaRequired)})).catch((()=>{d(!1)})):d(!1)}),[n]),t.useEffect((()=>{e&&c&&!r&&"ready"===i&&l&&s()}),[e,c,r,i,l,s])}(),r||"txn"!==n?l?/*#__PURE__*/e.jsx(Je,{}):s?
/*#__PURE__*/e.jsxs(e.Fragment,{children:[/*#__PURE__*/e.jsx(o.Hide,{$if:!!n,children:/*#__PURE__*/e.jsx(t.Suspense,{children:/*#__PURE__*/e.jsx(s,{})})}),/*#__PURE__*/e.jsxs(t.Suspense,{children:["txn"===n&&/*#__PURE__*/e.jsx(Ge,{onClose:i}),"auth"===n&&/*#__PURE__*/e.jsx($e,{})]})]}):null:/*#__PURE__*/e.jsx(t.Suspense,{children:/*#__PURE__*/e.jsx(Ge,{onClose:i})})},Ze=()=>{let r=t.useRef(null);/*#__PURE__*/return e.jsx(tt,{style:{height:o.useElementHeight(r)},id:"privy-modal-content",children:/*#__PURE__*/e.jsx("div",{ref:r,children:/*#__PURE__*/e.jsx(Qe,{})})})};const Xe=({open:r})=>{let n=p.useAppConfig(),{gracefulClosePrivyModal:i}=(()=>{let{closePrivyModal:e}=c.usePrivyInternal(),{onUserCloseViaDialogOrKeybindRef:r}=a.usePrivyModal();return{gracefulClosePrivyModal:t.useCallback((()=>{if(!r?.current)return e({shouldCallAuthOnSuccess:!1});r.current()}),[e])}})(),s=De((e=>e.inProgressMfaFlow));return Fe({onMfaRequired:()=>{n.mfa.noPromptOnMfaRequired||De.setState({inProgressMfaFlow:"txn"})}}),n.render.standalone?/*#__PURE__*/e.jsx(qe,{children:/*#__PURE__*/e.jsx(et,{id:"privy-modal-content",children:/*#__PURE__*/e.jsx(Qe,{})})}):/*#__PURE__*/e.jsx(ze,{open:!(!r&&!s),id:"privy-dialog","aria-label":"log in or sign up","aria-labelledby":"privy-dialog-title",onClick:()=>i(),children:/*#__PURE__*/e.jsx(qe,{children:/*#__PURE__*/e.jsx(Ze,{})})})};let et=C.styled.div`
  display: flex;
  flex-direction: column;
  text-align: center;
  font-size: 14px;
  line-height: 20px;
  width: 100%;
  background: var(--privy-color-background);
  padding: 0 16px;
`,tt=C.styled(et)`
  transition: height 150ms ease-out;
  overflow-x: hidden;
  overflow-y: auto;
  scrollbar-width: none;

  // Ensure the modal gets pinned to the top if it ever gets too tall
  max-height: calc(100svh - 32px);

  border-radius: var(--privy-border-radius-lg) var(--privy-border-radius-lg) 0 0;
  box-shadow: 0px 0px 36px rgba(55, 65, 81, 0.15);

  @media (min-width: 441px) {
    box-shadow: 0px 8px 36px rgba(55, 65, 81, 0.15);
    border-radius: var(--privy-border-radius-lg);
  }
`,rt=C.styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  padding: 2rem;
`;function nt(r){let n=t.useRef(null),i=t.useRef();return t.useEffect((()=>{i.current?.remove(),i.current=function({botUsername:e,scriptHost:t}){let r=document.createElement("script"),{origin:n}=new URL(t);return r.async=!0,r.src=`${n}/js/telegram-login.js`,r.setAttribute("data-telegram-login",e),r.setAttribute("data-request-access","write"),r.setAttribute("data-lang","en"),r}(r),n.current?.after(i.current)}),[r]),/*#__PURE__*/e.jsx("div",{ref:n,hidden:!0})}const it=()=>{let{ready:e}=l.useWallets(),{client:r}=c.usePrivyInternal();return t.useEffect((()=>{let t=()=>{if(!r.connectors||!e)return;let t=r.connectors.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt,id:e.meta.id})));d.u.put(p.CONNECTIONS_HISTORY_KEY,t)};return r.connectors?.on("walletsUpdated",t),()=>{r.connectors?.off("walletsUpdated",t)}}),[e,r.connectors]),null};class at extends o.EthereumWalletConnector{async initialize(){let e=await this.createProvider();this.provider=e,this.proxyProvider.setWalletProvider(e),this.subscribeListeners(),e.session&&(this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=o.getExternalWalletDataByUrl(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown"),this.connected=!0,await this.syncAccounts()),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),this.getConnectedWallet()}async isConnected(){return!!this.walletProvider?.connected}get walletBranding(){let e=this.walletProvider?.session?.peer.metadata.icons?.[0];return{name:o.stripEmoji(this.walletProvider?.session?.peer.metadata.name||"")||"WalletConnect",icon:"string"==typeof e?e:d.WALLET_CONNECT_LOGO_DATA_URI,id:this.walletProvider?.session?.peer.metadata.name.toLowerCase()||"wallet_connect_v2"}}async resetConnection(e){this.walletProvider&&this.walletProvider.connected&&(await this.walletProvider.disconnect(),this.walletProvider.signer.session=void 0,this.walletClientType=e,this.redirectUri=void 0,this.fallbackUniversalRedirectUri=void 0,f.deleteWalletConnectDeepLink(),this.onDisconnect())}async promptConnection(){if(this.provider)return new Promise(((e,t)=>{(async()=>{let t="",r=await Promise.race([this.walletProvider?.enable(),this.proxyProvider.walletTimeout()]);if(r?.length&&(t=r[0]),!t||""===t)throw new c.PrivyConnectorError("Unable to retrieve address");this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=o.getExternalWalletDataByUrl(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown",this.proxyProvider.rpcTimeoutDuration=o.getRpcTimeout(this.rpcConfig,this.walletClientType)),this.connected=!0,await this.syncAccounts(r),e()})().catch((e=>{t(e?d.formatConnectorError(e):new c.PrivyConnectorError("Unknown error during connection"))}))}))}disconnect(){this.walletProvider?.disconnect().then((()=>this.onDisconnect())).catch((()=>console.warn("Unable to disconnect WalletConnect provider")))}get walletProvider(){return this.proxyProvider.walletProvider}setWalletProvider(e){this.proxyProvider.setWalletProvider(e)}async createProvider(){let e={};for(let t of this.chains){let r=o.getJsonRpcEndpoint(t.id,this.chains,this.rpcConfig,this.privyAppId);r&&(e[t.id]=r)}let t=this.shouldEnforceDefaultChainOnConnect?[this.defaultChain.id]:[],r=this.chains.map((e=>e.id)),n=await k.EthereumProvider.init({projectId:this.walletConnectCloudProjectId,chains:t,optionalChains:r,optionalEvents:k.OPTIONAL_EVENTS,optionalMethods:k.OPTIONAL_METHODS,rpcMap:e,showQrModal:!1,metadata:{description:this.privyAppName,name:this.privyAppName,url:window.location.origin,icons:[]}});return n.on("display_uri",(e=>{if(n.signer.abortPairingAttempt(),f.removeWalletConnectDeepLink(),!this.showPrivyQrModal)throw new c.PrivyConnectorError("WalletConnect modal not available - Privy handles wallet connections through its own UI");if(w.isMobile&&this.walletEntry){let{redirect:t,href:r}=f.buildTargetUrl(e,this.walletEntry);f.openHref(t,"_self"),f.setWalletConnectDeepLink({href:r,name:this.walletEntry.metadata?.shortName||this.walletEntry.name});let n=f.buildUniversalFallbackUrl(e,this.walletEntry);return this.redirectUri=t,this.fallbackUniversalRedirectUri=n?.redirect,this.showPrivyQrModal({native:t,universal:t})}if(this.redirectUri=void 0,this.walletEntry){let t=f.buildUniversalFallbackUrl(e,this.walletEntry);this.fallbackUniversalRedirectUri=t?.redirect}this.showPrivyQrModal({native:e,universal:void 0})})),n.on("connect",(()=>{n.session?.peer.metadata.url&&(this.walletEntry=o.getExternalWalletDataByUrl(n.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown")})),n}async enableProvider(){return this.walletProvider?.connected?Promise.resolve(this.walletProvider.accounts):await(this.walletProvider?.enable())}setWalletEntry(e,t){this.walletEntry=e,this.showPrivyQrModal=t}constructor({walletConnectCloudProjectId:e,rpcConfig:t,chains:r,defaultChain:n,shouldEnforceDefaultChainOnConnect:i,privyAppId:a,privyAppName:s,walletClientType:l}){super(l||"unknown",r,n,t),this.connectorType="wallet_connect_v2",this.privyAppId=a,this.privyAppName=s,this.walletConnectCloudProjectId=e,this.rpcConfig=t,this.shouldEnforceDefaultChainOnConnect=i,this.proxyProvider=new o.PrivyProxyProvider(void 0,this.rpcTimeoutDuration),l&&(this.walletEntry=o.getExternalWalletData(l),this.walletClientType=l)}}const st=["error","invalid_request_arguments","wallet_not_on_device","invalid_recovery_pin","insufficient_funds","missing_or_invalid_mfa","mfa_verification_max_attempts_reached","mfa_timeout","twilio_verification_failed"];class ot extends Error{constructor(e,t){super(t),this.type=e}}function lt(e){let t=e.type;return"string"==typeof t&&st.includes(t)}function ct(e){return lt(e)&&"wallet_not_on_device"===e.type}async function dt(e,t,r,n,i,a=!1){let s=a,o=async o=>{if(s&&t&&t.length>0){o===(a?0:1)?i("configureMfa","onMfaRequired",{mfaMethods:t}):n.current?.reject(new ot("missing_or_invalid_mfa","MFA verification failed, retry."));let s=await new Promise(((e,t)=>{r.current={resolve:e,reject:t},setTimeout((()=>{let e=new ot("mfa_timeout","Timed out waiting for MFA code");n.current?.reject(e),t(e)}),3e5)}));return await e(s)}return await e()},l=null;for(let e=0;e<4;e++)try{l=await o(e),n.current?.resolve(void 0);break}catch(e){if("missing_or_invalid_mfa"!==e.type)throw n.current?.resolve(void 0),e;s=!0}if(null===l){let e=new ot("mfa_verification_max_attempts_reached","Max MFA verification attempts reached");throw n.current?.reject(e),e}return l}var ut;let ht=(ut=0,()=>"id-"+ut++);function pt(e){return void 0!==e.error}let yt=new class{enqueue(e,t){this.callbacks[e]=t}dequeue(e,t){let r=this.callbacks[t];if(!r)throw Error(`cannot dequeue ${e} event: no event found for id ${t}`);switch(delete this.callbacks[t],e){case"privy:iframe:ready":case"privy:user-signer:sign":case"privy:wallets:add":case"privy:wallets:import":case"privy:wallets:set-recovery":case"privy:wallets:connect":case"privy:wallets:recover":case"privy:wallets:rpc":case"privy:wallet:create":case"privy:mfa:verify":case"privy:mfa:init-enrollment":case"privy:mfa:submit-enrollment":case"privy:mfa:unenroll":case"privy:mfa:clear":case"privy:auth:unlink-passkey":case"privy:farcaster:init-signer":case"privy:farcaster:sign":case"privy:solana-wallet:create":case"privy:delegated-actions:consent":return r;default:throw Error(`invalid wallet event type ${e}`)}}constructor(){this.callbacks={}}},wt=new Map,mt=(e,t)=>"bigint"==typeof t?t.toString():t;function gt(e,t,r,n){let i=r.contentWindow;if(!i)throw Error("iframe not initialized");let a=((e,t)=>`${e}${JSON.stringify(t,mt)}`)(e,t);if("privy:wallet:create"===e){let e=wt.get(a);if(e)return e}let s=new Promise(((r,a)=>{let s=ht();yt.enqueue(s,{resolve:r,reject:a}),i.postMessage({id:s,event:e,data:t},n)})).finally((()=>{wt.delete(a)}));return wt.set(a,s),s}function vt(r){let n=p.useIsServerConfigLoaded(),i=t.useRef(null),a=t.useRef(r.mfaMethods),s=A.useEmitPrivyEvent(),[l,c]=t.useState(!1);return t.useEffect((()=>{a.current=r.mfaMethods}),[r.mfaMethods]),t.useEffect((()=>{if(!l)return;let e=i.current;if(!e)return;function t(e){var t;e&&e.origin===r.origin&&"string"==typeof(t=e.data).event&&/^privy:.+/.test(t.event)&&function(e){switch(e.event){case"privy:iframe:ready":let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data);case"privy:user-signer:sign":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:add":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:set-recovery":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:connect":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:recover":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:rpc":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallet:create":let r=yt.dequeue(e.event,e.id);return pt(e)?r.reject(new ot(e.error.type,e.error.message)):r.resolve(e.data);case"privy:wallets:import":let n=yt.dequeue(e.event,e.id);return pt(e)?n.reject(new ot(e.error.type,e.error.message)):n.resolve(e.data);case"privy:mfa:verify":let i=yt.dequeue(e.event,e.id);return pt(e)?i.reject(new ot(e.error.type,e.error.message)):i.resolve(e.data);case"privy:mfa:init-enrollment":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:submit-enrollment":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:unenroll":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:clear":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:auth:unlink-passkey":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:solana-wallet:create":let a=yt.dequeue(e.event,e.id);return pt(e)?a.reject(new ot(e.error.type,e.error.message)):a.resolve(e.data);case"privy:farcaster:init-signer":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:farcaster:sign":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:delegated-actions:consent":{let t=yt.dequeue(e.event,e.id);return pt(e)?t.reject(new ot(e.error.type,e.error.message)):t.resolve(e.data)}default:console.warn("Unsupported wallet proxy method:",e)}}(e.data)}let n={signWithUserSigner:t=>dt((n=>gt("privy:user-signer:sign",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),addWallet:t=>dt((n=>gt("privy:wallets:add",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),setRecovery:t=>dt((n=>gt("privy:wallets:set-recovery",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),connect:t=>dt((n=>gt("privy:wallets:connect",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),recover:t=>dt((n=>gt("privy:wallets:recover",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s,!t.recoveryAccessToken&&!t.recoveryPassword&&!t.recoverySecretOverride),rpc:t=>dt((n=>gt("privy:wallets:rpc",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),create:t=>gt("privy:wallet:create",t,e,r.origin),importWallet:t=>gt("privy:wallets:import",t,e,r.origin),createSolana:t=>dt((n=>gt("privy:solana-wallet:create",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),createDelegatedAction:t=>gt("privy:delegated-actions:consent",t,e,r.origin),verifyMfa:t=>dt((n=>gt("privy:mfa:verify",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s,!0),initEnrollMfa:t=>dt((n=>gt("privy:mfa:init-enrollment",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),submitEnrollMfa:t=>dt((n=>gt("privy:mfa:submit-enrollment",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),unenrollMfa:t=>dt((n=>gt("privy:mfa:unenroll",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),clearMfa:t=>gt("privy:mfa:clear",t,e,r.origin),unlinkPasskeyAccount:t=>dt((n=>gt("privy:auth:unlink-passkey",{...t,...n},e,r.origin)),a.current,r.mfaPromise,r.mfaSubmitPromise,s),initFarcasterSigner:t=>gt("privy:farcaster:init-signer",t,e,r.origin),signFarcasterMessage:t=>gt("privy:farcaster:sign",t,e,r.origin)};window.addEventListener("message",t);let c=new AbortController;return o.invokeUntilSettled((()=>gt("privy:iframe:ready",{},e,r.origin)),{abortSignal:c.signal}).then((()=>r.onLoad(n)),((...e)=>{console.warn("Privy iframe failed to load: ",...e),r.onLoadFailed()})),()=>{window.removeEventListener("message",t),c.abort()}}),[l]),n?
/*#__PURE__*/e.jsx("iframe",{ref:i,width:"0",height:"0",style:{display:"none",height:"0px",width:"0px"},onLoad:()=>c(!0),src:_.constructURL({origin:r.origin,path:`/apps/${r.appId}/embedded-wallets`,query:{caid:r.clientAnalyticsId,client_id:r.appClientId}})}):null}const ft=({address:e,user:t})=>{let r=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!r)throw new c.PrivyClientError("Address to delegate is not associated with current user.");if(!d.isFirstClassChainWallet(r))throw new c.PrivyClientError(`useDelegatedActions is not supported for ${r.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:r.address,chainType:r.chainType,walletIndex:r.walletIndex??0}},Et=({address:e,user:t})=>{let r=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!r)throw new c.PrivyClientError("Address to delegate is not associated with current user.");let n=r.imported?r:a.getPrivyPrimaryWallet(t);if(!n)throw new c.PrivyClientError("Unable to determine root address for delegated address.");if(!d.isFirstClassChainWallet(n))throw new c.PrivyClientError(`useDelegatedActions is not supported for ${n.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:n.address,chainType:n.chainType,imported:n.imported}},Ct=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.delegated));const At="popup-privy-oauth",Pt="PRIVY_OAUTH_USE_BROADCAST_CHANNEL";class Tt{async authenticate(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");try{return await this.api.post(v.oAuthAuthenticatePath,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw c.formatApiError(e)}}async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");try{return await this.api.post(v.oAuthLinkPath,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider})}catch(e){throw c.formatApiError(e)}}constructor(e){this.meta=e}}async function kt({api:e,requesterAppId:t,providerAppId:r}){let n=(await e.get(`/api/v1/apps/${t}/cross-app/connections`)).connections.find((e=>e.provider_app_id===r));if(!n)throw new c.PrivyClientError("Invalid connected app");return{name:n.provider_app_name,logoUrl:n.provider_app_icon_url||void 0,apiUrl:n.provider_app_custom_api_url,readOnly:n.read_only,customAuthAuthorizeUrl:n.provider_app_custom_auth_authorize_url,customAuthTransactUrl:n.provider_app_custom_auth_transact_url}}const _t=async({user:e,address:t,client:r,request:n,requesterAppId:i,reconnect:a})=>{r.createAnalyticsEvent({eventName:"cross_app_request_started",payload:{address:t,method:n.method}});let s=e?.linkedAccounts.find((e=>"cross_app"===e.type&&(e.embeddedWallets.some((e=>e.address===t))||e.smartWallets.some((e=>e.address===t)))));if(!e||!s)throw r.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Cannot request a signature with this wallet address",address:t}}),new c.PrivyClientError("Cannot request a signature with this wallet address");let o=r.getProviderAccessToken(s.providerApp.id),l=await kt({api:r.api,requesterAppId:i,providerAppId:s.providerApp.id});if(!o){if(l.readOnly)throw console.error("cannot transact against a read-only provider app"),new c.PrivyClientError("Cannot transact against a read-only provider app");await a({appId:s.providerApp.id,action:"link"})&&(o=r.getProviderAccessToken(s.providerApp.id))}if(!o)throw r.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Transactions require a valid token",address:t}}),new c.PrivyClientError("Transactions require a valid token");let d=new URL(l.customAuthTransactUrl||`${l.apiUrl}/oauth/transact`);d.searchParams.set("token",o||""),d.searchParams.set("request",St(n));let u=g.trigger({location:d.href});if(!u)throw r.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Missing token",address:t}}),new c.PrivyClientError("Failed to initialize signature request");return new Promise(((e,i)=>{let a=setTimeout((()=>{d(),i(new c.PrivyClientError("Request timeout")),r.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Request timeout",address:t}})}),12e4),o=setInterval((()=>{u.closed&&(d(),i(new c.PrivyClientError("User rejected request")),r.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"User rejected request",address:t}}))}),300),l=a=>{a.data&&("set"===a.data.token?.action&&void 0!==a.data.token?.value?r.storeProviderAccessToken(s.providerApp.id,a.data.token.value):"clear"===a.data.token?.action&&r.storeProviderAccessToken(s.providerApp.id,null),"PRIVY_CROSS_APP_ACTION_RESPONSE"===a.data.type&&a.data.result&&(d(),e(a.data.result),r.createAnalyticsEvent({eventName:"cross_app_request_success",payload:{address:t,method:n.method}})),"PRIVY_CROSS_APP_ACTION_ERROR"===a.data.type&&a.data.error&&(d(),i(a.data.error),r.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:a.data.error,address:t}})))};window.addEventListener("message",l);let d=()=>{u.close(),clearInterval(o),clearTimeout(a),window.removeEventListener("message",l)}}))};let St=e=>JSON.stringify({content:{request:{request:bt(e,S.toHex)}},timestamp:Date.now(),callbackUrl:window.origin});const bt=(e,t)=>"bigint"==typeof e?t(e):Array.isArray(e)?e.map((e=>bt(e,t))):e&&"object"==typeof e?Object.fromEntries(Object.entries(e).map((([e,r])=>[e,bt(r,t)]))):e;function It({isCreatingWallet:e,skipSplashScreen:t}){return e?"EmbeddedWalletPasswordCreateScreen":t?"EmbeddedWalletPasswordUpdateScreen":"EmbeddedWalletPasswordUpdateSplashScreen"}function Wt({walletAction:e,availableRecoveryMethods:t,legacySetWalletPasswordFlow:r,isResettingPassword:n,showAutomaticRecovery:i}){return i?"SetAutomaticRecoveryScreen":r||1===t.length?It({isCreatingWallet:"create"===e,skipSplashScreen:n}):"RecoverySelectionScreen"}function Ut(e){switch(e){case"user-passcode":return"PasswordRecoveryScreen";case"google-drive":case"icloud":return"RecoveryOAuthScreen";default:throw Error("Recovery method not supported")}}function xt(e,t){if(e.onComplete)switch(t){case"external":e.fundingResult?e.onComplete({...e.fundingResult,fundingMethod:t}):e.onComplete({status:"cancelled",address:e.address,fundingMethod:t,amount:e.amount});break;case null:e.onComplete({status:"cancelled",address:e.address,fundingMethod:void 0,amount:e.amount});break;default:e.onComplete({status:"completed",address:e.address,fundingMethod:t,amount:e.amount})}}const Rt=new Map([["FundingMethodSelectionScreen",null],["TransferFromWalletScreen","external"],["FundingAmountEditScreen","external"],["ConnectOnlyLandingScreen","external"],["ConnectOnlyStatusScreen","external"],["AwaitingExternalEthereumTransferScreen","external"],["AwaitingEvmToSolBridgingScreen","external"],["AwaitingSolToEvmBridgingScreen","external"],["ManualTransferScreen","manual"],["MoonpayStatusScreen","moonpay"]]);function Ot(e){let t=e.toLowerCase();return!!window?.webkit?.messageHandlers?.ReactNativeWebView||!!window?.ReactNativeWebView||["fbav","fban","instagram","snapchat","linkedinapp"].some((e=>t.includes(e)))}async function Nt({rpc:e,address:t}){return(await e.getBalance(t,{commitment:"confirmed"}).send()).value??0n}let Mt={apple_oauth:"apple",custom_auth:"custom",discord_oauth:"discord",email:"email",farcaster:"farcaster",github_oauth:"github",google_oauth:"google",instagram_oauth:"instagram",linkedin_oauth:"linkedin",passkey:"passkey",phone:"sms",spotify_oauth:"spotify",telegram:"telegram",tiktok_oauth:"tiktok",line_oauth:"line",twitch_oauth:"twitch",twitter_oauth:"twitter",wallet:"siwe",smart_wallet:"siwe",cross_app:"privy:"};const Ft=e=>{if(a.isCustomOAuthProvider(e))return{displayName:e.replace("custom:",""),loginMethod:"custom"};let t=Mt[e];return"wallet"===e||"phone"===e?{displayName:e,loginMethod:t}:{displayName:t,loginMethod:t}};async function Dt(e,t,r,n){let i=h.toViemTransactionSerializable(e),{chain:a,...s}=await(async()=>n?await n():await t.prepareTransactionRequest({...i,account:{address:r,type:"json-rpc"}}))();return{...s,type:h.STRING_TO_NUMBER_TXN_TYPE[s.type]}}const Lt=()=>{let e=p.useAppConfig(),{user:r}=a.usePrivyContext(),{client:n,refreshSessionAndUser:i,walletProxy:s}=c.usePrivyInternal();return{migrate:t.useCallback((async()=>{if("legacy-embedded-wallets-only"===e.embeddedWallets.mode)return{success:!0,migrated:!1};if(!r)throw new c.PrivyClientError("User must be authenticated before migrating wallets",c.PrivyErrorCode.MUST_BE_AUTHENTICATED);if(!s)throw new c.PrivyClientError("Cannot connect to wallet proxy");let t=await n.getAccessToken();if(!t)throw new c.PrivyClientError("User must be authenticated before migrating wallets",c.PrivyErrorCode.MUST_BE_AUTHENTICATED);let o=r.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&d.isFirstClassChainWallet(e)&&!a.getIsUnifiedWallet(e)));if(0===o.length)return{success:!0,migrated:!1};let u=o.filter((e=>e.imported)),h=o.filter((e=>!e.imported));if(h.length>0){let e=h.find((e=>"ethereum"===e.chainType&&0===e.walletIndex))??h.find((e=>"solana"===e.chainType&&0===e.walletIndex))??null;if(!e)throw new c.PrivyClientError("Primary wallet not found");let{entropyId:r,entropyIdVerifier:n}=l.toEntropyDetailsFromAccount(e);try{await s.connect({accessToken:t,entropyId:r,entropyIdVerifier:n})}catch(i){if(!ct(i)||"privy"!==e.recoveryMethod)throw i;await s.recover({accessToken:t,entropyId:r,entropyIdVerifier:n})}await s.createDelegatedAction({accessToken:t,rootWallet:{address:e.address,chainType:e.chainType,imported:!1},delegatedWallets:h.map((e=>({address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0})))})}for(let e of u){let{entropyId:r,entropyIdVerifier:n}=l.toEntropyDetailsFromAccount(e);try{await s.connect({accessToken:t,entropyId:r,entropyIdVerifier:n})}catch(u){if(!ct(u)||"privy"!==e.recoveryMethod)throw u;await s.recover({accessToken:t,entropyId:r,entropyIdVerifier:n})}await s.createDelegatedAction({accessToken:t,rootWallet:{address:e.address,chainType:e.chainType,imported:!0},delegatedWallets:[{address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0}]})}return await i(),{success:!0,migrated:!0}}),[e.embeddedWallets.mode,r,s,n,i])}},jt=({disabled:e})=>{let{migrate:r}=Lt(),{user:n}=a.usePrivyContext(),{walletProxy:i}=c.usePrivyInternal(),s=t.useRef(!1);return t.useEffect((()=>{!e&&!s.current&&n&&i&&(s.current=!0,r().catch((e=>{console.debug("Unable to migrate wallets: ",e)})).finally((()=>{s.current=!1})))}),[n,i,e,r]),null},qt=e=>({id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}),zt=P.create((()=>({ethereum:[]}))),Kt=()=>zt.getState().ethereum;class Ht{async authenticate(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");try{return await this.api.post(v.customJwtAccountAuthenticatePath,{token:this.meta.token})}catch(e){throw c.formatApiError(e)}}async link(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");try{return await this.api.post(v.customJwtAccountLinkPath,{token:this.meta.token})}catch(e){throw c.formatApiError(e)}}constructor(e){this.meta={token:e}}}const Vt=(e,t)=>!a.getPrivyEthereumWallet(e)&&("all-users"===t||"users-without-wallets"===t&&!Bt(e).length);let Bt=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"ethereum"===e.chainType));const Yt=(e,t)=>!a.getPrivySolanaWallet(e)&&("all-users"===t||"users-without-wallets"===t&&!Gt(e).length);let Gt=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"solana"===e.chainType));const $t=()=>{let{walletProxy:e,recoverEmbeddedWallet:t,setUser:r,refreshSessionAndUser:n,privy:i,client:a}=c.usePrivyInternal(),s=p.useAppConfig();return{create:async({walletIndex:o,chainType:l,latestUser:c,recoveryMethod:d,recoveryPassword:u,recoveryAccessToken:h,idempotencyKey:p})=>{let y=c;y||(y=await n());let w=await a.getAccessToken();if(!y||!w||!e)throw Error("User must be authenticated before creating a Privy wallet");return await f.createWalletAtIndex({appConfig:s,user:y,refreshSessionAndUser:n,privy:i,accessToken:w,proxy:e,recoverEmbeddedWallet:t,setUser:r,walletIndex:o,chainType:l,recoveryMethod:d,recoveryPassword:u,recoveryAccessToken:h,idempotencyKey:p})}}};function Jt({subscribe:e,getExternalJwt:r,enabled:n=!0,onAuthenticated:i,onUnauthenticated:a,onError:s}){let{client:o,setAuthenticated:l,setUser:d,setIsNewUser:u}=c.usePrivyInternal(),{logout:h,authenticated:y,ready:w}=f.usePrivy(),{create:m}=$t(),g=p.useAppConfig();if(!o)throw new c.PrivyClientError("`useSyncJwtBasedAuthState` must be used within a `PrivyProvider`");let[v,E]=t.useState({status:"initial"}),C=t.useRef(),A=t.useRef(!1),P=t.useRef(r);t.useEffect((()=>{P.current=r}),[r]);let T=t.useRef(i);t.useEffect((()=>{T.current=i}),[i]);let k=t.useRef(a);t.useEffect((()=>{k.current=a}),[a]);let _=t.useRef(s);t.useEffect((()=>{_.current=s}),[s]);let S=t.useRef(m);t.useEffect((()=>{S.current=m}),[m]);let b=t.useRef(g.embeddedWallets.ethereum.createOnLogin);t.useEffect((()=>{b.current=g.embeddedWallets.ethereum.createOnLogin}),[g.embeddedWallets.ethereum.createOnLogin]);let I=t.useRef(g.embeddedWallets.solana.createOnLogin);t.useEffect((()=>{I.current=g.embeddedWallets.solana.createOnLogin}),[g.embeddedWallets.solana.createOnLogin]);let W=t.useRef(d);t.useEffect((()=>{W.current=d}),[d]);let U=t.useRef(u);t.useEffect((()=>{U.current=u}),[u]);let x=t.useRef(l);return t.useEffect((()=>{x.current=l}),[l]),t.useEffect((()=>{if(!n||!w)return;let t=async()=>{if(!A.current){A.current=!0;try{E({status:"loading"});let e=await P.current();if(void 0!==C.current&&C.current===e)return void E({status:"done"});if(!e)return y&&(await h(),k.current?.()),C.current=e,void E({status:"done"});o.startAuthFlow(new Ht(e));let{user:t,isNewUser:r=!1}=await o.authenticate();if(!t)throw new c.PrivyClientError("Failed to sync with custom auth provider");T.current?.({user:t,isNewUser:r}),W.current(t),U.current(r),x.current(!0);let n=Vt(t,b.current),i=Yt(t,I.current);if(n&&i){let e=await S.current({chainType:"ethereum",walletIndex:0,latestUser:t});await S.current({chainType:"solana",walletIndex:0,latestUser:e.user})}else i?await S.current({chainType:"solana",walletIndex:0,latestUser:t}):n&&await S.current({chainType:"ethereum",walletIndex:0,latestUser:t});C.current=e,E({status:"done"})}catch(e){if(console.warn(e),await h().catch((()=>{})),k.current?.(),e instanceof c.PrivyApiError&&e.privyErrorCode===c.PrivyErrorCode.LINKED_TO_ANOTHER_USER)return E({status:"initial"}),void setTimeout((()=>{t()}),0);_.current?.(e),E({status:"error",error:e})}finally{A.current=!1}}};return t(),e(t)}),[e,o,y,h,n,w]),n?{state:v}:{state:{status:"not-enabled"}}}let Qt=P.create((()=>({jwtAuthFlowState:{status:"not-enabled"}})));function Zt({customAuth:e}){let{jwtAuthFlowState:r}=function({customAuth:e}){let r=A.useEmitPrivyEvent(),n=t.useRef(),i=t.useCallback((e=>(n.current=e,()=>{n.current=void 0})),[]),a=e?.getCustomAccessToken??(()=>Promise.resolve(void 0)),{state:s}=Jt({enabled:!0===e?.enabled,subscribe:i,getExternalJwt:a,onAuthenticated:({user:e,isNewUser:t})=>{r("login","onComplete",{user:e,isNewUser:t,wasAlreadyAuthenticated:!1,loginMethod:"custom",loginAccount:null}),r("customAuth","onAuthenticated",{user:e})},onUnauthenticated:()=>{r("customAuth","onUnauthenticated")},onError:e=>{r("login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR)}});return t.useEffect((()=>{(async()=>{e&&!e.isLoading&&n.current?.()})()}),[e?.enabled,e?.getCustomAccessToken,e?.isLoading]),{jwtAuthFlowState:s}}({customAuth:e});return t.useEffect((()=>{Qt.setState({jwtAuthFlowState:r})}),[r]),null}const Xt=/*#__PURE__*/t.createContext(!1);let er,tr,rr,nr,ir;const ar=n=>{let i=n.client,s=n.privy,u=f.usePlugins(),h=p.useAppConfig();o.useExternalWalletListings(o.shouldFetchWcRegistryListings(h?.appearance.walletList??[]));let[E,C]=t.useState(!1),P=De((e=>e.inProgressMfaFlow)),[T,k]=t.useState(!1),[_,S]=t.useState(null),I=zt((e=>e.ethereum)),[W,U]=t.useState(void 0),[x,R]=t.useState(!1),[O,N]=t.useState(null),[M,F]=t.useState(!1),[D,L]=t.useState({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:c.notImplemented}),[j,q]=t.useState({status:"initial"}),[z,K]=t.useState({status:"initial"}),[H,V]=t.useState({status:"initial"}),[B,Y]=t.useState({status:"initial"}),[G,$]=t.useState({status:"initial"}),[J,Q]=t.useState({status:"initial"}),[Z,X]=t.useState(null),ee=p.useIsServerConfigLoaded(),[re,ne]=t.useState({}),[se,le]=t.useState(null),ce=t.useRef(null),[he,ve]=t.useState(!1),ke=t.useRef(null),_e=t.useRef(null),be=t.useRef(A.privyEventsDefault),[Ie,Re]=t.useState(!1),[Oe,Fe]=t.useState(!1),je=t.useCallback((e=>{Fe(e),!e&&O&&Me[O]().then((e=>{e.default.isUnauthenticatedScreem&&N(null)}))}),[O]);i.onStoreCustomerAccessToken=e=>{e&&A.emitPrivyEvent(be,"accessToken","onAccessTokenGranted",{accessToken:e})},i.onDeleteCustomerAccessToken=()=>{S(null),je(!1),A.emitPrivyEvent(be,"accessToken","onAccessTokenRemoved")};let qe=t.useRef(null),ze=t.useRef(null),Ke=t.useRef(!1),He=({showWalletUIs:e})=>Ke.current?Ke.current:void 0!==e?!e:!h.embeddedWallets.showWalletUIs,Ve=e=>{N(e),setTimeout((()=>{C(!0)}),15)};t.useEffect((()=>{if(!_)return void i.connectors?.removeEmbeddedWalletConnectors();let e=a.getPrivyEthereumWallet(_),t=a.getPrivyEthereumHDWallets(_),r=a.getImportedPrivyEthereumWallets(_);e&&t.length||i.connectors?.removeEmbeddedWalletConnectors(),r.length||i.connectors?.removeImportedWalletConnectors(),i.connectors?Z?(e&&i.connectors.addEmbeddedWalletConnectors({walletProxy:Z,user:_,embeddedWallets:t,defaultChain:h.defaultChain,appId:n.appId,privyClient:s}),r.forEach((e=>i.connectors?.addImportedWalletConnector(Z,e.address,h.defaultChain,n.appId)))):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[Z,_]),t.useEffect((()=>{Z&&ce.current?.(Z)}),[Z]),t.useEffect((()=>{if(h.externalWallets.solana.connectors)return h.externalWallets.solana.connectors.onMount(),()=>h.externalWallets.solana.connectors?.onUnmount()}),[h.externalWallets.solana.connectors]),t.useEffect((()=>{!T&&ee&&async function(){let e,t=Be(),r=Ye(),n=y.createStore();i.initializeConnectorManager({walletConnectCloudProjectId:h.walletConnectCloudProjectId,rpcConfig:h.rpcConfig,chains:h.chains,defaultChain:h.defaultChain,store:n,walletList:h.appearance.walletList,shouldEnforceDefaultChainOnConnect:h.shouldEnforceDefaultChainOnConnect,externalWalletConfig:h.externalWallets,appName:h.name??"Privy",walletChainType:h.appearance.walletChainType,setBaseAccountSdk:U}),i.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=i.connectors.walletConnectors.length,r=i.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);r===t?Re(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:r,expected:t}),Re(!0)}),1500)})),i.connectors?.initialize().then((()=>{Ze()}));let a=await i.getAuthenticatedUser(),s=!!a;h.legal.requireUsersAcceptTerms&&a&&!a.hasAcceptedTerms?(await i.logout(),wt.setReadyToTrue(!0),A.emitPrivyEvent(be,"logout","onSuccess")):(h.customAuth?.enabled||(je(!!a),a&&A.emitPrivyEvent(be,"login","onComplete",{user:a,isNewUser:!1,wasAlreadyAuthenticated:!0,loginMethod:null,loginAccount:null}),S(a)),t?ze.current=s?"link":"login":r&&!s?(ze.current="login",ne({telegramAuthModalData:{seamlessAuth:!0}}),Ve("TelegramAuthScreen")):wt.setReadyToTrue(!!a))}()}),[i,se,T,ee]),t.useEffect((()=>{if(T){if(!_||!_.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void ve(!!Z);if([...I].some((e=>"privy"===e.walletClientType)))return void ve(!0);ve(!!Z)}}),[T,_,I,Z]),t.useEffect((()=>{i.connectors?.setWalletList(h.appearance.walletList)}),[h.appearance.walletList.join()]);let Be=()=>{let e=ge();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&e.provider.startsWith("privy:")&&!e.popupFlow&&(new BroadcastChannel(At).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(i.startAuthFlow(new me({...e,customOAuthRedirectUrl:h.customOAuthRedirectUrl})),Ve("OAuthStatusScreen"),!0))},Ye=()=>{let e=function(){let e;return(e=function(){let e=new URLSearchParams(window.location.search),t=Number(e.get("id")||""),r=e.get("hash"),n=Number(e.get("auth_date")||""),i=e.get("first_name");if(t&&i&&n&&r)return Object.fromEntries(e.entries())}())?(xe(),{flowType:"login-url",authData:e}):(e=function(){let e=window.location.hash;if(!e||!e.startsWith("#tgWebAppData"))return;let t=Ue(e.replace("#tgWebAppData=","")),{user:r,auth_date:n,hash:i}=t;return r&&n&&i?t:void 0}())?(xe(),{flowType:"web-app",authData:e}):void 0}();if(!e||!h.loginMethods.telegram||!h.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new We;return i.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},Ge=async(e,t,r,n)=>{if("solana_adapter"!==e)$e(await(i.connectors?.createEthereumWalletConnector({connectorType:e,walletClientType:t}))||null,t,r,n);else{let e=i.connectors?.findSolanaWalletConnector(t);if(!e)return;$e(e,t,r,n)}};async function $e(e,t,r,n){if(!e)return L({status:"disconnected",connectedWallet:null,connectError:new c.PrivyConnectorError("Unable to connect to wallet."),connector:null,connectRetry:c.notImplemented}),n?.(null,r);L({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:c.notImplemented}),e instanceof at&&t&&await e.resetConnection(t),L({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>$e(e,t,r,n)});try{let t=await e.connect({showPrompt:!0});if((!t||o.isBaseConnectedEthereumWallet(t))&&h.shouldEnforceDefaultChainOnConnect&&!h.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){L((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:c.notImplemented})));try{await(t?.switchChain(h.defaultChain.id)),t&&(t.chainId=o.formatChainIdToCAIP2(m.toHex(h.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${h.defaultChain.id}`)}}return L((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:c.notImplemented}))),t&&A.emitPrivyEvent(be,"connectWallet","onSuccess",{wallet:t}),n?.(t,r)}catch(e){return e instanceof c.PrivyError?(console.warn(e.cause?e.cause:e.message),A.emitPrivyEvent(be,"connectWallet","onError",e.privyErrorCode||c.PrivyErrorCode.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),A.emitPrivyEvent(be,"connectWallet","onError",c.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR)),L((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),n?.(null,r)}}let Je=async(e,t,r)=>{if(null===e||!o.isBaseConnectedEthereumWallet(e))return;let n=new Ce(i,e,t,r);i.startAuthFlow(n)},Qe=async(e,t,r,n="plain")=>{let a=u(f.SOLANA_LEDGER_PLUGIN_ID);if("transaction"===n&&!a)throw new c.PrivyClientError("useSolanaLedger plugin hook must be mounted");if(null===e||!o.isBaseConnectedSolanaWallet(e))return;let s=new Ae(e,i,t,r,n,a);i.startAuthFlow(s)},Ze=async()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),r=e.get("privy_wallet_client"),n="true"===e.get("privy_connect_only");if(!t||!r)return;let a=o.getWalletConfigForConnector({connectorType:t,walletClientType:r});if(!a||!a.isInstalled)return Ve("LoginFailedScreen");if(!i.connectors)throw new c.PrivyClientError("Connector not initialized");await Ve(n?"ConnectOnlyStatusScreen":"ConnectionStatusScreen");let s=new URL(window.location.href);s.searchParams.delete("privy_connector"),s.searchParams.delete("privy_wallet_client"),s.searchParams.delete("privy_connect_only"),window.history.pushState({},"",s),Ge(t,r,void 0,n?void 0:"solana_adapter"===t?Qe:Je)};t.useEffect((()=>{T&&Oe&&null===_&&i.getAuthenticatedUser().then(S)}),[T,Oe,_,i]);let et=e=>{if(!Oe)throw A.emitPrivyEvent(be,"linkAccount","onError",c.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:e}),new c.PrivyClientError("User must be authenticated before linking an account.")},tt=e=>{if(!Oe||!_)return!1;if("privy"===e.walletClientType)return!0;for(let t of _.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},rt=()=>{zt.setState((e=>{let t=i.connectors?.wallets.filter(o.isBaseConnectedEthereumWallet).map((e=>({...e,linked:tt(e),loginOrLink:async()=>{if(!await e.isConnected())throw new c.PrivyClientError("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new c.PrivyClientError("Cannot link or login with embedded wallet");(async e=>{let t;if(!i.connectors)throw new c.PrivyClientError("Connector not initialized");t="ethereum"===e.type?i.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:i.connectors.findSolanaWalletConnector(e.walletClientType)||null,L((r=>({...r,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:c.notImplemented}))),h.captcha.enabledProvider&&!Oe?(ne({captchaModalData:{callback:t=>o.isBaseConnectedEthereumWallet(e)?Je(e,t):Qe(e,t),userIntentRequired:!1,onSuccessNavigateTo:"ConnectionStatusScreen",onErrorNavigateTo:"ErrorScreen"}}),await Ve("CaptchaScreen")):(o.isBaseConnectedEthereumWallet(e)?await Je(e):await Qe(e),await Ve("ConnectionStatusScreen"))})(e)},fund:async t=>{await wt.fundWallet(e.address,t)},unlink:async()=>{if(!Oe)throw new c.PrivyClientError("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new c.PrivyClientError("Cannot unlink an embedded wallet");S(await i.unlinkEthereumWallet(e.address))}})))||[];return o.areWalletArraysEqual(e.ethereum,t)?{}:{ethereum:t}}))};t.useEffect((()=>{rt()}),[_?.linkedAccounts,Oe,T]),t.useEffect((()=>{if(T){if(!i.connectors)throw new c.PrivyClientError("Connector not initialized");rt(),i.connectors.on("walletsUpdated",rt)}}),[T]),t.useEffect((()=>{[...h.loginMethodsAndOrder?.primary??[],...h.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>i.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!i]);let st=({transaction:e,sponsor:t,uiOptions:u,fundWalletConfig:p,address:y,signOnly:w})=>new Promise((async(g,v)=>{let{requesterAppId:f}=u||{},E=w?"signTransaction":"sendTransaction",C=y?a.getPrivyWalletWithAddress(_,y):a.getPrivyEthereumWallet(_);if(!C&&y){let r=a.getConnectedWalletWithAddress(Kt(),y);if(r){if(t)throw new c.PrivyClientError("Cannot sponsor transactions for externally connected wallet.");try{let t=await r.getEthereumProvider(),n={...e,from:y,chainId:e.chainId||Number(r.chainId.replace("eip155:","")),value:void 0!==e.value?m.toHex(e.value):void 0},i=await t.request({method:"sendTransaction"===E?"eth_sendTransaction":"eth_signTransaction",params:[n]});return A.emitPrivyEvent(be,E,"onSuccess",{hash:i}),void g({hash:i})}catch(e){return A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.TRANSACTION_FAILURE),void v(e??new d.PrivyProviderRpcError("Unable to "+E+e))}}}if(!C)return A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void v(new c.PrivyClientError("No embedded or connected wallet found for address."));if(!Oe||!_)return A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.MUST_BE_AUTHENTICATED),void v(Error("User must be authenticated before signing with a Privy wallet"));let P=C.address,T=C.walletIndex??0,{entropyId:k,entropyIdVerifier:S}=l.getEntropyDetailsForUser(_,C),I=mt.wallets.find((e=>"privy"===e.walletClientType&&m.getAddress(e.address)===m.getAddress(P)));if(!I)return A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void v(Error("Must have a Privy wallet before signing"));let W=await I.getEthereumProvider(),U=await W.request({method:"eth_chainId"}),x=e.chainId?Number(e.chainId):d.extractChainIdFromCAIP2(U);(e=>{if(!h.chains.map((e=>e.id)).includes(e))throw new c.PrivyConnectorError(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,c.PrivyErrorCode.UNSUPPORTED_CHAIN_ID)})(x);let R={...e,from:e.from??P,chainId:x},O=await te();if(!O||!Z)return A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),void v(Error("Must have valid access token and Privy wallet to send transaction"));let N=b.getPublicClient(R.chainId,h.chains,h.rpcConfig,{appId:n.appId}),M=a.getIsUnifiedWallet(C),F=async({transactionRequest:e})=>{try{let n;if(!await wt.recoverEmbeddedWallet({address:P}))throw A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),v(Error("Unable to connect to wallet")),Error("Unable to connect to wallet");if(t){let t=await(async({transactionRequest:e})=>{if(!M)throw new c.PrivyClientError("Sponsoring is only supported for wallets on the TEE stack");if(w)throw new c.PrivyClientError("Cannot sponsor a sign transaction request");let t=e=>null==e?void 0:m.toHex(e),n=await r.rpc(s,(async({message:e})=>await Z.signWithUserSigner({accessToken:O,requesterAppId:f,message:e})),{chain_type:"ethereum",method:"eth_sendTransaction",caip2:o.formatChainIdToCAIP2(m.toHex(e.chainId)),sponsor:!0,params:{transaction:{from:e.from,to:e.to,chain_id:t(e.chainId),data:m.isHex(e.data)?e.data?e.data:m.toHex(Uint8Array.from(e.data)):void 0,value:t(e.value)}},wallet_id:C.id});if(n.data&&"hash"in n.data)return n.data.hash;throw new d.PrivyProviderRpcError("Unable to sign transaction")})({transactionRequest:e});return A.emitPrivyEvent(be,"sendTransaction","onSuccess",{hash:t}),t}if(M){let t=e=>null==e?void 0:m.toHex(e),i=await r.rpc(s,(async({message:e})=>await Z.signWithUserSigner({accessToken:O,requesterAppId:f,message:e})),{chain_type:"ethereum",method:"eth_signTransaction",params:{transaction:{from:e.from,to:e.to,nonce:t(e.nonce),chain_id:t(e.chainId),data:m.isHex(e.data)?e.data?e.data:m.toHex(Uint8Array.from(e.data)):void 0,value:t(e.value),type:e.type,gas_limit:t(e.gasLimit??e.gas),gas_price:t(e.gasPrice??e.gas),max_fee_per_gas:t(e.maxFeePerGas),max_priority_fee_per_gas:t(e.maxPriorityFeePerGas)}},wallet_id:C.id});if(!i.data||!("signed_transaction"in i.data))throw new d.PrivyProviderRpcError("Unable to sign transaction");n=i.data.signed_transaction}else n=await async function({accessToken:e,entropyId:t,entropyIdVerifier:r,transactingWalletIndex:n,walletProxy:i,transactionRequest:a,requesterAppId:s}){return(await i.rpc({entropyId:t,entropyIdVerifier:r,hdWalletIndex:n??0,chainType:"ethereum",accessToken:e,requesterAppId:s,request:{method:"eth_signTransaction",params:[a]}})).response.data}({accessToken:O,entropyId:k,entropyIdVerifier:S,transactingWalletIndex:T,walletProxy:Z,transactionRequest:e,requesterAppId:f});if(w)return A.emitPrivyEvent(be,"signTransaction","onSuccess",{signature:n}),n;{let e=await N.sendRawTransaction({serializedTransaction:n});return A.emitPrivyEvent(be,"sendTransaction","onSuccess",{hash:e}),e}}catch(e){throw A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.TRANSACTION_FAILURE),e}};if(He({showWalletUIs:u?.showWalletUIs})){let e=w||t?R:await Dt(R,N,R.from);try{let t=await F({transactionRequest:e});w?A.emitPrivyEvent(be,"signTransaction","onSuccess",{signature:t}):A.emitPrivyEvent(be,"sendTransaction","onSuccess",{hash:t}),g({hash:t})}catch(e){A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.TRANSACTION_FAILURE),v(e)}}else{let e={connectingWalletAddress:P,recoveryMethod:C.recoveryMethod,entropyId:k,entropyIdVerifier:S,onCompleteNavigateTo:"SendTransactionScreen",isUnifiedWallet:M,onFailure:e=>{A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),v(e)}},r=(e=>!!e.fundingConfig&&d.filterSupportedOptions(e.fundingConfig.options).length>=1)(h)?d.prepareFundingModalData({address:P,appConfig:h,fundWalletConfig:p,methodScreen:"FundingMethodSelectionScreen",chainIdOverride:R.chainId,comingFromSendTransactionScreen:!0}):void 0;ne({connectWallet:e,sendTransaction:{transactionRequest:R,transactingWalletIndex:T,transactingWalletAddress:P,entropyId:k,entropyIdVerifier:S,signOnly:w,scanTransaction:async()=>{let e=await Dt(R,N,R.from);return await i.scanTransaction({metadata:{domain:h.embeddedWallets.transactionScanning.domain},chain_id:e.chainId.toString(),request:{method:"eth_sendTransaction",params:[{from:e.from,to:e.to,value:e.value?.toString(),gas:e.gas?.toString(),gasPrice:e.gasPrice?.toString(),nonce:e.nonce?.toString(),data:e.data}]}})},getIsSponsored:async()=>!!t,onConfirm:({transactionRequest:e})=>F({transactionRequest:e}),onSuccess:e=>{w?A.emitPrivyEvent(be,"signTransaction","onSuccess",{signature:e.hash}):A.emitPrivyEvent(be,"sendTransaction","onSuccess",{hash:e.hash}),g(e)},onFailure:e=>{A.emitPrivyEvent(be,E,"onError",c.PrivyErrorCode.TRANSACTION_FAILURE),v(e)},uiOptions:u||{},fundWalletConfig:p,requesterAppId:f},funding:r}),Ve("EmbeddedWalletConnectingScreen")}}));function ot(){return new Promise((async(e,t)=>{let r=await te();if(!r||!Z)throw Error("Must have valid access token to enroll in MFA");try{await Z.verifyMfa({accessToken:r}),e()}catch(e){t(e)}}))}let lt=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],dt=e=>{let t=_?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:r,loginMethod:n}=Ft(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw A.emitPrivyEvent(be,"linkAccount","onError",c.PrivyErrorCode.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:n}),new c.PrivyClientError(`User already has an account of type ${r} linked.`)};async function ut({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){N(null);let r=t?"setWalletPassword":"setWalletRecovery";if(!Oe||!_)throw A.emitPrivyEvent(be,r,"onError",c.PrivyErrorCode.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let n=a.getPrivyPrimaryWallet(_);if(!n||!Z)throw A.emitPrivyEvent(be,r,"onError",c.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");let i=a.getIsUnifiedWallet(n);if(i)throw A.emitPrivyEvent(be,r,"onError",c.PrivyErrorCode.UNSUPPORTED_WALLET_TYPE),new c.PrivyClientError("User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");try{await ot()}catch(e){throw A.emitPrivyEvent(be,r,"onError",c.PrivyErrorCode.MISSING_MFA_CREDENTIALS),e}return new Promise(((a,s)=>{let o="user-passcode"===n.recoveryMethod,d=Wt({walletAction:"update",availableRecoveryMethods:h.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:o,showAutomaticRecovery:e}),{entropyId:u,entropyIdVerifier:p}=l.getEntropyDetailsForUser(_),y={recoveryMethod:n.recoveryMethod,connectingWalletAddress:n.address,onCompleteNavigateTo:d,shouldForceMFA:!1,entropyId:u,isUnifiedWallet:i,entropyIdVerifier:p,onFailure:e=>{A.emitPrivyEvent(be,r,"onError",c.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}};ne({setWalletPassword:{onSuccess:e=>{A.emitPrivyEvent(be,r,"onSuccess",{method:"user-passcode",wallet:e}),a(e)},onFailure:e=>{A.emitPrivyEvent(be,r,"onError",c.PrivyErrorCode.USER_EXITED_SET_PASSWORD_FLOW),s(e)},callAuthOnSuccessOnClose:!1},recoverWallet:{entropyId:u,entropyIdVerifier:p,onFailure:s},connectWallet:y,recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:o,shouldCreateEth:!1,shouldCreateSol:!1}}),Ve("EmbeddedWalletConnectingScreen")}))}async function ht({appId:e,action:t,disableSignup:r}){let n=await te();if("link"===t&&!n)throw A.emitPrivyEvent(be,"linkAccount","onError",c.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new c.PrivyClientError("User must be authenticated before linking an account.");if("login"===t&&n)throw A.emitPrivyEvent(be,"login","onError",c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),new c.PrivyClientError("Attempted to log in, but user is already logged in. Use a `link` helper instead.");qe.current=`privy:${e}`,ze.current=t;let a=g.trigger();return i.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(n,s)=>{let{name:o,logoUrl:l}=await kt({api:i.api,providerAppId:e,requesterAppId:h.id});ne({crossAppAuth:{appId:e,name:o,logoUrl:l,action:t,popup:a,disableSignup:r,onSuccess:n,onError:s}}),Ve("CrossAppAuthScreen")}))}let pt={ready:T,authenticated:Oe,user:_,walletConnectors:i.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),ne({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,walletChainType:e?.walletChainType,description:e?.description,hideHeader:e?.hideHeader}}),Ve("ConnectOnlyLandingScreen")},linkWallet:e=>(e&&"target"in e&&e&&(e=void 0),et("siwe"),qe.current="siwe",ze.current="link",ne({...re,externalConnectWallet:{...re.externalConnectWallet,walletList:e?.walletList,walletChainType:e?.walletChainType,description:e?.description||`Link a wallet to your ${h?.name} account`}}),Ve("AuthenticateWithWalletScreen")),startCrossAppAuthFlow:ht,linkEmail:()=>{et("email"),dt("email"),qe.current="email",ze.current="link",Ve("LinkEmailScreen")},linkPhone:()=>{et("sms"),dt("phone"),qe.current="sms",ze.current="link",Ve("LinkPhoneScreen")},linkGoogle:async()=>{et("google"),dt("google_oauth"),ze.current="link",await wt.initLoginWithOAuth("google")},linkTwitter:async()=>{et("twitter"),dt("twitter_oauth"),ze.current="link",await wt.initLoginWithOAuth("twitter")},linkTwitch:async()=>{et("twitch"),dt("twitch_oauth"),ze.current="link",await wt.initLoginWithOAuth("twitch")},linkDiscord:async()=>{et("discord"),dt("discord_oauth"),ze.current="link",await wt.initLoginWithOAuth("discord")},linkGithub:async()=>{et("github"),dt("github_oauth"),ze.current="link",await wt.initLoginWithOAuth("github")},linkSpotify:async()=>{et("spotify"),dt("spotify_oauth"),ze.current="link",await wt.initLoginWithOAuth("spotify")},linkInstagram:async()=>{et("instagram"),dt("instagram_oauth"),ze.current="link",await wt.initLoginWithOAuth("instagram")},linkTiktok:async()=>{et("tiktok"),dt("tiktok_oauth"),ze.current="link",await wt.initLoginWithOAuth("tiktok")},linkLine:async()=>{et("line"),dt("line_oauth"),ze.current="link",await wt.initLoginWithOAuth("line")},linkLinkedIn:async()=>{et("linkedin"),dt("linkedin_oauth"),ze.current="link",await wt.initLoginWithOAuth("linkedin")},linkApple:async()=>{et("apple"),dt("apple_oauth"),ze.current="link",await wt.initLoginWithOAuth("apple")},linkPasskey:async()=>{et("passkey"),dt("passkey"),await wt.initLinkWithPasskey(),Ve("LinkPasskeyScreen")},linkTelegram:async e=>{if(et("telegram"),dt("telegram"),ze.current="link",qe.current="telegram",e?.launchParams)if(e.launchParams.initDataRaw){let t=new We;i.startAuthFlow(t),t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=Ue(e.launchParams.initDataRaw),ne({telegramAuthModalData:{seamlessAuth:!0}}),Ve("TelegramAuthScreen")}else A.emitPrivyEvent(be,"linkAccount","onError",c.PrivyErrorCode.INVALID_DATA,{linkMethod:"telegram"});else await wt.initLoginWithTelegram();Ve("TelegramAuthScreen")},linkFarcaster:async()=>{et("farcaster"),dt("farcaster"),await wt.initLoginWithFarcaster(),ze.current="link",qe.current="farcaster",Ve("FarcasterConnectStatusScreen")},updateEmail:()=>{if(et("email"),!_?.email)throw new c.PrivyClientError("User does not have an email linked to their account.");ze.current="update",qe.current="email",Ve("UpdateEmailScreen")},updatePhone:()=>{if(et("sms"),!_?.phone)throw new c.PrivyClientError("User does not have a phone number linked to their account.");ze.current="update",qe.current="sms",Ve("UpdatePhoneScreen")},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!T){let e=await new Promise((e=>{le((t=>e.bind(t)))}));if(le(null),e)return void console.warn(t)}!_||_.isGuest?(ze.current="login",ne({login:e}),Ve("LandingScreen")):console.warn(t)},connectOrCreateWallet:async()=>{T||(await new Promise((e=>{le((()=>e))})),le(null)),Oe?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(ze.current="connect-or-create",Ve("ConnectOrCreateScreen"))},logout:async()=>{if(ze.current=null,qe.current=null,_&&i.clearProviderAcccessTokens(_),N(null),await i.logout(),_&&Z)try{await Z.clearMfa({userId:_.id})}catch(e){}S(null),je(!1),K({status:"initial"}),V({status:"initial"}),q({status:"initial"}),Y({status:"initial"}),$({status:"initial"}),Q({status:"initial"}),A.emitPrivyEvent(be,"logout","onSuccess"),C(!1),d.u.del(p.CLIENT_ANALYTICS_ID_KEY),d.u.del(p.getGuestCredentialStorageKey(h.id))},getAccessToken:t.useCallback((async()=>{let e=await i.getCustomerAccessToken();return e&&!Oe&&je(!0),e}),[i,Oe]),unlinkWallet:async e=>{let t;return S(t=e.startsWith("0x")?await i.unlinkEthereumWallet(e):await i.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await i.unlinkEmail(e);return S(t),t},unlinkPhone:async e=>{let t=await i.unlinkPhone(e);return S(t),t},unlinkGoogle:async e=>{let t=await i.unlinkOAuth("google",e);return S(t),t},unlinkTwitter:async e=>{let t=await i.unlinkOAuth("twitter",e);return S(t),t},unlinkTwitch:async e=>{let t=await i.unlinkOAuth("twitch",e);return S(t),t},unlinkDiscord:async e=>{let t=await i.unlinkOAuth("discord",e);return S(t),t},unlinkGithub:async e=>{let t=await i.unlinkOAuth("github",e);return S(t),t},unlinkSpotify:async e=>{let t=await i.unlinkOAuth("spotify",e);return S(t),t},unlinkInstagram:async e=>{let t=await i.unlinkOAuth("instagram",e);return S(t),t},unlinkTiktok:async e=>{let t=await i.unlinkOAuth("tiktok",e);return S(t),t},unlinkLine:async e=>{let t=await i.unlinkOAuth("line",e);return S(t),t},unlinkLinkedIn:async e=>{let t=await i.unlinkOAuth("linkedin",e);return S(t),t},unlinkApple:async e=>{let t=await i.unlinkOAuth("apple",e);return S(t),t},unlinkFarcaster:async e=>{let t=await i.unlinkFarcaster(e);return S(t),t},unlinkTelegram:async e=>{let t=await i.unlinkTelegram(e);return S(t),t},unlinkPasskey:async e=>{let t=await te();if(!t)throw Error("Must have valid access token to enroll in MFA");if(!Z)throw Error("Wallet proxy not initialized.");let r=h.passkeys.shouldUnenrollMfaOnUnlink;await Z.unlinkPasskeyAccount({credentialId:e,accessToken:t,removeAsMfa:r});let n=await i.getAuthenticatedUser();return S(n),n},unlinkCrossAppAccount:async({subject:e})=>{let t=_?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new c.PrivyClientError("Invalid subject");i.storeProviderAccessToken(t.id,null);let r=await i.unlinkOAuth(`privy:${t.id}`,e);return S(r),r},setWalletRecovery:async e=>ut({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>ut({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t)=>new Promise((async(n,o)=>{let{requesterAppId:u}=t?.uiOptions||{},h=e.message,p=t?.address?a.getPrivyWalletWithAddress(_,t.address):a.getPrivyEthereumWallet(_);if(!p&&void 0!==t?.address){let e=a.getConnectedWalletWithAddress(Kt(),t.address);if(e)try{let t=await e.getEthereumProvider(),r=await t.request({method:"personal_sign",params:[h,e.address]});return A.emitPrivyEvent(be,"signMessage","onSuccess",{signature:r}),void n({signature:r})}catch(e){return A.emitPrivyEvent(be,"signMessage","onError",c.PrivyErrorCode.UNABLE_TO_SIGN),void o(e??new d.PrivyProviderRpcError("Unable to sign message"))}}if(!p)throw new c.PrivyClientError("No embedded or connected wallet found for address.");if(!Oe||!_)return A.emitPrivyEvent(be,"signMessage","onError",c.PrivyErrorCode.MUST_BE_AUTHENTICATED),void o(Error("User must be authenticated before signing with a Privy wallet"));let y=p.address,w=p.walletIndex??0,{entropyId:g,entropyIdVerifier:v}=l.getEntropyDetailsForUser(_,p),f=a.getIsUnifiedWallet(p);if("string"!=typeof h||h.length<1)return A.emitPrivyEvent(be,"signMessage","onError",c.PrivyErrorCode.INVALID_MESSAGE),void o(Error("Message must be a non-empty string"));let E=async()=>{let t;if(!Oe)throw Error("User must be authenticated before signing with a Privy wallet");let n=await te();if(!Z||!n||!await wt.recoverEmbeddedWallet({address:y}))throw Error("Unable to connect to wallet");if(i.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:y,requesterAppId:u}}),f){let i=m.isHex(e.message,{strict:!0}),a=await r.rpc(s,(async({message:e})=>await Z.signWithUserSigner({accessToken:n,requesterAppId:u,message:e})),{chain_type:"ethereum",method:"personal_sign",params:i?{message:h.slice(2),encoding:"hex"}:{message:h,encoding:"utf-8"},wallet_id:p.id});if(!a.data||!("signature"in a.data))throw new d.PrivyProviderRpcError("Unable to sign message");t=a.data.signature}else{let{response:e}=await Z.rpc({accessToken:n,entropyId:g,entropyIdVerifier:v,chainType:"ethereum",hdWalletIndex:w,requesterAppId:u,request:{method:"personal_sign",params:[h,y]}});t=e.data}return i.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:y,requesterAppId:u}}),t};if(He({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await E();A.emitPrivyEvent(be,"signMessage","onSuccess",{signature:e}),n({signature:e})}catch(e){A.emitPrivyEvent(be,"signMessage","onError",c.PrivyErrorCode.UNABLE_TO_SIGN),o(e??new d.PrivyProviderRpcError("Unable to sign message"))}else ne({signMessage:{method:"personal_sign",data:h,confirmAndSign:E,onSuccess:e=>{A.emitPrivyEvent(be,"signMessage","onSuccess",{signature:e}),n({signature:e})},onFailure:e=>{A.emitPrivyEvent(be,"signMessage","onError",c.PrivyErrorCode.UNABLE_TO_SIGN),o(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:p.recoveryMethod,connectingWalletAddress:y,entropyId:g,entropyIdVerifier:v,onCompleteNavigateTo:"SignRequestScreen",isUnifiedWallet:f,onFailure:e=>{A.emitPrivyEvent(be,"signMessage","onError",c.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),o(e)}}}),Ve("EmbeddedWalletConnectingScreen")})),signTypedData:(e,t)=>new Promise((async(n,u)=>{let{requesterAppId:h}=t?.uiOptions||{},p=t?.address?a.getPrivyWalletWithAddress(_,t.address):a.getPrivyEthereumWallet(_);if(!p&&t?.address){let r=a.getConnectedWalletWithAddress(Kt(),t.address);if(r)try{let t=await r.getEthereumProvider(),i=o.generateTypedDataWithDomainType(e),a=await t.request({method:"eth_signTypedData_v4",params:[r.address,i]});return A.emitPrivyEvent(be,"signTypedData","onSuccess",{signature:a}),void n({signature:a})}catch(e){return A.emitPrivyEvent(be,"signTypedData","onError",c.PrivyErrorCode.UNABLE_TO_SIGN),void u(e??new d.PrivyProviderRpcError("Unable to sign typed data "+e))}}if(!p)throw new c.PrivyClientError("No embedded or connected wallet found for address.");if(!Oe||!_)return A.emitPrivyEvent(be,"signTypedData","onError",c.PrivyErrorCode.MUST_BE_AUTHENTICATED),void u(Error("User must be authenticated before signing with a Privy wallet"));let y=p.address,w=p.walletIndex??0,{entropyId:m,entropyIdVerifier:g}=l.getEntropyDetailsForUser(_,p),v=a.getIsUnifiedWallet(p),f=o.generateTypedDataWithDomainType(e),E=async()=>{let e;if(!Oe)throw Error("User must be authenticated before signing with a Privy wallet");let t=await te();if(!Z||!t||!await wt.recoverEmbeddedWallet({address:y}))throw Error("Unable to connect to wallet");if(i.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:y,requesterAppId:h}}),v){let{domain:n,types:i,primaryType:a,message:o}=f,l=await r.rpc(s,(async({message:e})=>await Z.signWithUserSigner({accessToken:t,requesterAppId:h,message:e})),{chain_type:"ethereum",method:"eth_signTypedData_v4",params:{typed_data:{domain:n,types:i,primary_type:a,message:o}},wallet_id:p.id});if(!l.data||!("signature"in l.data))throw new d.PrivyProviderRpcError("Unable to sign message");e=l.data.signature}else{let{response:r}=await Z.rpc({accessToken:t,entropyId:m,entropyIdVerifier:g,chainType:"ethereum",hdWalletIndex:w,requesterAppId:h,request:{method:"eth_signTypedData_v4",params:[y,f]}});e=r.data}return i.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:y,requesterAppId:h}}),e};if(He({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await E();A.emitPrivyEvent(be,"signTypedData","onSuccess",{signature:e}),n({signature:e})}catch(e){A.emitPrivyEvent(be,"signTypedData","onError",c.PrivyErrorCode.UNABLE_TO_SIGN),u(e??new d.PrivyProviderRpcError("Unable to sign message"))}else ne({signMessage:{method:"eth_signTypedData_v4",data:f,confirmAndSign:E,onSuccess:e=>{A.emitPrivyEvent(be,"signTypedData","onSuccess",{signature:e}),n({signature:e})},onFailure:e=>{A.emitPrivyEvent(be,"signTypedData","onError",c.PrivyErrorCode.UNABLE_TO_SIGN),u(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:p.recoveryMethod,connectingWalletAddress:p.address,entropyId:m,isUnifiedWallet:v,entropyIdVerifier:g,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{A.emitPrivyEvent(be,"signMessage","onError",c.PrivyErrorCode.UNKNOWN_CONNECT_WALLET_ERROR),u(e)}}}),Ve("EmbeddedWalletConnectingScreen")})),sendTransaction:async(e,t)=>await st({transaction:e,sponsor:t?.sponsor,uiOptions:t?.uiOptions,fundWalletConfig:t?.fundWalletConfig,address:t?.address,signOnly:!1}),signTransaction:async(e,t)=>({signature:(await st({transaction:e,uiOptions:t?.uiOptions,address:t?.address,signOnly:!0})).hash}),exportWallet:e=>new Promise((async(t,r)=>{if(!Oe||!_)return void r(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let s=e?.address?a.getPrivyWalletWithAddress(_,e.address):a.getPrivyEthereumWallet(_);if(!s)return void r(new c.PrivyClientError("User must have an embedded wallet."));let o=s.address,{entropyId:u,entropyIdVerifier:h}=l.getEntropyDetailsForUser(_,s),p=a.getIsUnifiedWallet(s);if(!o)return void r(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));if(!m.isAddress(o))return void r(Error("Must provide a valid Ethereum address."));let y={recoveryMethod:s.recoveryMethod,connectingWalletAddress:s.address,isUnifiedWallet:p,entropyId:u,entropyIdVerifier:h,onCompleteNavigateTo:"EmbeddedWalletKeyExportScreen",onFailure:r,shouldForceMFA:!0};ne(re),await te()&&Z?Z?d.isFirstClassChainWallet(s)?(ne({keyExport:{appId:n.appId,appClientId:n.clientId,origin:i.apiUrl,address:s.address,entropyId:u,entropyIdVerifier:h,hdWalletIndex:s.walletIndex,chainType:s.chainType,walletId:s.id,isUnifiedWallet:p,imported:s.imported,onSuccess:t,onFailure:r},connectWallet:y}),Ve("EmbeddedWalletConnectingScreen")):r(Error(`Export is not supported for ${s.chainType} wallets`)):r(Error("Must have a Privy wallet before exporting")):r(Error("Must have valid access token to enroll in MFA"))})),promptMfa:ot,async init(e){switch(e){case"sms":return void await i.initMfaSmsVerification();case"passkey":return await i.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new c.PrivyClientError("Invalid MFA code");ke.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{_e.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new c.PrivyClientError("Invalid authenticator response");let r=await import("@simplewebauthn/browser"),n=qt(await r.startAuthentication({optionsJSON:t}));ke.current?.resolve({mfaMethod:e,mfaCode:n,relyingParty:window.origin}),await new Promise(((e,t)=>{_e.current={resolve:e,reject:t}}));break;default:throw ke.current?.reject(new c.PrivyClientError("Unsupported MFA method")),new c.PrivyClientError(`Unsupported MFA method: ${e}`)}},cancel(){ke.current?.reject(new c.PrivyClientError("MFA canceled"))},async initEnrollmentWithSms(e){let t=await te();if(!t||!Z)throw Error("Must have valid access token to enroll in MFA");await Z.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,r)=>{if(!e)return wt.closePrivyModal(),void t();h.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),ne({mfaEnrollmentFlow:{mfaMethods:h.mfa.methods,shouldUnlinkOnUnenrollMfa:h.passkeys.shouldUnlinkOnUnenrollMfa,onSuccess:t,onFailure:r}}),Ve("MfaEnrollmentFlowScreen")})),async initEnrollmentWithTotp(){let e=await te();if(!e||!Z)throw Error("Must have valid access token to enroll in MFA");let t=await Z.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await te();if(!t||!Z)throw Error("Must have valid access token to enroll in MFA");await Z.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),S(await i.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await te();if(!t||!Z)throw Error("Must have valid access token to enroll in MFA");await Z.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),S(await i.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e},t={}){let r=await te();if(!r||!Z)throw Error("Must have valid access token to enroll in MFA");await Z.submitEnrollMfa({method:"passkey",accessToken:r,credentialIds:e,removeForLogin:t.removeForLogin}),S(await i.getAuthenticatedUser())},async unenroll(e,t={}){let r=await te();if(!r||!Z)throw Error("Must have valid access token to remove MFA");"passkey"===e?await Z.submitEnrollMfa({method:"passkey",accessToken:r,credentialIds:[],removeForLogin:t.removeForLogin}):await Z.unenrollMfa({method:e,accessToken:r}),S(await i.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await te(),t=_?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!Z||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(a.getIsUnifiedWallet(t))throw new c.PrivyClientError("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!_?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await wt.recoverEmbeddedWallet({address:t.address}))throw Error("Unable to connect to wallet");let r=await Z.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===r.status&&S(await i.getAuthenticatedUser()||_||null),ne({farcasterSigner:r}),Ve("FarcasterSignerStatusScreen")},getFarcasterSignerPublicKey:async()=>{let e,t=await te(),r=_?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!Z||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(a.getIsUnifiedWallet(r))throw new c.PrivyClientError("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!_?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await wt.recoverEmbeddedWallet({address:r.address}))throw Error("Unable to connect to wallet");if(!_.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=_.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await te(),r=_?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!Z||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(a.getIsUnifiedWallet(r))throw new c.PrivyClientError("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!_?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await wt.recoverEmbeddedWallet({address:r.address}))throw Error("Unable to connect to wallet");if(!_.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let n=await import("@simplewebauthn/browser"),i=await Z.signFarcasterMessage({address:r.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:n.bufferToBase64URLString(e)},fid:BigInt(_.farcaster.fid),relyingParty:window.origin});return new Uint8Array(n.base64URLStringToBuffer(i.signature))},signMessageWithCrossAppWallet(e,{address:t,chainId:r}){let n=_?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return _t({user:_,client:i,address:t,requesterAppId:h.id,request:{method:n?"privy_signSmartWalletMessage":"personal_sign",params:[e,t],chainId:r},reconnect:ht})},signTypedDataWithCrossAppWallet(e,{address:t,chainId:r}){let n=_?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),a=o.generateTypedDataWithDomainType(e);return _t({user:_,client:i,address:t,requesterAppId:h.id,request:{method:n?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,a],chainId:r},reconnect:ht})},sendTransactionWithCrossAppWallet(e,{address:t}){let r=_?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return _t({user:_,client:i,address:t,requesterAppId:h.id,request:{method:r?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e],chainId:e.chainId},reconnect:ht})},signTransactionWithCrossAppWallet(e,{address:t}){let r=_?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return _t({user:_,client:i,address:t,requesterAppId:h.id,request:{method:r?"privy_signSmartWalletTx":"eth_signTransaction",params:[e],chainId:e.chainId},reconnect:ht})},isModalOpen:E||!!P,mfaMethods:h.mfa.methods};er=pt.signMessage,tr=pt.signTypedData,nr=async(e,t)=>await st({transaction:e,...t,signOnly:!1}),rr=async(e,t)=>({signature:(await st({transaction:e,...t,signOnly:!0})).hash});let yt=async e=>{let t,r,n;F(!0),$({status:"loading"}),i.startAuthFlow(new me({...e,customOAuthRedirectUrl:h.customOAuthRedirectUrl}));let a=d.u.get(p.STATE_CODE_KEY),s=e.stateCode;if(a!==s)throw i.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:a??"",returnedStateCode:s??""}}),F(!1),new c.PrivyClientError("Unexpected auth flow. This may be a phishing attempt.",void 0,c.PrivyErrorCode.OAUTH_UNEXPECTED);if(null!==await i.getAccessToken())try{({user:t,oAuthTokens:n}=await i.link()),qe.current=e.provider;let r=lt(t);t&&r&&A.emitPrivyEvent(be,"linkAccount","onSuccess",{user:t,linkMethod:qe.current,linkedAccount:r})}catch(t){throw F(!1),A.emitPrivyEvent(be,"linkAccount","onError",t.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:r,oAuthTokens:n}=await i.authenticate()),qe.current=e.provider;let a=lt(t);t&&a&&void 0!==r&&A.emitPrivyEvent(be,"login","onComplete",{user:t,isNewUser:r,wasAlreadyAuthenticated:!1,loginMethod:qe.current,loginAccount:a})}catch(e){throw F(!1),$({status:"error",error:e}),A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}return S(t),R(r||!1),je(!0),F(!1),$({status:"done"}),n&&t&&A.emitPrivyEvent(be,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:n,user:t}),t??void 0},wt={privy:s,setAuthenticated:je,setUser:S,setIsNewUser:R,isNewUserThisSession:x,pendingTransaction:null,walletConnectionStatus:D,setWalletConnectionStatus:L,connectors:i.connectors?.walletConnectors??[],rpcConfig:h.rpcConfig,chains:h.chains,appId:n.appId,showFiatPrices:"native-token"!==h.embeddedWallets.priceDisplay.primary,clientAnalyticsId:i.clientAnalyticsId,hideWalletUIs:Ke,isHeadlessSigning:t.useCallback(He,[h.embeddedWallets.showWalletUIs]),emailOtpState:z,setEmailOtpState:K,smsOtpState:H,setSmsOtpState:V,oAuthState:G,setOAuthState:$,telegramAuthState:J,setTelegramAuthState:Q,siweState:B,setSiweState:Y,isHeadlessOAuthLoading:M,baseAccountSdk:W,setBaseAccountSdk:U,nativeTokenSymbolForChainId:e=>h.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(Z)return Z;let t=new Promise((e=>{ce.current=e})),r=new Promise((t=>setTimeout((()=>t(null)),e))),n=await Promise.race([t,r]);return ce.current=null,n},getAuthFlow:()=>i.authFlow,getAuthMeta:()=>i.authFlow?.meta,client:i,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,r=T&&Oe&&_;if(r&&qe.current&&(t=lt(_)),"login"===ze.current)e.shouldCallAuthOnSuccess&&r&&qe.current?A.emitPrivyEvent(be,"login","onComplete",{user:_,isNewUser:x,wasAlreadyAuthenticated:!1,loginMethod:qe.current,loginAccount:t??null}):A.emitPrivyEvent(be,"login","onError",c.PrivyErrorCode.USER_EXITED_AUTH_FLOW);else if("link"===ze.current&&t)e.isSuccess&&r&&qe.current?A.emitPrivyEvent(be,"linkAccount","onSuccess",{user:_,linkMethod:qe.current,linkedAccount:t}):qe.current&&A.emitPrivyEvent(be,"linkAccount","onError",c.PrivyErrorCode.USER_EXITED_LINK_FLOW,{linkMethod:qe.current});else if("update"===ze.current&&t)e.isSuccess&&r&&qe.current?A.emitPrivyEvent(be,"update","onSuccess",{user:_,updateMethod:qe.current,updatedAccount:t}):qe.current&&A.emitPrivyEvent(be,"update","onError",c.PrivyErrorCode.USER_EXITED_UPDATE_FLOW,{linkMethod:qe.current});else if("connect-or-create"===ze.current){let e=Kt();e[0]?A.emitPrivyEvent(be,"connectOrCreateWallet","onSuccess",{wallet:e[0]}):A.emitPrivyEvent(be,"connectOrCreateWallet","onError",c.PrivyErrorCode.USER_EXITED_AUTH_FLOW)}let a=O&&Rt.has(O),s="ErrorScreen"===O&&re.errorModalData&&Rt.has(re.errorModalData.previousScreen);if((a||s)&&re.funding){let e,t=Rt.get(O)??null;if(s&&re.funding?.onError){let e=re.errorModalData?.error,t=e?.privyErrorCode||c.PrivyErrorCode.UNKNOWN_FUNDING_ERROR,r=new c.PrivyClientError(e?.message||"Funding failed",e,t);re.funding?.onError?.(r)}if("solana"===re.funding.chainType){let r=h.solanaRpcs[re.funding.chain];if(!r)return console.warn("Unable to load solana rpc, skipping balance"),A.emitPrivyEvent(be,"fundSolanaWallet","onUserExited",{address:re.funding.address,fundingMethod:t,chain:re.funding.chain,balance:e}),C(!1),void xt(re.funding,t);if(u(f.SOLANA_FUNDING_PLUGIN_ID))try{e=await Nt({rpc:r.rpc,address:re.funding.address})}catch{console.error("Unable to pull wallet balance")}else console.warn("Unable to load solana plugin, skipping balance");A.emitPrivyEvent(be,"fundSolanaWallet","onUserExited",{address:re.funding.address,fundingMethod:t,chain:re.funding.chain,balance:e})}else{let r=b.getPublicClient(re.funding.chain.id,h.chains,h.rpcConfig,{appId:n.appId});try{e=await r.getBalance({address:re.funding.address})}catch{console.error("Unable to pull wallet balance")}A.emitPrivyEvent(be,"fundWallet","onUserExited",{address:re.funding.address,chain:re.funding.chain,fundingMethod:t,balance:e}),xt(re.funding,t)}}ne((e=>({...e,externalConnectWallet:{}}))),ze.current=null,qe.current=null,R(!1),C(!1),L({status:"disconnected",connectedWallet:null,connector:null,connectError:null,connectRetry:()=>{}}),setTimeout((()=>{i.authFlow=void 0}),200)},openPrivyModal:Ve,connectWallet:$e,initLoginWithWallet:async(e,t,r,n)=>{o.isBaseConnectedEthereumWallet(e)?(qe.current="siwe",Je(e,t,r)):(qe.current="siws",Qe(e,t,r,n))},loginWithWallet:async()=>{let e,t,r;if(!T)throw new c.PrivyNotReadyError;if(i.authFlow instanceof Ce?e="siwe":i.authFlow instanceof Ae&&(e="siws"),!e)throw new c.PrivyClientError("Must initialize SIWE/SIWS flow first.");if(null!==await i.getAccessToken())try{({user:t}=await i.link()),qe.current=e}catch(t){throw A.emitPrivyEvent(be,"linkAccount","onError",t.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:r}=await i.authenticate()),qe.current=e}catch(e){throw A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.GENERIC_CONNECT_WALLET_ERROR),e}S(t||_||null),R(r||!1),je(!0)},delegateWallet:async({address:e,chainType:t,showDelegationUIs:r})=>new Promise((async(n,i)=>{let s=await te();if(!Oe||!_||!s)throw new c.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new c.PrivyClientError("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let o=wt.walletProxy??await wt.initializeWalletProxy(15e3);if(!o)throw new c.PrivyClientError("Wallet proxy not initialized.");if((({address:e,user:t})=>!!Ct(t).find((t=>t.address===e)))({address:e,user:_}))return n();let l=a.getPrivyWalletWithAddress(_,e);if(!l)throw new c.PrivyClientError("Address to delegate is not associated with current user.");if(a.getIsUnifiedWallet(l))throw new c.PrivyClientError("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let d=ft({address:e,user:_}),u=Et({address:e,user:_}),h=async()=>{await o.createDelegatedAction({accessToken:s,rootWallet:u,delegatedWallets:[d]}),await wt.refreshSessionAndUser()};if(await wt.recoverEmbeddedWallet({address:e}),r)ne({delegatedActions:{consent:{address:e,onDelegate:h,onSuccess:async()=>{n()},onError:async e=>{i(e)}}}}),Ve("DelegatedActionsConsentScreen");else try{await h(),n()}catch(e){i(e)}})),revokeDelegatedWallets:async({showDelegationUIs:e})=>new Promise((async(t,r)=>{if(!Oe||!_)throw new c.PrivyClientError("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");let n=Ct(_);if(0===n.length)throw new c.PrivyClientError("User has no delegated wallets to revoke.");if(n.some(a.getIsUnifiedWallet))throw new c.PrivyClientError("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let s=async()=>{await i.revokeDelegatedWallet(),await wt.refreshSessionAndUser()};if(e)ne({delegatedActions:{revoke:{onRevoke:s,onSuccess:async()=>{t()},onError:async e=>{r(e)}}}}),Ve("DelegatedActionsRevokeScreen");else try{await s(),t()}catch(e){r(e)}})),initLoginWithFarcaster:async(e,t)=>{let r=new oe(e,t);i.startAuthFlow(r);try{qe.current="farcaster",await r.initializeFarcasterConnect()}catch(e){throw"login"===ze.current?A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR):"link"===ze.current&&A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!T)throw new c.PrivyNotReadyError;if(!(i.authFlow instanceof oe))throw new c.PrivyClientError("Must initialize Farcaster flow first.");if(null!==await i.getAccessToken())try{({user:e}=await i.link()),qe.current="farcaster"}catch(e){throw A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await i.authenticate()),qe.current="farcaster"}catch(e){throw A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}S(e||null),R(t||!1),je(!0)},async crossAppAuthFlow({appId:e,popup:t,action:r,disableSignup:n}){let a=`privy:${e}`;qe.current=a;let{url:s,stateCode:o,codeVerifier:l}=await async function({api:e,appId:t}){let r=pe(),n=ye(),i=await we(r);try{let{url:a}=await e.post(v.oAuthInitPath,{provider:`privy:${t}`,redirect_to:window.location.href,code_challenge:i,state_code:n});return{url:a,stateCode:n,codeVerifier:r}}catch(e){throw c.formatApiError(e)}}({api:i.api,appId:e});if(!s)throw i.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new c.PrivyClientError("No authorization URL returned for cross-app auth.");try{let d=await async function({url:e,popup:t}){return t.location=e,new Promise(((e,r)=>{let n,i=setTimeout((()=>{r(new c.PrivyClientError("Authorization request timed out after 2 minutes.")),a()}),12e4);function a(){t?.close(),window.removeEventListener("message",o)}let s=setInterval((()=>{t?.closed&&!n&&(a(),clearInterval(s),clearTimeout(i),r(new c.PrivyClientError("User rejected request")))}),300);function o(t){t.data&&("PRIVY_OAUTH_RESPONSE"===t.data.type&&t.data.stateCode&&t.data.authorizationCode&&(clearTimeout(i),e(t.data),a()),"PRIVY_OAUTH_ERROR"===t.data.type&&(clearTimeout(i),r(new c.PrivyClientError(t.data.error)),a()),t.data.type===Pt&&((n=new BroadcastChannel(At)).onmessage=o))}window.addEventListener("message",o)}))}({url:s,popup:t,provider:a}),u=d.stateCode,h=d.authorizationCode;if(u!==o)throw i.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:a,storedStateCode:o??"",returnedStateCode:u??""}}),new c.PrivyClientError("Unexpected auth flow. This may be a phishing attempt.",void 0,c.PrivyErrorCode.OAUTH_UNEXPECTED);let p=await async function({appId:e,stateCode:t,codeVerifier:r,authorizationCode:n,action:i,client:a,disableSignup:s}){if(!n||!t)throw new c.PrivyClientError("[Cross-App AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if("undefined"===n)throw new c.PrivyClientError("User denied confirmation during cross-app auth flow");try{let o=new Tt({authorizationCode:n,stateCode:t,codeVerifier:r,provider:`privy:${e}`,disableSignup:!!s});a.startAuthFlow(o);let l="link"===i?await a.link():await a.authenticate(),c=l.oAuthTokens?.accessToken;return console.debug(),c}catch(e){let t=c.formatApiError(e);if(t.privyErrorCode===c.PrivyErrorCode.ACCOUNT_TRANSFER_REQUIRED)throw t;if(t.privyErrorCode)throw new c.PrivyClientError(t.message||"Invalid code during cross-app auth flow.",void 0,t.privyErrorCode);if("User denied confirmation during cross-app auth flow"===t.message)throw new c.PrivyClientError("Invalid code during cross-app auth flow.",void 0,c.PrivyErrorCode.OAUTH_USER_DENIED);throw new c.PrivyClientError("Invalid code during cross-app auth flow.",void 0,c.PrivyErrorCode.UNKNOWN_AUTH_ERROR)}}({appId:e,codeVerifier:l,stateCode:u,authorizationCode:h,action:r,client:i,disableSignup:n});p&&i.storeProviderAccessToken(e,p);let y=await wt.refreshSessionAndUser();if(!y)throw new c.PrivyClientError("Unable to update user");return i.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),y}catch(e){throw i.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:a}}),e}},async initLoginWithOAuth(e,t,r){if(qe.current=e,!d.e())return void Ve("InAppBrowserLoginNotPossible");if("google"===e&&!h.allowOAuthInEmbeddedBrowsers&&Ot(window.navigator.userAgent))return void Ve("InAppBrowserLoginNotPossible");"twitter"===e&&window.opener&&window.opener.postMessage({type:Pt},"*"),d.u.del(p.HEADLESS_OAUTH_KEY),d.u.del(p.OAUTH_DISABLE_SIGNUP_KEY);let n=new me({provider:e,disableSignup:!!r,withPrivyUi:!0,customOAuthRedirectUrl:h.customOAuthRedirectUrl});t&&n.addCaptchaToken(t),i.startAuthFlow(n);let a=await i.authFlow.getAuthorizationUrl();if(a&&a.url)if("twitter"===e&&w.isAndroid&&(a.url=a.url.replace("x.com","twitter.com")),"chrome-extension:"===window.location.protocol&&de())try{let{privyOAuthCode:e,privyOAuthState:t}=await ue(a.url);Ve("OAuthStatusScreen"),n.meta.stateCode=t,n.meta.authorizationCode=e}catch(e){throw console.error("OAuth in chrome extension flow failed:",e),e}else window.location.assign(a.url)},async initLoginWithTelegram(e,t){if(!T)throw new c.PrivyNotReadyError;qe.current="telegram";let r=new We(e,t);i.startAuthFlow(r),Q({status:"loading"}),r.meta.telegramWebAppData=void 0,r.meta.telegramAuthResult=await new Promise(((e,t)=>h.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:h.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(r=>r?e(r):("link"===ze.current?A.emitPrivyEvent(be,"linkAccount","onError",c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}):"login"===ze.current?A.emitPrivyEvent(be,"login","onError",c.PrivyErrorCode.INVALID_CREDENTIALS):"update"===ze.current&&A.emitPrivyEvent(be,"login","onError",c.PrivyErrorCode.FAILED_TO_UPDATE_ACCOUNT),t(new c.PrivyClientError("Telegram auth failed or was canceled by the client"))))):t(new c.PrivyClientError("Telegram was not initialized")):t(new c.PrivyClientError("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,r;if(!(i.authFlow instanceof We))throw new c.PrivyClientError("Must initialize Telegram flow before calling loginWithTelegram");i.authFlow.meta.captchaToken||=e?.captchaToken;let n=await te(),a=e?.intent||ze.current;if("login"===a)try{let e=await i.authenticate();t=e.user,r=e.isNewUser,qe.current="telegram"}catch(e){throw A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}else{if("link"!==a)throw new c.PrivyClientError("Unknown auth intent");try{t=(await i.link()).user,qe.current="telegram"}catch(e){throw A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}S(t),R(r||!1),je(!0),Q({status:"done"});let s=t?.linkedAccounts.find((({type:e})=>"telegram"===e))||null;return{user:t,isNewUser:r||!1,wasAlreadyAuthenticated:!!n,loginAccount:s}},async loginWithOAuth(e){let t,r,n;if(!(i.authFlow instanceof me))throw new c.PrivyClientError("Must initialize OAuth flow before calling loginWithOAuth");let a=d.u.get(p.STATE_CODE_KEY),s=i.authFlow.meta.stateCode;if(a!==s)throw i.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:a??"",returnedStateCode:s??""}}),new c.PrivyClientError("Unexpected auth flow. This may be a phishing attempt.",void 0,c.PrivyErrorCode.OAUTH_UNEXPECTED);if(null!==await i.getAccessToken())try{let r=await i.link();t=r.user,n=r.oAuthTokens,qe.current=e}catch(t){throw A.emitPrivyEvent(be,"linkAccount","onError",t.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let a=await i.authenticate();t=a.user,r=a.isNewUser,n=a.oAuthTokens,qe.current=e}catch(t){throw"login"===ze.current?A.emitPrivyEvent(be,"login","onError",t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR):"link"===ze.current&&A.emitPrivyEvent(be,"linkAccount","onError",t.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return S(t),R(r||!1),je(!0),n&&t&&A.emitPrivyEvent(be,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:n,user:t}),n},passkeyAuthState:j,setPasskeyAuthState:q,async initSignupWithPasskey({captchaToken:e,withPrivyUi:t}){let r=new fe({captchaToken:e,setPasskeyAuthState:q,hints:h.passkeys.registration?.hints});i.startAuthFlow(r),ze.current="login";try{qe.current="passkey",q({status:"generating-challenge"}),await r.initRegisterFlow(t),q({status:"awaiting-passkey"})}catch(e){throw q({status:"error",error:e}),A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}},async signupWithPasskey(){let e,t;if(!T)throw new c.PrivyNotReadyError;if(!(i.authFlow instanceof fe))throw new c.PrivyClientError("Must initialize Passkey flow first.");if("passkey"!==qe.current){let e=new c.PrivyClientError("Must init login with Passkey flow first.");throw q({status:"error",error:e}),e}let r=await te();try{qe.current="passkey",q({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await i.authenticate())}catch(e){throw q({status:"error",error:e}),A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}S(e),R(t||!1),je(!0),q({status:"done"});let n=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!r,loginAccount:n}},async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let r=new fe({captchaToken:e,setPasskeyAuthState:q,hints:void 0});i.startAuthFlow(r),ze.current="login";try{qe.current="passkey",q({status:"generating-challenge"}),await r.initAuthenticationFlow(t),q({status:"awaiting-passkey"})}catch(e){throw q({status:"error",error:e}),A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(e){let t,r;if(!T)throw new c.PrivyNotReadyError;if(!(i.authFlow instanceof fe))throw new c.PrivyClientError("Must initialize Passkey flow first.");if(e?.credentialIds&&(i.authFlow.meta.allowedCredentialsIds=e.credentialIds),"passkey"!==qe.current){let e=new c.PrivyClientError("Must init login with Passkey flow first.");throw q({status:"error",error:e}),e}let n=await te();try{qe.current="passkey",q({status:"awaiting-passkey"}),({user:t,isNewUser:r}=await i.authenticate())}catch(e){throw q({status:"error",error:e}),A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}S(t),R(r||!1),je(!0),q({status:"done"});let a=t?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:t,isNewUser:r||!1,wasAlreadyAuthenticated:!!n,loginAccount:a}},async initLinkWithPasskey(e){let t=new fe({captchaToken:e,hints:h.passkeys.registration?.hints});i.startAuthFlow(t),ze.current="link",qe.current="passkey",q({status:"generating-challenge"});try{await t.initLinkFlow(),q({status:"awaiting-passkey"})}catch(e){throw A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),q({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!T)throw new c.PrivyNotReadyError;if(!(i.authFlow instanceof fe))throw new c.PrivyClientError("Must initialize Passkey flow first.");if("passkey"!==qe.current)throw new c.PrivyClientError("Must init login with Passkey flow first.");try{qe.current="passkey",({user:e}=await i.link())}catch(e){throw A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return S(e||_||null),q({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,r){if(!d.e())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&!h.allowOAuthInEmbeddedBrowsers&&Ot(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let n=new me({provider:e,withPrivyUi:!1,disableSignup:r??!1,customOAuthRedirectUrl:h.customOAuthRedirectUrl});t&&n.addCaptchaToken(t),$({status:"loading"});let a=await i.startAuthFlow(n).getAuthorizationUrl();if(a?.url)if("chrome-extension:"===window.location.protocol&&de())try{let{privyOAuthCode:e,privyOAuthState:t}=await ue(a.url);n.meta.stateCode=t,n.meta.authorizationCode=e,await yt(n.meta)}catch(e){throw $({status:"error",error:e}),e}else window.location.assign(a.url)},loginWithHeadlessOAuth:yt,initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:r,withPrivyUi:n})=>{let a=new ie({email:e,captchaToken:t,disableSignup:r});i.startAuthFlow(a);try{qe.current="email",K({status:"sending-code"});let e=await a.sendCodeEmail({withPrivyUi:n});if(e?.ssoRedirectUrl)return window.location.href=e.ssoRedirectUrl,void await o.sleep(1e4);K({status:"awaiting-code-input"})}catch(e){throw K({status:"error",error:e}),"login"===ze.current?A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR):"link"===ze.current&&A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async({oldAddress:e,newAddress:t,captchaToken:r})=>{let n=new ae(e,t,r);i.startAuthFlow(n);try{await n.sendCodeEmail({withPrivyUi:!0})}catch(e){throw A.emitPrivyEvent(be,"update","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:qe.current}),e}},initUpdatePhone:async(e,t,r)=>{let n=new Te(e,t,r);i.startAuthFlow(n);try{await n.sendSmsCode({withPrivyUi:!0})}catch(e){A.emitPrivyEvent(be,"update","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:qe.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:r,withPrivyUi:n})=>{V({status:"sending-code"});let a=new Pe({phoneNumber:e,captchaToken:t,disableSignup:r});i.startAuthFlow(a);try{qe.current="sms",await a.sendSmsCode({withPrivyUi:n}),V({status:"awaiting-code-input"})}catch(e){throw V({status:"error",error:e}),"login"===ze.current?A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR):"link"===ze.current&&A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(i.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(i.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,r;function n(e){i.authFlow instanceof ie?K(e):i.authFlow instanceof Pe&&V(e)}if(n({status:"submitting-code"}),!T){let e=new c.PrivyNotReadyError;throw n({status:"error",error:e}),e}if(i.authFlow instanceof ie)i.authFlow.meta.emailCode=e.trim();else{if(!(i.authFlow instanceof Pe)){let e=new c.PrivyClientError("Must initialize a passwordless code flow first");throw n({status:"error",error:e}),e}i.authFlow.meta.smsCode=e.trim()}let a=await te();if("link"===ze.current)try{({user:t}=await i.link())}catch(e){throw n({status:"error",error:e}),A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:qe.current}),e}else if("update"===ze.current)try{({user:t}=await i.link())}catch(e){throw n({status:"error",error:e}),A.emitPrivyEvent(be,"update","onError",e.privyErrorCode||c.PrivyErrorCode.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:qe.current}),e}else try{({user:t,isNewUser:r}=await i.authenticate())}catch(e){throw n({status:"error",error:e}),A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}let s=t||_;S(s||null),R(r||!1),je(!0),n({status:"done"});let o=null;return i.authFlow instanceof ie?o=s?.linkedAccounts.find((({type:e})=>"email"===e))||null:i.authFlow instanceof Pe&&(o=s?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:s,isNewUser:r||!1,wasAlreadyAuthenticated:!!a,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:r})=>{ze.current=Oe?"link":"login",qe.current="siwe",Y({status:"generating-message"});let n=await i.generateSiweNonce({address:e,captchaToken:r});return Y({status:"awaiting-signature"}),Ee({address:e,chainId:t.replace("eip155:",""),nonce:n})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let r=await i.generateSiweNonce({address:e});return Ee({address:e,chainId:t.replace("eip155:",""),nonce:r})},linkSmartWallet:async({message:e,signature:t,smartWalletType:r,smartWalletVersion:n})=>{let a;a=await i.linkSmartWallet({message:e,signature:t,smartWalletType:r,smartWalletVersion:n}),S((a=await wt.refreshSessionAndUser()??a)||_||null)},loginWithSiwe:async({message:e,signature:t,captchaToken:r,disableSignup:n,walletClientType:a,connectorType:s})=>{let o,l=null;try{if(_)throw Error("User already authenticated");let c=new Ce(i,void 0,r,n,{message:e,signature:t,walletClientType:a,connectorType:s});i.startAuthFlow(c),qe.current="siwe",ze.current="login",Y({status:"submitting-signature"});let d=await i.authenticate();if(({user:l,isNewUser:o}=d),!l)throw Error("Authentication failed - no user returned")}catch(e){throw A.emitPrivyEvent(be,"login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),Y({status:"error",error:e}),e}return S(l),R(o||!1),je(!0),Y({status:"done"}),ze.current=null,qe.current=null,{user:l,isNewUser:o||!1}},linkWithSiwe:async({message:e,signature:t,chainId:r,walletClientType:n,connectorType:a})=>{let s;et("siwe");let o=null;try{Y({status:"submitting-signature"}),s=await i.linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:n,connectorType:a}),s=await wt.refreshSessionAndUser()??s,Y({status:"done"}),(o=lt(s)||null)&&A.emitPrivyEvent(be,"linkAccount","onSuccess",{user:s,linkMethod:"siwe",linkedAccount:o})}catch(e){throw A.emitPrivyEvent(be,"linkAccount","onError",e.privyErrorCode||c.PrivyErrorCode.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),ze.current=null,qe.current=null,Y({status:"error",error:e}),e}let l=s||_;return S(l||null),ze.current=null,qe.current=null,{user:l,linkedAccount:o}},refreshSessionAndUser:async()=>{let e=await i.getAuthenticatedUser();return je(!!e),S(e),e},walletProxy:Z,createAnalyticsEvent:({eventName:e,payload:t,timestamp:r})=>i.createAnalyticsEvent({eventName:e,payload:t,timestamp:r}),acceptTerms:async()=>{let e=await i.acceptTerms();return S(e),e},getUsdTokenPrice:e=>i.getUsdTokenPrice(e),getUsdPriceForSol:()=>i.getUsdPriceForSol(),getSplTokenMetadata:e=>i.getSplTokenMetadata(e),recoverEmbeddedWallet:async e=>new Promise((async(t,r)=>{if(!_)return void t(!0);let n=e?.address?a.getPrivyWalletWithAddress(_,e.address):a.getPrivyPrimaryWallet(_)||a.getImportedPrivyEthereumWallets(_).at(0)||a.getImportedPrivySolanaWallets(_).at(0);if(!n||a.getIsUnifiedWallet(n))return void t(!0);let s=await te();if(!s||!Z||!n)return void r(Error("Must have valid access token and Privy wallet to recover wallet"));let{entropyId:o,entropyIdVerifier:c}=l.getEntropyDetailsForUser(_,n);try{await Z.connect({accessToken:s,entropyId:o,entropyIdVerifier:c}),t(!0)}catch(e){if(ct(e)&&"privy"===n.recoveryMethod){let e;i.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:n.address}});try{e=await Z.recover({entropyId:o,entropyIdVerifier:c,accessToken:s})}catch(e){return void r(e)}e.entropyId||r(Error("Unable to recover wallet")),i.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:n.address}}),t(!0)}else ct(e)&&"privy"!==n.recoveryMethod&&"privy-v2"!==n.recoveryMethod?(ne({recoverWallet:{entropyId:o,entropyIdVerifier:c,onFailure:r,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:n.recoveryMethod,action:"recover",shouldCreateEth:!1,shouldCreateSol:!1}}),Ve(Ut(n.recoveryMethod))):r(e)}})),setReadyToTrue:e=>{k(!0),se?.(e)},updateWallets:()=>rt(),fundWallet:async(e,t)=>{let r="FundingMethodSelectionScreen";return new Promise(((n,i)=>{ne({funding:{...d.prepareFundingModalData({address:e,appConfig:h,fundWalletConfig:t,methodScreen:r,onComplete:n,onError:i})}}),Ve(r)}))},openModal:Ve,requestFarcasterSignerStatus:async e=>{let t=await te(),r=_?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!Z||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!_?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let n=await i.requestFarcasterSignerStatus(e);return"approved"===n.status&&S(await i.getAuthenticatedUser()||_||null),n},connectCoinbaseSmartWallet:async()=>{h.externalWallets.coinbaseWallet.config.preference={...h.externalWallets.coinbaseWallet.config.preference,options:"smartWalletOnly"};let e=i.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||i.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),$e(e);await Ge("coinbase_wallet","coinbase_smart_wallet")},connectBaseAccount:async()=>{let e=i.connectors?.findWalletConnector("base_account","base_account");if(e)return $e(e);await Ge("base_account","base_account")},initiateAccountTransfer:async({nonce:e,account:t,accountType:r,externalWalletMetadata:n,telegramAuthResult:a,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l})=>{let c=await i.sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:n,telegramAuthResult:a,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l});return S(c),c},inProgressAuthFlowRef:ze,inProgressLoginOrLinkMethodRef:qe};ir=wt.recoverEmbeddedWallet,wt.recoverEmbeddedWallet;let mt=t.useMemo((()=>({wallets:I,ready:he&&Ie})),[I,he,Ie]),gt=i.authFlow instanceof We,{siteKey:St,enabledProvider:bt}=h.captcha,It=!h.headless&&bt&&!Oe&&(T||gt);/*#__PURE__*/return e.jsx(Xt.Provider,{value:!0,children:/*#__PURE__*/e.jsx(a.PrivyContext.Provider,{value:pt,children:/*#__PURE__*/e.jsx(A.PrivyEventsContext.Provider,{value:be,children:/*#__PURE__*/e.jsx(l.UseWalletsContext.Provider,{value:mt,children:/*#__PURE__*/e.jsx(Se,{appId:h.id,captchaSiteKey:St,enabledCaptchaProvider:bt,children:/*#__PURE__*/e.jsxs(c.InternalPrivyContext.Provider,{value:wt,children:[/*#__PURE__*/e.jsx(o.RecentlyUsedAccountProvider,{children:/*#__PURE__*/e.jsxs(a.ModalProvider,{data:re,setModalData:ne,setInitialScreen:N,initialScreen:O,authenticated:Oe,open:E,children:[n.children,/*#__PURE__*/e.jsx(Zt,{customAuth:h.customAuth}),It&&/*#__PURE__*/e.jsx(Ne,{delayedExecution:!1}),/*#__PURE__*/e.jsx(it,{}),/*#__PURE__*/e.jsx(jt,{disabled:h.embeddedWallets.disableAutomaticMigration}),/*#__PURE__*/e.jsx(Le,{palette:h.appearance.palette||{}}),!h.render.standalone&&/*#__PURE__*/e.jsx(Xe,{open:E})]})}),/*#__PURE__*/e.jsx(vt,{appId:n.appId,appClientId:n.clientId,clientAnalyticsId:i.clientAnalyticsId,origin:i.apiUrl,mfaMethods:_?.mfaMethods,mfaPromise:ke,mfaSubmitPromise:_e,onLoad:X,onLoadFailed:()=>null}),h.loginConfig.telegramAuthConfiguration&&
/*#__PURE__*/e.jsx(o.Hide,{$if:!0,children:/*#__PURE__*/e.jsx(nt,{scriptHost:n.apiUrl||p.DEFAULT_PRIVY_API_URL,botUsername:h.loginConfig.telegramAuthConfiguration.botName})})]})})})})})})},sr=e=>ir(e);class or extends Error{constructor(e,t,r){super(e),this.code=t,this.data=r}}class lr extends z.default{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new or(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await te()||!this.address)throw new or("Disconnected",4900);let{hash:r}=await((e,t)=>nr(e,t))(t,{address:this.address});return r}async handleSignTransaction(e){if(!e.params||!Array.isArray(e.params))throw new or(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await te()||!this.address)throw new or("Disconnected",4900);let{signature:r}=await((e,t)=>rr(e,t))(t,{address:this.address});return r}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new or(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new or(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.publicClient=b.getPublicClient(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],r=e.params[1],{signature:n}=await((e,t)=>er(e,t))({message:t},{address:r});return n}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],r="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1],{signature:n}=await((e,t)=>tr(e,t))(o.generateTypedDataWithDomainType(r),{address:t});return n}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:o.toHex(this.chainId)};return await this.publicClient.estimateGas({account:t.from??this.address,...h.toViemTransactionSerializable(t)})}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return o.toHex(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"eth_signTransaction":return this.handleSignTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!(e=>re.includes(e))(e.method))return this.publicClient.request({method:e.method,params:e.params});{let t=await te();if(await sr({address:this.address}),!t||!this.address)throw new or("Disconnected",4900);try{let r={method:e.method,params:e.params},n=this.walletAccount;return n&&a.getIsUnifiedWallet(n)?this.handleWalletApiRequest(r,n,t):(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:r})).response.data}catch(e){throw console.error(e),new or("Disconnected",4900)}}}async handleWalletApiRequest(e,t,n){let i=this.privyClient;if(!i)throw new or("Disconnected",4900);if("secp256k1_sign"===e.method){let a=await r.rpc(i,(async({message:e})=>this.walletProxy.signWithUserSigner({accessToken:n,message:e})),{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:t.id,params:{hash:e.params[0]}});if("secp256k1_sign"!==a.method)throw new or(`Invalid params for ${e.method}`,4200);return a.data.signature}throw new or(`Method not supported: ${e.method}`,4200)}constructor({walletProxy:e,address:t,entropyId:r,entropyIdVerifier:n,rpcConfig:i,chains:a,appId:s,chainId:l=1,walletIndex:c,privyClient:d,walletAccount:u}){super(),this.walletProxy=e,this.address=t,this.entropyId=r,this.entropyIdVerifier=n,this.chainId=l,this.rpcConfig=i,this.chains=a,this.publicClient=b.getPublicClient(l,this.chains,i,{appId:s}),this.rpcTimeoutDuration=o.getRpcTimeout(i,"privy"),this.appId=s,this.walletIndex=c,this.privyClient=d,this.walletAccount=u}}const cr=({style:t,...r})=>/*#__PURE__*/e.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",stroke:"currentColor",strokeWidth:1.5,viewBox:"0 0 24 24",style:{...t},...r,children:/*#__PURE__*/e.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25m18 0A2.25 2.25 0 0018.75 3H5.25A2.25 2.25 0 003 5.25m18 0V12a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 12V5.25"})}),dr=({style:t,...r})=>/*#__PURE__*/e.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",width:"108",height:"108",viewBox:"0 0 108 108",fill:"none",style:{height:"28px",width:"28px",...t},...r,children:[/*#__PURE__*/e.jsx("rect",{width:"108",height:"108",rx:"23",fill:"#AB9FF2"}),/*#__PURE__*/e.jsx("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M46.5267 69.9229C42.0054 76.8509 34.4292 85.6182 24.348 85.6182C19.5824 85.6182 15 83.6563 15 75.1342C15 53.4305 44.6326 19.8327 72.1268 19.8327C87.768 19.8327 94 30.6846 94 43.0079C94 58.8258 83.7355 76.9122 73.5321 76.9122C70.2939 76.9122 68.7053 75.1342 68.7053 72.314C68.7053 71.5783 68.8275 70.7812 69.0719 69.9229C65.5893 75.8699 58.8685 81.3878 52.5754 81.3878C47.993 81.3878 45.6713 78.5063 45.6713 74.4598C45.6713 72.9884 45.9768 71.4556 46.5267 69.9229ZM83.6761 42.5794C83.6761 46.1704 81.5575 47.9658 79.1875 47.9658C76.7816 47.9658 74.6989 46.1704 74.6989 42.5794C74.6989 38.9885 76.7816 37.1931 79.1875 37.1931C81.5575 37.1931 83.6761 38.9885 83.6761 42.5794ZM70.2103 42.5795C70.2103 46.1704 68.0916 47.9658 65.7216 47.9658C63.3157 47.9658 61.233 46.1704 61.233 42.5795C61.233 38.9885 63.3157 37.1931 65.7216 37.1931C68.0916 37.1931 70.2103 38.9885 70.2103 42.5795Z",fill:"#FFFDF8"})]});function ur(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}var hr=0;class pr extends o.EthereumWalletConnector{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return{name:this.providerDetail.info.name,icon:this.providerDetail.info.icon,id:this.providerDetail.info.rdns}}disconnect(){console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`)}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new c.PrivyConnectorError("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw d.formatConnectorError(e)}}constructor(e,t,r,n,i){super(i||"unknown",e,t,r),this.connectorType="injected",this.proxyProvider=new o.PrivyProxyProvider(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.providerDetail=n;let a=n.provider;this.proxyProvider.setWalletProvider(a)}}var yr="__private_"+hr+++"__walletBranding";class wr extends o.EthereumWalletConnector{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return ur(this,yr)[yr]??{name:"Browser Extension",icon:cr,id:"extension"}}disconnect(){console.warn("Programmatic disconnect with browser wallets is not yet supported.")}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new c.PrivyConnectorError("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw d.formatConnectorError(e)}}constructor(e,t,r,n,i){super(i??"unknown",e,t,r),Object.defineProperty(this,yr,{writable:!0,value:void 0}),this.connectorType="injected",this.proxyProvider=new o.PrivyProxyProvider(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.proxyProvider.setWalletProvider(n),"metamask"===i?ur(this,yr)[yr]={name:"MetaMask",icon:o.Metamask,id:"io.metamask"}:"phantom"===i&&(ur(this,yr)[yr]={name:"Phantom",icon:dr,id:"phantom"})}}class mr extends pr{disconnect(){console.warn("MetaMask does not support programmatic disconnect.")}async promptConnection(){try{w.isMobile||await this.proxyProvider.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]});let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new c.PrivyConnectorError("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw d.formatConnectorError(e)}}}class gr extends z.default{get wallets(){let e=new Set;return this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let r=`${t.address}${t.walletClientType}${t.connectorType}${t.meta.id}`;return!e.has(r)&&(e.add(r),!0)}))}async initialize(e){if(this.initialized&&!e||(e&&this.removeAllConnectors(),this.externalWalletConfig.disableAllExternalWallets))return;let t=o.detectInjectedConnectors({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:r})=>{this.createEthereumWalletConnector({connectorType:"injected",walletClientType:e,providers:{eip6963InjectedProvider:t,legacyInjectedProvider:r}})}))}));for(let e of(this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector({connectorType:"coinbase_wallet",walletClientType:"coinbase_wallet"}),this.walletList.includes("base_account")&&this.createEthereumWalletConnector({connectorType:"base_account",walletClientType:"base_account"}),Object.values(o.mobileWalletsConfig)))!e.isInstalled&&this.walletList.includes(e.client)&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&e.chainTypes.includes("ethereum")&&this.createEthereumWalletConnector({connectorType:"null",walletClientType:e.client,walletConfig:e}),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&e.chainTypes.includes("solana")&&this.addSolanaWalletConnector(new o.SolanaNullConnector({id:e.client,name:e.name})));this.externalWalletConfig.walletConnect.enabled&&(this.walletList.includes("wallet_connect_qr")||o.shouldFetchWcRegistryListings(this.walletList))&&"solana-only"!==this.walletChainType&&this.createEthereumWalletConnector({connectorType:"wallet_connect_v2",walletClientType:"unknown"});let r=this.walletList.includes("wallet_connect_qr_solana")||o.shouldFetchWcRegistryListings(this.walletList)&&"ethereum-only"!==this.walletChainType,n=this.externalWalletConfig.solana.connectors?.get()||[],i=async e=>{if(!r)return;let t=e.find((e=>"walletconnect_solana"===e.walletBranding?.id));t&&t.wallet&&await t.wallet.initialize({walletConnectCloudProjectId:this.walletConnectCloudProjectId,privyAppName:this.privyAppName})};i(n),n.filter((e=>r||"walletconnect_solana"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{i(e),e?.filter((e=>r||"walletconnect_solana"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector)})),await t,this.initialized=!0}findWalletConnector(e,t,r){return"wallet_connect_v2"===e?this.walletConnectors.filter(o.isEthereumWalletConnector).find((t=>t.connectorType===e&&(!r||t.wallets.some((e=>e.address===r)))))??null:this.walletConnectors.filter(o.isEthereumWalletConnector).find((n=>n.connectorType===e&&n.walletClientType===t&&(!r||n.wallets.some((e=>e.address===r)))))??null}findSolanaWalletConnector(e){return this.walletConnectors.filter(o.isSolanaWalletConnector).find((t=>"unknown"===t.walletClientType?t.walletBranding.id===e:t.walletClientType===e))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}findImportedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded_imported"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&("solana"===e.type&&"unknown"===t.walletClientType&&"unknown"===e.walletClientType?e.meta.id===t.id:t.walletClientType===e.walletClientType)));t&&(e.connectedAt=t.connectedAt)})),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&this.emit("walletsUpdated")}addEmbeddedWalletConnectors({walletProxy:e,user:t,embeddedWallets:r,defaultChain:n,appId:i,privyClient:a}){let{entropyId:s,entropyIdVerifier:c}=l.getEntropyDetailsForUser(t);for(let t of r){let r=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===t.walletIndex));if(r&&o.isEthereumWalletConnector(r))r.proxyProvider.walletProxy=e;else{let r=new ee({provider:new lr({walletProxy:e,address:t.address,entropyId:s,entropyIdVerifier:c,rpcConfig:this.rpcConfig,chains:this.chains,appId:i,chainId:n.id,walletIndex:t.walletIndex,privyClient:a,walletAccount:t}),chains:this.chains,defaultChain:n,rpcConfig:this.rpcConfig,imported:!1,walletIndex:t.walletIndex});this.addWalletConnector(r)}}}addImportedWalletConnector(e,t,r,n){let i=this.findWalletConnector("embedded_imported","privy",t);if(i&&o.isEthereumWalletConnector(i))i.proxyProvider.walletProxy=e;else{let i=new ee({provider:new lr({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:n,chainId:r.id}),chains:this.chains,walletIndex:0,defaultChain:r,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(i)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.storedConnections=d.loadConnectionHistory(),this.emit("walletsUpdated")}removeImportedWalletConnectors(){let e=this.findImportedWalletConnectors();e.length&&(e.forEach((e=>{let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1)})),this.storedConnections=d.loadConnectionHistory(),this.emit("walletsUpdated"))}async createEthereumWalletConnector({connectorType:e,walletClientType:t,providers:r,walletConfig:n}){let i=this.findWalletConnector(e,t);if(i&&o.isEthereumWalletConnector(i))return i instanceof at&&i.resetConnection(t),i;let a=(()=>"injected"!==e?"coinbase_wallet"===e?new Z(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.coinbaseWallet.config):"base_account"===e?new J(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.baseAccount.config,this.setBaseAccountSdk):"null"!==e?new at({walletConnectCloudProjectId:this.walletConnectCloudProjectId,rpcConfig:this.rpcConfig,chains:this.chains,defaultChain:this.defaultChain,shouldEnforceDefaultChainOnConnect:this.shouldEnforceDefaultChainOnConnect,privyAppId:this.privyAppId,privyAppName:this.privyAppName,walletClientType:t}):n?new o.EthereumNullConnector({id:n.client,name:n.name,defaultChain:this.defaultChain,walletClientType:n.client}):null:"metamask"===t&&r?.eip6963InjectedProvider?new mr(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,"metamask"):"metamask"===t&&r?.legacyInjectedProvider?new wr(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"metamask"):"phantom"===t&&r?.legacyInjectedProvider?new wr(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"phantom"):r?.legacyInjectedProvider&&"unknown_browser_extension"===t?new wr(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider):r?.eip6963InjectedProvider?new pr(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,t):void 0)();return a&&this.addWalletConnector(a),a||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}setWalletList(e){this.walletList=e,this.initialized&&this.initialize(!0).catch(console.error)}removeAllConnectors(){for(let e of this.walletConnectors)e.removeAllListeners();this.walletConnectors=[]}constructor(e,t,r,n,i,a,s,o,l,c,u,h){super(),this.addSolanaWalletConnector=async e=>{let t=this.findSolanaWalletConnector(e.walletClientType);if(!t||"null"===t.connectorType){if("null"===t?.connectorType){let e=this.walletConnectors.indexOf(t);this.walletConnectors.splice(e,1)}this.addWalletConnector(e)}},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=r,this.chains=n,this.defaultChain=i,this.walletConnectors=[],this.initialized=!1,this.store=a,this.walletList=s,this.shouldEnforceDefaultChainOnConnect=o,this.externalWalletConfig=l,this.privyAppName=c,this.walletChainType=h||"ethereum-only",this.setBaseAccountSdk=u,this.storedConnections=d.loadConnectionHistory()}}const vr=P.create((()=>({identityToken:null})));let fr=[v.sessionsRefreshPath,v.sessionsLogoutPath,v.analyticsEventsPath];class Er{async get(e,t){try{return await this.baseFetch(e,t)}catch(e){throw c.formatApiError(e)}}async post(e,t,r){try{return await this.baseFetch(e,{method:"POST",...t?{body:t}:{},...r})}catch(e){throw c.formatApiError(e)}}async delete(e,t){try{return await this.baseFetch(e,{method:"DELETE",...t})}catch(e){throw c.formatApiError(e)}}constructor({appId:e,appClientId:t,client:r,defaults:n}){this.appId=e,this.appClientId=t,this.clientAnalyticsId=r.clientAnalyticsId,this.sdkVersion=p.VERSION,this.client=r,this.defaults=n,this.fallbackApiUrl=r.fallbackApiUrl,this.baseFetch=I.ofetch.create({baseURL:this.defaults.baseURL,timeout:this.defaults.timeout,retry:3,retryDelay:500,retryStatusCodes:[408,409,425,500,502,503,504],credentials:"include",onRequest:async({request:e,options:t})=>{let r=new Headers(t.headers);r.set("privy-app-id",this.appId),this.appClientId&&r.set("privy-client-id",this.appClientId),r.set("privy-ca-id",this.clientAnalyticsId||""),r.set("privy-client",`react-auth:${this.sdkVersion}`);let n=fr.includes(e.toString());if(!r.has("authorization")){let e=await this.client.getAccessToken({disableAutoRefresh:n});null!==e&&r.set("authorization",`Bearer ${e}`)}t.headers=r,t.retryDelay&&"number"==typeof t.retryDelay&&(t.retryDelay=3*t.retryDelay)},onRequestError:({error:e})=>{if(e instanceof DOMException&&"AbortError"===e.name)throw new c.PrivyTimeoutError}})}}const Cr=e=>({rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification});class Ar{getOrCreateGuestCredential(e){let t=p.getGuestCredentialStorageKey(e);if(d.e()){if(d.u.get(t))return d.u.get(t);{let e=i.base64url.encode(he(32));return d.u.put(t,e),e}}return i.base64url.encode(he(32))}async authenticate(){if(!this.api)throw new c.PrivyClientError("Auth flow has no API instance");try{return await this.api.post(v.guestAccountAuthenticatePath,{guest_credential:this.meta.guestCredential})}catch(e){throw c.formatApiError(e)}}async link(){throw Error("Linking is not supported for the guest flow")}constructor(e){this.meta={guestCredential:this.getOrCreateGuestCredential(e)}}}function Pr(){return!(w.isSafari&&window.location.origin.startsWith("http://localhost"))}var Tr,kr=((Tr={}).PRIVY="privy_access_token",Tr.CUSTOMER="customer_access_token",Tr);class _r{get token(){return this.privyAccessToken||this.customerAccessToken}getToken(e){return"privy_access_token"===e?this.privyAccessToken:this.customerAccessToken}get customerAccessToken(){return this._getToken(p.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY)}get privyAccessToken(){return this._getToken(p.PRIVY_ACCESS_TOKEN_STORAGE_KEY)}_getToken(e){try{let t=d.u.get(e);return"string"==typeof t?H.throwIfNotWellFormedJwt(t):null}catch(e){return console.error(e),this.destroyLocalState(),null}}get refreshToken(){try{let e=d.u.get(p.REFRESH_TOKEN_STORAGE_KEY);return"string"==typeof e?e:null}catch(e){return console.error(e),this.destroyLocalState(),null}}getProviderAccessToken(e){try{let t=d.u.get(p.getProviderAccessTokenStorageKey(e));if("string"!=typeof t)return null;{let r=new H(t);return r.isExpired()?(d.u.del(p.getProviderAccessTokenStorageKey(e)),null):r.value}}catch(e){return console.error(e),null}}get mightHaveServerCookies(){try{let e=K.default.get(p.SESSION_COOKIE_KEY);return void 0!==e&&e.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e="privy_access_token"){let t="string"==typeof this.getToken(e),r="string"==typeof this.refreshToken&&this.refreshToken!==p.DEPRECATED_REFRESH_TOKEN;return this.mightHaveServerCookies||t&&r}hasActiveAccessToken(e){let t=H.parse(this.getToken(e));return null!==t&&!t.isExpired(30)}authenticate(e){return this.authenticateOnce.execute(e)}link(e){return this.linkOnce.execute(e)}refresh(){return this.refreshOnce.execute()}destroy(){return this.destroyOnce.execute()}storeProviderAccessToken(e,t){"string"==typeof t?d.u.put(p.getProviderAccessTokenStorageKey(e),t):d.u.del(p.getProviderAccessTokenStorageKey(e))}updateIdentityToken(e){"string"==typeof e?this.storeIdentityToken(e):this.clearIdentityToken()}async _authenticate(e){try{let t=await e.authenticate(),{user:r,is_new_user:n,oauth_tokens:i}=t;this.handleTokenResponse(t);let s=i?{provider:i.provider,accessToken:i.access_token,accessTokenExpiresInSeconds:i.access_token_expires_in_seconds,refreshToken:i.refresh_token,refreshTokenExpiresInSeconds:i.refresh_token_expires_in_seconds,scopes:i.scopes}:void 0;return this._trackAuthenticateEvents(e,n),{user:a.convertUserResponseToUser(r),isNewUser:n,oAuthTokens:s}}catch(e){throw console.warn("Error authenticating session"),c.formatPrivyError(e)}}_trackAuthenticateEvents(e,t){let r=function(e){return e instanceof ie?"email":e instanceof Pe?"sms":e instanceof Ce?"siwe":e instanceof Ar?"guest":e instanceof Ht?"custom_auth":e instanceof me?e.meta.provider:null}(e);r&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate",payload:{method:r,isNewUser:t}}),"siwe"===r&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate_siwe",payload:{connectorType:e.meta.connectorType,walletClientType:e.meta.walletClientType}})}async _link(e){try{let t=await e.link(),r=t.oauth_tokens,n=r?{provider:r.provider,accessToken:r.access_token,accessTokenExpiresInSeconds:r.access_token_expires_in_seconds,refreshToken:r.refresh_token,refreshTokenExpiresInSeconds:r.refresh_token_expires_in_seconds,scopes:r.scopes}:void 0;return{user:a.convertUserResponseToUser(t),oAuthTokens:n}}catch(e){throw console.warn("Error linking account"),c.formatPrivyError(e)}}async _refresh(){if(!this.api)throw new c.PrivyClientError("Session has no API instance");if(!this.client)throw new c.PrivyClientError("Session has no PrivyClient instance");await this.client.getAccessToken({disableAutoRefresh:!0});let e=this.token,t=this.refreshToken;if(this.client.useServerCookies&&!this.mightHaveServerCookies&&this.token&&window.location.origin===this.client.apiUrl)return this.destroyLocalState(),null;try{let r;if(!(e&&t||this.mightHaveServerCookies))return null;{let n={};e&&(n.authorization=`Bearer ${e}`),r=await this.api.post(v.sessionsRefreshPath,t?{refresh_token:t}:{},{headers:n})}return this.handleTokenResponse(r),a.convertUserResponseToUser(r.user)}catch(e){if(e instanceof c.PrivyApiError&&e.privyErrorCode===c.PrivyErrorCode.MISSING_OR_INVALID_TOKEN)return console.warn("Unable to refresh tokens - token is missing or no longer valid"),this.destroyLocalState(),null;throw c.formatPrivyError(e)}}handleTokenResponse(e){e.session_update_action&&"set"!==e.session_update_action?"clear"===e.session_update_action?this.destroyLocalState():"ignore"===e.session_update_action&&(e.token&&(this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token)),e.identity_token&&this.storeIdentityToken(e.identity_token)):this._storeAllTokens(e)}_storeAllTokens(e){this.storeRefreshToken(e.refresh_token),this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),e.identity_token&&this.storeIdentityToken(e.identity_token)}async _destroy(){try{await(this.api?.post(v.sessionsLogoutPath,{refresh_token:this.refreshToken}))}catch(e){console.warn("Error destroying session")}this.destroyLocalState()}destroyLocalState(){this.storeRefreshToken(null),this.storeCustomerAccessToken(null),this.storePrivyAccessToken(null),this.clearIdentityToken()}storeCustomerAccessToken(e){if("string"==typeof e){let t=d.u.get(p.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY);if(d.u.put(p.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY,e),!this.client?.useServerCookies){let t=H.parse(e)?.expiration;K.default.set(p.CUSTOMER_ACCESS_TOKEN_COOKIE_KEY,e,{sameSite:"Strict",secure:Pr(),expires:t?new Date(1e3*t):void 0})}t!==e&&this.client?.onStoreCustomerAccessToken?.(e)}else d.u.del(p.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY),K.default.remove(p.CUSTOMER_ACCESS_TOKEN_COOKIE_KEY),this.client?.onDeleteCustomerAccessToken?.()}storeRefreshToken(e){"string"==typeof e?(d.u.put(p.REFRESH_TOKEN_STORAGE_KEY,e),this.client?.useServerCookies||K.default.set(p.SESSION_COOKIE_KEY,"t",{sameSite:"Strict",secure:Pr(),expires:30})):(d.u.del(p.REFRESH_TOKEN_STORAGE_KEY),K.default.remove(p.REFRESH_TOKEN_COOKIE_KEY),K.default.remove(p.SESSION_COOKIE_KEY))}storePrivyAccessToken(e){"string"==typeof e?d.u.put(p.PRIVY_ACCESS_TOKEN_STORAGE_KEY,e):d.u.del(p.PRIVY_ACCESS_TOKEN_STORAGE_KEY)}storeIdentityToken(e){if(vr.setState({identityToken:e}),this.client?.useServerCookies)return;d.u.put(p.IDENTITY_TOKEN_STORAGE_KEY,e);let t=H.parse(e)?.expiration;K.default.set(p.IDENTITY_TOKEN_COOKIE_KEY,e,{sameSite:"Strict",secure:Pr(),expires:t?new Date(1e3*t):void 0})}clearIdentityToken(){d.u.del(p.IDENTITY_TOKEN_STORAGE_KEY),vr.setState({identityToken:null}),K.default.remove(p.IDENTITY_TOKEN_COOKIE_KEY)}constructor(){this.authenticateOnce=new se((async e=>this._authenticate(e))),this.linkOnce=new se((async e=>this._link(e))),this.refreshOnce=new se(this._refresh.bind(this)),this.destroyOnce=new se(this._destroy.bind(this))}}let Sr,br;var Ir=0,Wr="__private_"+Ir+++"__getOrGenerateClientAnalyticsId";class Ur{getAppId(){return this.appId}initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:r,defaultChain:n,store:i,walletList:a,shouldEnforceDefaultChainOnConnect:s,externalWalletConfig:o,appName:l,walletChainType:c,setBaseAccountSdk:d}){this.connectors||(this.connectors=new gr(this.appId,e,t,r,n,i,a,s,o,l,d,c))}generateApi(){let e=new Er({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new c.PrivyClientError("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new c.PrivyClientError("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(v.mfaPasswordlessSmsInitPath,{action:"verify"})}catch(e){throw c.formatApiError(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(v.mfaPasskeyInitPath,{});return Cr(e.options)}catch(e){throw c.formatApiError(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(v.acceptTermsPath,{});return a.convertUserResponseToUser(e)}catch(e){throw c.formatPrivyError(e)}}async unlinkEmail(e){try{let t=await this.api.post(v.unlinkEmailPath,{address:e});return await this.getAuthenticatedUser()??a.convertUserResponseToUser(t)}catch(e){throw c.formatPrivyError(e)}}async unlinkPhone(e){try{let t=await this.api.post(v.unlinkPhonePath,{phoneNumber:e});return await this.getAuthenticatedUser()??a.convertUserResponseToUser(t)}catch(e){throw c.formatPrivyError(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(v.unlinkWalletPath,{address:e});return await this.getAuthenticatedUser()??a.convertUserResponseToUser(t)}catch(e){throw c.formatPrivyError(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(v.siwsUnlinkWalletPath,{address:e});return await this.getAuthenticatedUser()??a.convertUserResponseToUser(t)}catch(e){throw c.formatPrivyError(e)}}async unlinkOAuth(e,t){try{let r=await this.api.post(v.unlinkOAuthPath,{provider:e,subject:t});return await this.getAuthenticatedUser()??a.convertUserResponseToUser(r)}catch(e){throw c.formatPrivyError(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(v.unlinkFarcasterPath,{fid:e});return await this.getAuthenticatedUser()??a.convertUserResponseToUser(t)}catch(e){throw c.formatPrivyError(e)}}async unlinkTelegram(e){try{let t=await this.api.post(v.telegramAccountUnlinkPath,{telegram_user_id:e});return await this.getAuthenticatedUser()??a.convertUserResponseToUser(t)}catch(e){throw c.formatPrivyError(e)}}async revokeDelegatedWallet(){try{await this.api.post(v.delegatedActionsRevokePath,{})}catch(e){throw c.formatPrivyError(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:r,options:n}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(v.analyticsEventsPath,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:r?r.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:n?.keepAlive??!1})}catch(e){console.log("Unable to submit event. This is not an issue.")}}async signMoonpayOnRampUrl(e){try{return this.api.post(v.moonpayPluginOnRampPath,e)}catch(e){throw c.formatPrivyError(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(v.coinbaseOnRampInitPath,e)}catch(e){throw c.formatPrivyError(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${v.coinbaseOnRampStatusPath}?partnerUserId=${e}`)}catch(e){throw c.formatPrivyError(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(kr.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(kr.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?V.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async getSplTokenMetadata({mintAddress:e,cluster:t}){try{return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${t}`)}catch(r){return void console.error(`Unable to fetch token metadata for ${t}:${e}`)}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(v.siweInitPath,{address:e,token:t})).nonce}catch(e){throw c.formatPrivyError(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:n,connectorType:i,mode:a}){return await this.api.post(v.siweAuthenticatePath,{message:e,signature:t,chainId:r,walletClientType:n,connectorType:i,mode:a})}async linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:n,connectorType:i}){return await this.api.post(v.siweLinkPath,{message:e,signature:t,chainId:r,walletClientType:n,connectorType:i})}async linkSmartWallet({message:e,signature:t,smartWalletType:r,smartWalletVersion:n}){try{let i=await this.api.post(v.smartWalletLinkPath,{message:e,signature:t,smart_wallet_type:r,smart_wallet_version:n});return a.convertUserResponseToUser(i)}catch(e){throw c.formatPrivyError(e)}}async linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:n,connectorType:i}){try{let s=await this.linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:n,connectorType:i});return a.convertUserResponseToUser(s)}catch(e){throw c.formatPrivyError(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(v.siwsInitPath,{address:e,token:t})).nonce}catch(e){throw c.formatPrivyError(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:n,mode:i,messageType:a="plain"}){return await this.api.post(v.siwsAuthenticatePath,{message:e,signature:t,walletClientType:r,connectorType:n,mode:i,message_type:a})}async authenticateWithSiws({message:e,signature:t,walletClientType:r,connectorType:n,mode:i,messageType:s="plain"}){let o=await this.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:n,mode:i,messageType:s});this.session.handleTokenResponse(o);let l=a.convertUserResponseToUser(o.user);if(!l)throw Error("Authentication failed - no user returned");return{user:l,isNewUser:o.is_new_user||!1}}async sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:n,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l}){try{let c,d;switch(r){case"email":c=v.transferEmailPath,d={nonce:e,email:t};break;case"sms":c=v.transferPhonePath,d={nonce:e,phoneNumber:t};break;case"siwe":if(c=v.transferWalletPath,!n)throw Error("Wallet parameters must be defined");d={nonce:e,address:t,...n};break;case"farcaster":c=v.transferFarcasterPath,d={nonce:e,farcaster_id:t,farcaster_embedded_address:o};break;case"telegram":c=v.telegramAccountTransferPath,d={nonce:e,telegram_auth_result:i,telegram_web_app_data:s};break;case"siws":c=v.siwsTransferPath,d={nonce:e,address:t,...n};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:c=v.transferOAuthPath,d={nonce:e,userInfo:l}}let u=await this.api.post(c,d);return await this.getAuthenticatedUser()??a.convertUserResponseToUser(u)}catch(e){throw c.formatPrivyError(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:n,messageType:i="plain"}){return await this.api.post(v.siwsLinkPath,{message:e,signature:t,walletClientType:r,connectorType:n,message_type:i})}async linkWithSiws({message:e,signature:t,walletClientType:r,connectorType:n,messageType:i="plain"}){try{let s=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:n,messageType:i});return a.convertUserResponseToUser(s)}catch(e){throw c.formatPrivyError(e)}}async updateUserAndIdToken(){try{let e=await this.api.get(v.usersMePath);return this.session.updateIdentityToken(e.identity_token),a.convertUserResponseToUser(e.user)}catch(e){throw c.formatPrivyError(e)}}async scanTransaction(e){try{return await this.api.post(v.transactionScanningPath,e)}catch(e){throw c.formatPrivyError(e)}}constructor({apiUrl:e=p.DEFAULT_PRIVY_API_URL,appId:t,appClientId:r,timeout:n=p.DEFAULT_API_TIMEOUT_MS}){Object.defineProperty(this,Wr,{value:xr}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==p.DEFAULT_PRIVY_API_URL&&e.startsWith("https://privy."),this.timeout=n,this.appId=t,this.appClientId=r,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Wr)[Wr](),Sr||(Sr=new _r),this.session=Sr,this.api=this.generateApi(),this.session.client=this}}function xr(){if("undefined"==typeof window)return null;try{let e=d.u.get(p.CLIENT_ANALYTICS_ID_KEY);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=n.v4();try{return d.u.put(p.CLIENT_ANALYTICS_ID_KEY,e),e}catch(t){return e}}function Rr(){if(!br)throw new c.PrivyClientError("No global PrivyClient instance found. Please ensure you have initialized the PrivyProvider.");return br}const Or=()=>{let{setModalData:e}=a.usePrivyModal(),{openModal:r,privy:n,closePrivyModal:i}=c.usePrivyInternal(),{user:s}=a.usePrivyContext();return t.useMemo((()=>({verify:async({standalone:t=!0}={standalone:!0})=>new Promise(((a,o)=>s?0===s.mfaMethods.length?a():(e((e=>({...e,mfaVerify:{onSuccess:async()=>{t?await i({shouldCallAuthOnSuccess:!1,isSuccess:!0}):De.setState({inProgressMfaFlow:void 0}),a()},onFailure:async e=>{t?await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}):De.setState({inProgressMfaFlow:void 0}),o(e)},sendSmsCode:async()=>{throw Error("Not enabled")},verifySmsCode:async()=>{throw Error("Not enabled")},verifyTotpCode:async e=>{await n.fetchPrivyRoute(x.MfaAuthTotpVerify,{body:{code:e}})},generateOptions:async()=>Cr((await n.fetchPrivyRoute(x.MfaAuthPasskeyInit,{body:{}})).options),verifyPasskey:async e=>{let t=await import("@simplewebauthn/browser"),r=await t.startAuthentication({optionsJSON:e});await n.fetchPrivyRoute(x.MfaAuthPasskeyVerify,{body:{authenticator_response:qt(r)}})}}}))),void(t?r("MfaAuthVerifyFlowScreen"):De.setState({inProgressMfaFlow:"auth"}))):o(Error("Must be logged in to verify MFA"))))})),[n,e,r,i])};const Nr=async({wallet:e})=>{let t=await e.getEthereumProvider();return N.toAccount({address:e.address,sign:async({hash:n})=>{if("privy"!==e.walletClientType)throw new r.PrivyClientError({error:"Unprefixed signing is not supported by external wallets.",code:"unsupported_wallet_type"});return await t.request({method:"secp256k1_sign",params:[n]})},signMessage:async({message:r})=>await t.request({method:"personal_sign",params:[r,e.address]}),signTypedData:async r=>await t.request({method:"eth_signTypedData_v4",params:[e.address,r]}),signTransaction:async e=>await t.request({method:"eth_signTransaction",params:[e]})})};let Mr=async(e,t,r,n,i)=>{if(!e)throw n("linkAccount","onError",c.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:i}),new c.PrivyClientError("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(i))))throw new c.PrivyClientError(`OAuth account of type ${i} not linked to the account.`);await r(i)};const Fr=()=>{let{user:e}=a.usePrivyContext(),t=c.usePrivyInternal(),{signWithUserSigner:n}=M.useSignWithUserSigner(),i=async({wallet:i,additional_signers:a})=>{let s=await t.client.getAccessToken();if(!e||!s)throw new c.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if(!i.id)throw new c.PrivyClientError("Wallet to add signers to must have ID on server");if(!t.walletProxy)throw new c.PrivyClientError("Wallet proxy not initialized.");await r.updateWallet(t.privy,{wallet_id:i.id},n,{additional_signers:a})};return{addSessionSignersInternal:async({address:n,signers:s})=>{let l=await t.client.getAccessToken();if(!e||!l)throw new c.PrivyClientError("User must be authenticated and have an embedded wallet to add a session signer.");let d=t.walletProxy??await t.initializeWalletProxy(15e3);if(!d)throw new c.PrivyClientError("Wallet proxy not initialized.");let u=a.getPrivyWalletWithAddress(e,n);if(!u)throw new c.PrivyClientError("Address to add signers too is not associated with current user.");if(a.getIsUnifiedWallet(u)){if(0===s.length)throw new c.PrivyClientError("Must specify at least one signer to add.");let e=[...(await r.getWallet(t.privy,{wallet_id:u.id})).additional_signers,...o.parseAdditionalSigners(s)];await i({wallet:u,additional_signers:e})}else{if(u.delegated)return{user:e};if(s.length>0)throw new c.PrivyClientError("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let r=ft({address:n,user:e}),i=Et({address:n,user:e});await t.recoverEmbeddedWallet({address:n}),await d.createDelegatedAction({accessToken:l,rootWallet:i,delegatedWallets:[r]})}let h=await t.refreshSessionAndUser();if(!h)throw Error("Could not refresh user");return{user:h}},removeSessionSignersInternal:async({address:r})=>{let n=await t.client.getAccessToken();if(!e||!n)throw new c.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if(!(t.walletProxy??await t.initializeWalletProxy(15e3)))throw new c.PrivyClientError("Wallet proxy not initialized.");let s=a.getPrivyWalletWithAddress(e,r);if(!s)throw new c.PrivyClientError("Address to remove signers from is not associated with current user.");a.getIsUnifiedWallet(s)?await i({wallet:s,additional_signers:[]}):await t.client.revokeDelegatedWallet();let o=await t.refreshSessionAndUser();if(!o)throw Error("Could not refresh user");return{user:o}}}},Dr=Xe;exports.BASE_ACCOUNT_DATA_URI=Y,exports.Blobby=X,exports.BrowserExtensionWallet=cr,exports.COINBASE_WALLET_DATA_URI=B,exports.Captcha=Ne,exports.CaptchaError=_e,exports.CoinbaseWallet=({style:t,...r})=>/*#__PURE__*/e.jsxs("svg",{viewBox:"0 0 1024 1024",fill:"none",xmlns:"http://www.w3.org/2000/svg",style:{height:"28px",width:"28px",...t},...r,children:[/*#__PURE__*/e.jsx("rect",{width:"1024",height:"1024",fill:"#0052FF",rx:100,ry:100}),/*#__PURE__*/e.jsx("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z",fill:"white"})]}),exports.ConnectorManager=gr,exports.LoginModal=Dr,exports.Phantom=dr,exports.PrivyClient=Ur,exports.PrivyIframeError=ot,exports.PrivyModal=Xe,exports.PrivyProvider=({config:r,...n})=>{(()=>{if(t.useContext(Xt))throw new c.PrivyClientError("Multiple PrivyProvider instances found","Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree.")})(),function(){if("undefined"==typeof window)return;let e=["localhost","127.0.0.1"].includes(window.location.hostname),t="https:"===window.location.protocol||"chrome-extension:"===window.location.protocol;if(!e&&!t)throw new c.PrivyClientError("Embedded wallet is only available over HTTPS")}(),function(e){if("string"!=typeof e||25!==e.length)throw new c.PrivyClientError("Cannot initialize the Privy provider with an invalid Privy app ID")}(n.appId),function(e){br||(br=new Ur({appId:e.appId,appClientId:e.clientId,apiUrl:e.apiUrl}))}(n);let i=t.useMemo((()=>new j.default({appId:n.appId,clientId:n.clientId,storage:d.u,baseUrl:n.apiUrl,sdkVersion:"react-auth:3.12.0"})),[]),a=Rr(),s=Object.assign({},r);/*#__PURE__*/return e.jsx(p.PrivyAppConfigProvider,{client:i,legacyClient:a,appClientId:n.clientId,clientConfig:s,children:/*#__PURE__*/e.jsx(f.PrivyPluginProvider,{children:/*#__PURE__*/e.jsx(ar,{...n,client:a,privy:i})})})},exports.RunEffectOnce=se,exports.SiweFlow=Ce,exports.SiwsFlow=Ae,exports.WalletConnectV2WalletConnector=at,exports.addFundingResultToModalData=function(e,t,r,n,i,a,s){return{...e,funding:e?.funding?{...e.funding,fundingResult:{status:t,address:e.funding.address,fundingMethod:void 0,transactionHash:r,amount:e.funding.amount,assetType:i?a?.symbol||"ETH":s.nativeCurrency.symbol||"ETH",metadata:{walletClientType:n}}}:void 0,solanaFundingData:e?.solanaFundingData,sendTransaction:e?.sendTransaction}},exports.createCodeVerifier=pe,exports.createStateCode=ye,exports.deriveCodeChallengeFromCodeVerifier=we,exports.e=Ot,exports.embeddedWalletRecoveryScreen=Ut,exports.embeddedWalletSetPasswordScreen=It,exports.errorIndicatesInvalidRecoveryPassword=function(e){return lt(e)&&("invalid_recovery_pin"===e.type||"invalid_request_arguments"===e.type)},exports.errorIndicatesMaxMfaRetries=function(e){return!!lt(e)&&"mfa_verification_max_attempts_reached"===e.type},exports.errorIndicatesMfaCanceled=function(e){return!!function(e){let t=e.type;return"string"==typeof t&&"client_error"===t}(e)&&"MFA canceled"===e.message},exports.errorIndicatesMfaRateLimit=function(e){return!(!lt(e)||!e.message.includes("code 429"))},exports.errorIndicatesMfaTimeout=function(e){return!!lt(e)&&"mfa_timeout"===e.type},exports.errorIndicatesMfaVerificationFailed=function(e){return!!lt(e)&&"missing_or_invalid_mfa"===e.type},exports.errorIndicatesRecoveryIsNeeded=ct,exports.fetchWalletBalance=Nt,exports.getCustomerAccessToken=function(){let e=Rr();return e?e.getCustomerAccessToken():Promise.resolve(d.u.get(p.CUSTOMER_ACCESS_TOKEN_STORAGE_KEY)||null)},exports.getIdentityToken=async function(){return await(br?.updateUserAndIdToken()),br?.useServerCookies?vr.getState().identityToken:Promise.resolve(d.u.get(p.IDENTITY_TOKEN_STORAGE_KEY)||null)},exports.getTelegramAuthErrorMessage=function(e){let t={detail:"",retryable:!1};return e?.privyErrorCode===c.PrivyErrorCode.LINKED_TO_ANOTHER_USER&&(t.detail="This account has already been linked to another user."),e?.privyErrorCode===c.PrivyErrorCode.DISALLOWED_LOGIN_METHOD&&(t.detail="Login with Telegram not allowed."),e?.privyErrorCode===c.PrivyErrorCode.INVALID_DATA&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===c.PrivyErrorCode.CANNOT_LINK_MORE_OF_TYPE&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===c.PrivyErrorCode.INVALID_CREDENTIALS&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===c.PrivyErrorCode.TOO_MANY_REQUESTS&&(t.detail="Too many requests. Please wait before trying again."),e?.privyErrorCode===c.PrivyErrorCode.TOO_MANY_REQUESTS&&e.message.includes("rate limit")&&(t.detail="Request limit reached for Telegram. Please wait a moment and try again."),e instanceof _e&&(t.retryable=!0,t.detail="Something went wrong. Try again."),t},exports.prepareTransactionRequest=Dt,exports.shouldCreateEmbeddedEthWallet=Vt,exports.shouldCreateEmbeddedSolWallet=Yt,exports.stripUrlOAuthParamsAndRemoveStateCode=ve,exports.toDisplayFromAccountType=Ft,exports.toEmbeddedWalletSetRecoveryScreen=Wt,exports.toViemAccount=Nr,exports.useAuthMfa=Or,exports.useAuthMfaEnrollment=()=>{let e=p.useAppConfig(),{setModalData:r}=a.usePrivyModal(),{verify:n}=Or(),{openModal:i,privy:s,closePrivyModal:o,refreshSessionAndUser:l,setUser:d}=c.usePrivyInternal();return t.useMemo((()=>({enroll:async t=>new Promise(((a,c)=>{r({mfaEnroll:{onSuccess:async e=>{await o({shouldCallAuthOnSuccess:!1,isSuccess:!0}),a(e)},onFailure:async e=>{await o({shouldCallAuthOnSuccess:!1,isSuccess:!1}),c(e)},onBack:t?.onBack?async()=>{await o({shouldCallAuthOnSuccess:!1,isSuccess:!1}),c(Error("User canceled MFA enrollment flow.")),t.onBack?.()}:void 0,verify:()=>n({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:e.mfa.methods,sendSmsCode:async()=>{throw Error("Not enabled")},enrollSms:async()=>{throw Error("Not enabled")},unenrollSms:async()=>{throw Error("Not enabled")},generateTotpSecret:async()=>await s.fetchPrivyRoute(x.MfaAuthTotpInit,{body:{}}),enrollTotp:async e=>{await s.fetchPrivyRoute(x.MfaAuthTotpEnroll,{body:{code:e}});let t=await l();return d(t),t},unenrollTotp:async()=>{await s.fetchPrivyRoute(x.MfaAuthTotpUnenroll,{body:{}});let e=await l();return d(e),e},enrollPasskey:async e=>{await s.fetchPrivyRoute(x.MfaAuthPasskeyEnrollment,{body:{credential_ids:e,remove_for_login:!0}});let t=await l();return d(t),t}}}),i("MfaAuthEnrollmentFlowScreen")}))})),[s,r,i,o])},exports.useAuthorizationSignature=()=>{let{signWithUserSigner:e}=M.useSignWithUserSigner();return t.useMemo((()=>({async generateAuthorizationSignature(t){let{targetAppId:n,...i}=t,{signature:a}=await r.generateAuthorizationSignature((async({message:t})=>e({message:t,targetAppId:n})),i);return{signature:a}}})),[e])},exports.useBaseAccountSdk=()=>{let{baseAccountSdk:e}=c.usePrivyInternal();return{baseAccountSdk:e}},exports.useCaptcha=be,exports.useConnectBaseAccount=()=>{let{connectBaseAccount:e}=c.usePrivyInternal();return{connectBaseAccount:e}},exports.useConnectCoinbaseSmartWallet=()=>{let{connectCoinbaseSmartWallet:e}=c.usePrivyInternal();return{connectCoinbaseSmartWallet:e}},exports.useConnectOrCreateWallet=e=>{let{connectOrCreateWallet:t}=a.usePrivyContext();return A.usePrivyEventSubscription("connectOrCreateWallet",e),{connectOrCreateWallet:t}},exports.useCreateWalletWithoutFallback=$t,exports.useCrossAppAccounts=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:r,signTypedDataWithCrossAppWallet:n,sendTransactionWithCrossAppWallet:i,signTransactionWithCrossAppWallet:s}=a.usePrivyContext();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:"login"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:"link"}),unlinkCrossAppAccount:t,signMessage:r,signTypedData:n,sendTransaction:i,signTransaction:s}},exports.useCustomAuth=e=>{let t=Qt((e=>e.jwtAuthFlowState));return A.usePrivyEventSubscription("customAuth",e),{status:t}},exports.useDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=c.usePrivyInternal();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},exports.useFarcasterSigner=function(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}=a.usePrivyContext();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}},exports.useGetAccessTokenForProvider=()=>t.useMemo((()=>({getAccessTokenForProvider:({appId:e})=>{try{let t=d.u.get(p.getProviderAccessTokenStorageKey(e));if("string"!=typeof t)return{token:null};{let r=new H(t);return r.isExpired()?(d.u.del(p.getProviderAccessTokenStorageKey(e)),{token:null}):{token:r.value}}}catch(e){return console.error(e),{token:null}}}})),[]),exports.useGuestAccounts=function(){let e=p.useAppConfig(),t=A.useEmitPrivyEvent(),{client:r,setUser:n,setAuthenticated:i,setIsNewUser:a,initializeWalletProxy:s}=c.usePrivyInternal(),{create:o}=f.useCreateWalletInternal();return{createGuestAccount:async()=>{if(!e.id||!r)throw Error("SDK not yet ready");r.startAuthFlow(new Ar(e.id));try{let l=await r.authenticate(),d=l.user,u=l.isNewUser??!1;if(!d)throw new c.PrivyClientError("Unable to authenticate guest account");let h=await r.getAccessToken(),y=await s(p.WALLET_PROXY_TIMEOUT);if(h&&y)try{let t=Vt(d,e.embeddedWallets.ethereum.createOnLogin),r=Yt(d,e.embeddedWallets.solana.createOnLogin);t&&r?(d=(await o({chainType:"ethereum",latestUser:d})).user,d=(await o({chainType:"solana",latestUser:d})).user):r?d=(await o({chainType:"solana",latestUser:d})).user:t?d=(await o({chainType:"ethereum",latestUser:d})).user:n(d)}catch(e){n(d),console.warn("Unable to create embedded wallet for guest account")}return a(u),i(!0),t("login","onComplete",{user:d,isNewUser:u,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),d}catch(e){throw t("login","onError",e.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}}},exports.useHeadlessDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=c.usePrivyInternal();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},exports.useIdentityToken=function(){let{identityToken:e}=vr();return{identityToken:e}},exports.useLinkAccount=function(e){let{linkEmail:r,linkPhone:n,linkWallet:i,linkGoogle:s,linkApple:o,linkTwitter:l,linkTwitch:c,linkDiscord:d,linkGithub:u,linkLinkedIn:h,linkTiktok:p,linkLine:y,linkSpotify:w,linkInstagram:m,linkTelegram:g,linkFarcaster:v,linkPasskey:f}=t.useContext(a.PrivyContext);return A.usePrivyEventSubscription("linkAccount",e),{linkEmail:r,linkPhone:n,linkWallet:i,linkGoogle:s,linkApple:o,linkTwitter:l,linkTwitch:c,linkDiscord:d,linkGithub:u,linkLinkedIn:h,linkTiktok:p,linkLine:y,linkSpotify:w,linkInstagram:m,linkFarcaster:v,linkTelegram:g,linkPasskey:f}},exports.useLinkJwtAccount=function(e){let{client:r}=c.usePrivyInternal(),[n,i]=t.useState({status:"initial"});return{linkWithCustomJwt:t.useCallback((async t=>{try{i({status:"initial"}),r.startAuthFlow(new Ht(t)),i({status:"loading"});let{user:n}=await r.link();if(!n)throw Error("Error, user not found");let a=n.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return i({status:"done"}),e?.onSuccess?.({user:n,linkMethod:"custom",linkedAccount:a}),{user:n}}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),t}}),[r.startAuthFlow,r.link]),state:n}},exports.useLinkWithPasskey=e=>{let{initLinkWithPasskey:r,linkWithPasskey:n,passkeyAuthState:i,setPasskeyAuthState:a}=c.usePrivyInternal();return{linkWithPasskey:t.useCallback((async()=>{try{await r();let t=await n();if(!t)throw Error("Error, user not found");let i=t.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:t,linkMethod:"passkey",linkedAccount:i})}catch(t){throw a({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[n]),state:i}},exports.useLinkWithSiwe=e=>{let r=be(),{siweState:n,setSiweState:i,linkWithSiwe:a,generateSiweMessage:s}=c.usePrivyInternal();return{generateSiweMessage:t.useCallback((async({address:t,chainId:r})=>{try{if(!t||!r)throw Error("wallet address and chainId required to generate nonce");return await s({address:t,chainId:r}).then((e=>e))}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[s]),linkWithSiwe:t.useCallback((async({signature:t,message:n,chainId:s,walletClientType:o,connectorType:l})=>{try{if(r.enabled&&"success"!==r.status)throw new _e(r.error,null,c.PrivyErrorCode.CAPTCHA_FAILURE);let{user:i,linkedAccount:d}=await a({message:n,signature:t,chainId:s,walletClientType:o,connectorType:l});d&&e?.onSuccess?.({user:i,linkMethod:"siwe",linkedAccount:d})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[a,r.status]),state:n}},exports.useLinkWithSiws=()=>{let e=be(),{client:r,setUser:n,refreshSessionAndUser:i}=c.usePrivyInternal(),{authenticated:a}=f.usePrivy();return{generateSiwsMessage:t.useCallback((async({address:t})=>{let n=await Ie(e),i=await r.generateSiwsNonce({address:t,captchaToken:n});return f.prepareSiwsMessageWithNonce({address:t,nonce:i})}),[e,r]),linkWithSiws:t.useCallback((async({signature:t,message:s,walletClientType:o,connectorType:l})=>{if(!a)throw Error("User must be authenticated before linking");await Ie(e);let c=await r.linkWithSiws({message:s,signature:t,walletClientType:o,connectorType:l,messageType:"plain"}),d=(e=>{if(!e)return;let t=e.linkedAccounts;return t&&0!==t.length?t[t.length-1]:void 0})(c=await i()??c)||null;return n(c||null),{user:c,linkedAccount:d}}),[a,e,r,i,n])}},exports.useLoginWithEmail=e=>{let r=be(),{emailOtpState:n,setEmailOtpState:i,initLoginWithEmail:a,loginWithCode:s}=c.usePrivyInternal();return{sendCode:t.useCallback((async({email:t,disableSignup:n})=>{try{if(!t)throw Error("Email required to send OTP code");let e=await Ie(r);return await a({email:t,captchaToken:e,disableSignup:n,withPrivyUi:!1})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[a,r]),loginWithCode:t.useCallback((async({code:t})=>{try{let{user:r,isNewUser:n,wasAlreadyAuthenticated:i,linkedAccount:a}=await s(t);e?.onComplete?.({user:r,isNewUser:n,wasAlreadyAuthenticated:i,loginMethod:"email",loginAccount:a})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[s]),state:n}},exports.useLoginWithFarcasterV2=()=>{let{client:e,setAuthenticated:r,setUser:n}=c.usePrivyInternal();return t.useMemo((()=>({init:async()=>{if(!e)throw new c.PrivyClientError("Must initialize Privy client first.");let t=new U.FarcasterFramesFlow;return e.startAuthFlow(t),await t.init()},login:async({fid:t,message:i,signature:a})=>{if(!e)throw new c.PrivyClientError("Must initialize Privy client first.");if(!(e.authFlow instanceof U.FarcasterFramesFlow))throw new c.PrivyClientError("Must initialize Farcaster Mini App flow first.");e.authFlow.setAuthData({message:i,signature:a,fid:t});let{user:s}=await e.authenticate();if(!s)throw new c.PrivyClientError("Failed to login with Farcaster V2");return n(s),r(!0),{user:s}}})),[e,n,r])},exports.useLoginWithOAuth=e=>{A.usePrivyEventSubscription("login",e);let r=be(),n=p.useIsServerConfigLoaded(),{ready:i,user:s}=a.usePrivyContext(),{initLoginWithHeadlessOAuth:o,loginWithHeadlessOAuth:l,oAuthState:d,setOAuthState:u,isHeadlessOAuthLoading:h}=c.usePrivyInternal(),y=t.useCallback((async e=>{try{if(r.enabled&&"success"!==r.status)throw new _e(r.error,null,c.PrivyErrorCode.CAPTCHA_FAILURE);return await o(e.provider,r.token,e.disableSignup)}catch(e){throw u({status:"error",error:e}),e}}),[o,r]),w=t.useCallback((async()=>{let e=ge();try{if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");let t=e.provider;if(a.isCustomOAuthProvider(t)){if(s&&s.linkedAccounts.some((e=>e.type===t)))return console.warn("User is already logged in with this OAuth provider"),s}else if(s&&t in s&&s[t])return console.warn("User is already logged in with this OAuth provider"),s;if(e.popupFlow)return}catch(e){throw u({status:"error",error:e}),e}try{return await l(e)}catch(e){throw u({status:"error",error:e}),e}finally{ve()}}),[l]);return t.useEffect((()=>{let e=ge();i&&n&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&w().catch((()=>{}))}),[i,n]),{initOAuth:y,loading:h,state:d}},exports.useLoginWithPasskey=e=>{let r=be(),{initLoginWithPasskey:n,loginWithPasskey:i,passkeyAuthState:a,setPasskeyAuthState:s}=c.usePrivyInternal();return{loginWithPasskey:t.useCallback((async t=>{try{let a=await Ie(r);await n({captchaToken:a,withPrivyUi:!1});let{user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginAccount:c}=await i(t);e?.onComplete?.({user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(t){throw s({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[i,r]),state:a}},exports.useLoginWithSiwe=e=>{let r=be(),{siweState:n,setSiweState:i,client:a,generateSiweMessage:s,loginWithSiwe:o}=c.usePrivyInternal();return{generateSiweNonce:t.useCallback((async t=>{try{let e=await Ie(r);i({status:"generating-message"});let n=await a.generateSiweNonce({address:t?.address,captchaToken:e});return i({status:"awaiting-signature"}),n}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[a,r]),generateSiweMessage:t.useCallback((async({address:t,chainId:n})=>{try{let e=await Ie(r);return await s({address:t,chainId:n,captchaToken:e})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[s,r]),loginWithSiwe:t.useCallback((async({message:t,signature:n,disableSignup:a,walletClientType:s,connectorType:l})=>{try{let i=await Ie(r),{user:c,isNewUser:d}=await o({message:t,signature:n,captchaToken:i,disableSignup:a,walletClientType:s,connectorType:l});return e?.onComplete?.({user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),c}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[o,r]),state:n}},exports.useLoginWithSiws=()=>{let e=be(),{client:r,setAuthenticated:n,setUser:i,setIsNewUser:a}=c.usePrivyInternal(),{authenticated:s}=f.usePrivy();return{generateSiwsMessage:t.useCallback((async({address:t})=>{let n=await Ie(e),i=await r.generateSiwsNonce({address:t,captchaToken:n});return f.prepareSiwsMessageWithNonce({address:t,nonce:i})}),[e,r]),loginWithSiws:t.useCallback((async({message:e,signature:t,disableSignup:o,walletClientType:l,connectorType:c})=>{if(s)throw Error("User already authenticated");let{user:d,isNewUser:u}=await r.authenticateWithSiws({message:e,signature:t,walletClientType:l,connectorType:c,mode:o?"no-signup":"login-or-sign-up",messageType:"plain"});if(!d)throw Error("Authentication failed - no user returned");return i(d),a(u||!1),n(!0),d}),[s,r,n,i,a])}},exports.useLoginWithSms=e=>{let r=be(),{smsOtpState:n,setSmsOtpState:i,initLoginWithSms:a,loginWithCode:s}=c.usePrivyInternal();return{sendCode:t.useCallback((async({phoneNumber:t,disableSignup:n})=>{try{if(!t)throw Error("SMS required to send OTP code");let e=await Ie(r);return await a({phoneNumber:t,captchaToken:e,disableSignup:n,withPrivyUi:!1})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[a,r]),loginWithCode:t.useCallback((async({code:t})=>{try{let{user:r,isNewUser:n,wasAlreadyAuthenticated:i,linkedAccount:a}=await s(t);e?.onComplete?.({user:r,isNewUser:n,wasAlreadyAuthenticated:i,loginMethod:"sms",loginAccount:a})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[s]),state:n}},exports.useLoginWithTelegram=e=>{let r=be(),{initLoginWithTelegram:n,loginWithTelegram:i,telegramAuthState:a,setTelegramAuthState:s}=c.usePrivyInternal();return{login:t.useCallback((async t=>{try{if(r.enabled&&"success"!==r.status)throw new _e(r.error,null,c.PrivyErrorCode.CAPTCHA_FAILURE);await n(r.token,t?.disableSignup);let{user:a,isNewUser:s,loginAccount:o,wasAlreadyAuthenticated:l}=await i({intent:"login"});e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:l,loginMethod:"telegram",loginAccount:o})}catch(t){throw s({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[n,i,r]),state:a}},exports.useMfa=function(){let{promptMfa:e,init:r,submit:n,cancel:i,mfaMethods:s}=t.useContext(a.PrivyContext);return{promptMfa:e,init:r,submit:n,cancel:i,mfaMethods:s}},exports.useMfaEnrollment=function(){let{initEnrollmentWithSms:e,initEnrollmentWithTotp:r,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:i,submitEnrollmentWithTotp:s,submitEnrollmentWithPasskey:o,unenroll:l,enrollInMfa:c}=t.useContext(a.PrivyContext);return{initEnrollmentWithSms:e,initEnrollmentWithTotp:r,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:i,submitEnrollmentWithTotp:s,submitEnrollmentWithPasskey:o,unenrollWithSms:()=>l("sms"),unenrollWithTotp:()=>l("totp"),unenrollWithPasskey:e=>l("passkey",e),showMfaEnrollmentModal:()=>c(!0),closeMfaEnrollmentModal:()=>c(!1)}},exports.useMigrateWallets=Lt,exports.useModalStatus=()=>{let{isModalOpen:e}=t.useContext(a.PrivyContext);return{isOpen:e}},exports.useOAuthTokens=function(e){let{authenticated:t,user:r}=a.usePrivyContext(),{initLoginWithOAuth:n}=c.usePrivyInternal(),i=A.useEmitPrivyEvent();return A.usePrivyEventSubscription("oAuthAuthorization",e),{reauthorize:e=>Mr(t,r,n,i,e.provider)}},exports.useRecoverEmbeddedWallet=()=>{let{user:e}=a.usePrivyContext(),{walletProxy:r}=c.usePrivyInternal();return{recover:t.useCallback((async t=>{if(!r)throw Error("Wallet proxy is not ready");let n=await te();if(!e||!n)throw new c.PrivyClientError("User must be logged in before attempting to modify the recovery method.");let{entropyId:i,entropyIdVerifier:a}=l.getEntropyDetailsForUser(e);try{await r.recover({entropyId:i,entropyIdVerifier:a,accessToken:n,...t})}catch{throw new c.PrivyClientError("Unable to recover wallets")}}),[r,e])}},exports.useRegisterMfaListener=Fe,exports.useSendTransaction=function(e){let{sendTransaction:r}=t.useContext(a.PrivyContext);return A.usePrivyEventSubscription("sendTransaction",e),{sendTransaction:r}},exports.useSessionSigners=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=Fr();return{addSessionSigners:async({address:t,signers:r})=>e({address:t,signers:r}),removeSessionSigners:async({address:e})=>t({address:e})}},exports.useSetWalletRecovery=function(e){let{setWalletRecovery:r}=t.useContext(a.PrivyContext);return A.usePrivyEventSubscription("setWalletRecovery",e),{setWalletRecovery:r}},exports.useSign7702Authorization=()=>{let{ready:e,wallets:r}=l.useWallets(),{user:n}=a.usePrivyContext(),{rpcConfig:i,chains:s,appId:o}=c.usePrivyInternal();return{signAuthorization:t.useCallback((async(t,l)=>{let c;if(!n)throw Error("User must be authenticated before signing with a Privy wallet");if(!e)throw Error("Wallets are not ready");let d=l?.address??a.getPrivyEthereumWallet(n)?.address??S.zeroAddress,u=r.find((e=>S.getAddress(e.address)===S.getAddress(d)));if(!u)throw Error("Signing wallet not found.");let h=t.chainId??Number(u.chainId.split(":")[1]);if(0===h)c={chainId:0,address:t.contractAddress,nonce:t.nonce??0};else{let e=s.find((e=>e.id===h));if(!e)throw Error("Error, chain not configured in PrivyProvider config");let r=S.createWalletClient({account:d,chain:e,transport:S.http(b.getJsonRpcEndpointFromChain(e,i,o))});c=await r.prepareAuthorization({...t})}let p=await u.getEthereumProvider(),y=await p.request({method:"secp256k1_sign",params:[m.hashAuthorization(c)]});return{...c,...S.parseSignature(y)}}),[e,r,n,s])}},exports.useSignMessage=function(e){let{signMessage:r}=t.useContext(a.PrivyContext);return A.usePrivyEventSubscription("signMessage",e),{signMessage:r}},exports.useSignTransaction=function(){let{signTransaction:e}=t.useContext(a.PrivyContext);return{signTransaction:e}},exports.useSignTypedData=function(e){let{signTypedData:r}=t.useContext(a.PrivyContext);return A.usePrivyEventSubscription("signTypedData",e),{signTypedData:r}},exports.useSigners=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=Fr();return{addSigners:async({address:t,signers:r})=>e({address:t,signers:r}),removeSigners:async({address:e})=>t({address:e})}},exports.useSignupWithPasskey=e=>{let r=be(),{initSignupWithPasskey:n,signupWithPasskey:i,passkeyAuthState:a,setPasskeyAuthState:s}=c.usePrivyInternal();return{signupWithPasskey:t.useCallback((async()=>{try{let t=await Ie(r);await n({captchaToken:t,withPrivyUi:!1});let{user:a,isNewUser:s,wasAlreadyAuthenticated:o,loginAccount:l}=await i();e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:o,loginMethod:"passkey",loginAccount:l})}catch(t){throw s({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR),t}}),[i,r]),state:a}},exports.useSubscribeToJwtAuthWithFlag=function({isAuthenticated:e,isLoading:r,...n}){let i=t.useRef();t.useEffect((()=>{r||i.current?.()}),[e,r]);let a=t.useCallback((e=>(i.current=e,()=>{i.current=void 0})),[]);return Jt({...n,subscribe:a})},exports.useSyncJwtBasedAuthState=Jt,exports.useToken=function(e){let{getAccessToken:r}=t.useContext(a.PrivyContext);return A.usePrivyEventSubscription("accessToken",e),{getAccessToken:r}},exports.useUpdateAccount=function(e){let{updateEmail:r,updatePhone:n}=t.useContext(a.PrivyContext);return A.usePrivyEventSubscription("update",e),{updateEmail:r,updatePhone:n}},exports.useUpdateEmail=e=>{let{user:r}=a.usePrivyContext(),{loginWithCode:n,emailOtpState:i,setEmailOtpState:s,client:o,inProgressAuthFlowRef:l,inProgressLoginOrLinkMethodRef:d}=c.usePrivyInternal();return{state:i,sendCode:t.useCallback((async({newEmailAddress:t})=>{try{if(!r?.email)throw Error("User is required to have an email address to update it.");let e=new ae(r.email.address,t);o.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(t){s({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[r?.email]),verifyCode:t.useCallback((async({code:t})=>{try{if(!r?.email)throw Error("User is required to have an email address to update it.");l.current="update",d.current="email";let{user:i,linkedAccount:a}=await n(t);return e?.onSuccess?.({user:i,updateMethod:"email",updatedAccount:a}),{user:i}}catch(t){s({status:"error",error:t}),e?.onError?.(t.privyErrorCode||c.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[r?.email])}},exports.useUser=()=>{let{setUser:e,client:r}=t.useContext(c.InternalPrivyContext),{user:n}=t.useContext(a.PrivyContext);return{user:n,refreshUser:t.useCallback((async()=>{let t=await(r?.updateUserAndIdToken());return e(t??null),t}),[r,e])}},exports.useX402Fetch=()=>{let{wallets:e}=l.useWallets();return t.useMemo((()=>({wrapFetchWithPayment:({walletAddress:t,fetch:r,maxValue:n=BigInt(1e5),paymentRequirementsSelector:i=R.selectPaymentRequirements,config:s})=>{let o=t||e[0]?.address;if(!o)throw new O.InvalidInputError("No wallet available for payment");let l=e.find((e=>a.areAddressesEqual(e.address,o)));if(!l)throw new O.InvalidInputError(`Wallet ${o} not found in connected wallets`);return async(e,t)=>{let a=await r(e,t);if(402!==a.status)return a;if(t?.__is402Retry)throw Error("Payment already attempted for this request");let{x402Version:o,accepts:c}=await a.json(),d=i(c,void 0,"exact");if(BigInt(d.maxAmountRequired)>n)throw new O.InvalidInputError("Payment amount exceeds maximum allowed");let u=await Nr({wallet:l}),h=await R.createPaymentHeader(u,o,d,s),p={...t,headers:{...t?.headers||{},"X-PAYMENT":h,"Access-Control-Expose-Headers":"X-PAYMENT-RESPONSE"},__is402Retry:!0};return await r(e,p)}}})),[e])};
