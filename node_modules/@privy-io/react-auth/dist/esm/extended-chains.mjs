import{useMemo as e}from"react";import{create as t,rawSign as r}from"@privy-io/js-sdk-core";import{u as a,a as i}from"./internal-context-Z-fyxadS.mjs";import{u as n,a as s,h as o,b as l,n as d}from"./get-is-unified-wallet-CNcx75Dp.mjs";import{u as c}from"./context-LVpDfP2H.mjs";import{u as p}from"./use-sign-with-user-signer-Do5Oi_rb.mjs";import"ofetch";import"viem";import"react/jsx-runtime";import"tinycolor2";const u=()=>{let{refreshSessionAndUser:r,privy:i}=a();return e((()=>({async createWallet(e){let a=await t(i,{request:{chain_type:e.chainType}}),n=await r();if(!n)throw Error("User must be authenticated before creating a Privy wallet");return{user:n,wallet:a}}})),[r,i])};function m(){let{user:t,getAccessToken:r}=n(),{walletProxy:d,openModal:p,client:u}=a(),{setModalData:m}=s(),h=c();return e((()=>({exportWallet:e=>new Promise((async(a,n)=>{if(!t)return void n(new i("User must be authenticated before exporting their Privy wallet"));let s=o(t,e.address);s?"spark"===s.chainType&&l(s)?await r()?d?(m({connectWallet:{recoveryMethod:s.recoveryMethod,connectingWalletAddress:s.address,isUnifiedWallet:!0,onCompleteNavigateTo:"EmbeddedWalletKeyExportScreen",onFailure:n,shouldForceMFA:!0},keyExport:{appId:h.id,appClientId:h.appClientId,origin:u.apiUrl,address:s.address,hdWalletIndex:s.walletIndex,chainType:s.chainType,walletId:s.id,isUnifiedWallet:!0,imported:s.imported,onSuccess:a,onFailure:n}}),p("EmbeddedWalletConnectingScreen")):n(new i("Wallet not ready for export")):n(new i("Must have valid access token.")):n(Error("Export via extended-chains is only supported for unified stack wallets")):n(new i("User must have an embedded wallet."))}))})),[t,r,d,p,u,m,h])}const h=()=>{let{user:t}=n(),{privy:i}=a(),{signWithUserSigner:s}=p();return e((()=>({async signRawHash({address:e,chainType:a,hash:n}){if(!t)throw Error("User must be authenticated before signing");let o=d(t,a).filter((e=>l(e))).find((t=>t.address===e));if(!o)throw Error("Wallet not found");let c=await r(i,s,{wallet_id:o.id,params:{hash:n}});if(c.data&&"signature"in c.data&&"hex"===c.data.encoding)return{signature:c.data.signature};throw Error("Failed to sign")}})),[i,s,t])};export{u as useCreateWallet,m as useExportWallet,h as useSignRawHash};
