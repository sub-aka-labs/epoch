import{getBase58Decoder as e,getTransactionDecoder as n,address as t,getTransactionEncoder as a}from"@solana/kit";import{useMemo as s,useEffect as i,useState as r}from"react";import o,{rpc as c,ConnectedStandardSolanaWallet as l}from"@privy-io/js-sdk-core";import{u as d,a as u,b as g,l as h}from"./internal-context-Z-fyxadS.mjs";import{a as p,h as f,b as w,o as A,k as y}from"./get-is-unified-wallet-CNcx75Dp.mjs";import{u as v}from"./usePrivy-Dj52a5sp.mjs";import{g as m,u as T}from"./useWallets-DlGuNtGR.mjs";import b from"eventemitter3";import{base58 as O}from"@scure/base";import{u as S}from"./context-LVpDfP2H.mjs";import{u as _}from"./use-sign-with-user-signer-Do5Oi_rb.mjs";import{g as E,u as I}from"./prepareFundingModalData-DjTxAoJ1.mjs";import{b as W,a as j,u as M}from"./useSolanaRpcClient-B7UDPdLi.mjs";const P=["solana:mainnet","solana:devnet","solana:testnet"];function F(n){return e().decode(n)}function C(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var U=0,D="__private_"+U+++"__implementation";function N(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var B=0;function R(e){return"__private_"+B+++"_"+e}var x=/*#__PURE__*/R("_address"),L=/*#__PURE__*/R("_publicKey"),V=/*#__PURE__*/R("_chains"),Q=/*#__PURE__*/R("_features"),G=/*#__PURE__*/R("_label"),K=/*#__PURE__*/R("_icon");class k{get address(){return N(this,x)[x]}get publicKey(){return N(this,L)[L].slice()}get chains(){return N(this,V)[V].slice()}get features(){return N(this,Q)[Q].slice()}get label(){return N(this,G)[G]}get icon(){return N(this,K)[K]}constructor({address:e,publicKey:n,label:t,icon:a}){Object.defineProperty(this,x,{writable:!0,value:void 0}),Object.defineProperty(this,L,{writable:!0,value:void 0}),Object.defineProperty(this,V,{writable:!0,value:void 0}),Object.defineProperty(this,Q,{writable:!0,value:void 0}),Object.defineProperty(this,G,{writable:!0,value:void 0}),Object.defineProperty(this,K,{writable:!0,value:void 0}),N(this,x)[x]=e,N(this,L)[L]=n,N(this,V)[V]=P,N(this,G)[G]=t,N(this,K)[K]=a,N(this,Q)[Q]=["solana:signAndSendTransaction","solana:signTransaction","solana:signMessage"],new.target===k&&Object.freeze(this)}}function J(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var Y=0;function H(e){return"__private_"+Y+++"_"+e}var Z=/*#__PURE__*/H("_listeners"),z=/*#__PURE__*/H("_version"),q=/*#__PURE__*/H("_name"),X=/*#__PURE__*/H("_icon"),$=/*#__PURE__*/H("_injection"),ee=/*#__PURE__*/H("_isPrivyWallet"),ne=/*#__PURE__*/H("_accounts"),te=/*#__PURE__*/H("_on"),ae=/*#__PURE__*/H("_emit"),se=/*#__PURE__*/H("_off"),ie=/*#__PURE__*/H("_connected"),re=/*#__PURE__*/H("_connect"),oe=/*#__PURE__*/H("_disconnect"),ce=/*#__PURE__*/H("_signMessage"),le=/*#__PURE__*/H("_signAndSendTransaction"),de=/*#__PURE__*/H("_signTransaction");function ue(e,...n){J(this,Z)[Z][e]?.forEach((e=>e.apply(null,n)))}function ge(e,n){J(this,Z)[Z][e]=J(this,Z)[Z][e]?.filter((e=>n!==e))}function he(e,s,i){let r=structuredClone(n().decode(e)),o=t(s);return o in r.signatures&&(r.signatures[o]=i),new Uint8Array(a().encode(r))}function pe(){let{isHeadlessSigning:e,walletProxy:n,initializeWalletProxy:t,recoverEmbeddedWallet:a,openModal:s,privy:i,client:r}=d(),{user:o}=v(),{setModalData:l}=p(),{signWithUserSigner:h}=_();return{signMessage:({message:d,address:p,options:A})=>new Promise((async(y,v)=>{let T=f(o,p);if("privy"!==T?.walletClientType)return void v(new u("Wallet is not a Privy wallet",void 0,g.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:b,entropyIdVerifier:O}=m(o,T),S=w(T),_=W(d).toString("base64");if(_.length<1)return void v(new u("Message must be a non-empty string",void 0,g.INVALID_MESSAGE));let E=async()=>{let e;if(!o)throw Error("User must be authenticated before signing with a Privy wallet");let s=await r.getAccessToken();if(!s)throw Error("User must be authenticated to use their embedded wallet.");let l=n??await t(15e3);if(!l)throw Error("Failed to initialize embedded wallet proxy.");if(!await a({address:T.address}))throw Error("Unable to connect to wallet");if(S){let n=await c(i,h,{chain_type:"solana",method:"signMessage",params:{message:_,encoding:"base64"},wallet_id:T.id});if(!n.data||!("signature"in n.data))throw Error("Failed to sign message");e=n.data.signature}else{let{response:n}=await l.rpc({accessToken:s,entropyId:b,entropyIdVerifier:O,chainType:"solana",hdWalletIndex:T.walletIndex??0,requesterAppId:A?.uiOptions?.requesterAppId,request:{method:"signMessage",params:{message:_}}});e=n.data.signature}return e};if(e({showWalletUIs:A?.uiOptions?.showWalletUIs}))try{let e=await E(),n=new Uint8Array(W(e,"base64"));y({signature:n})}catch(e){v(e)}else l({signMessage:{method:"solana_signMessage",data:_,confirmAndSign:E,onSuccess:e=>{y({signature:new Uint8Array(W(e,"base64"))})},onFailure:e=>{v(e)},uiOptions:A?.uiOptions??{}},connectWallet:{recoveryMethod:T.recoveryMethod,connectingWalletAddress:T.address,entropyId:b,entropyIdVerifier:O,isUnifiedWallet:S,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{v(new u("Failed to connect to wallet",e,g.UNKNOWN_CONNECT_WALLET_ERROR))}}}),s("EmbeddedWalletConnectingScreen")}))}}function fe(){let{isHeadlessSigning:e,openModal:n}=d(),{setModalData:t}=p(),{signMessage:a}=pe(),{user:s}=v();return{signTransaction:async({transaction:i,options:r,chain:o="solana:mainnet",address:c})=>{async function l(e){let{signature:n}=await a({message:j(e),address:c,options:{...r,uiOptions:{...r?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:he(e,c,n)}}return e({showWalletUIs:r?.uiOptions?.showWalletUIs})?l(i):new Promise((async(e,a)=>{let d=f(s,c);if("privy"!==d?.walletClientType)return void a(new u("Wallet is not a Privy wallet",void 0,g.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:h,entropyIdVerifier:p}=m(s,d),A=w(d);function y(e){return n=>{a(n instanceof u?n:new u("Failed to connect to wallet",n,e))}}let v={account:d,transaction:i,chain:o,signOnly:!0,uiOptions:r?.uiOptions||{},onConfirm:l,onSuccess:e,onFailure:y(g.TRANSACTION_FAILURE)};t({connectWallet:{recoveryMethod:d.recoveryMethod,connectingWalletAddress:d.address,entropyId:h,entropyIdVerifier:p,isUnifiedWallet:A,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:y(g.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:v}),n("EmbeddedWalletConnectingScreen")}))}}}let we=new class extends b{setImplementation(e){C(this,D)[D]=e}async signMessage(e){return C(this,D)[D].signMessage(e)}async signAndSendTransaction(e){return C(this,D)[D].signAndSendTransaction(e)}async signTransaction(e){return C(this,D)[D].signTransaction(e)}constructor(e){super(),Object.defineProperty(this,D,{writable:!0,value:void 0}),C(this,D)[D]=e}}({signTransaction:h("signTransaction was not injected"),signAndSendTransaction:h("signAndSendTransaction was not injected"),signMessage:h("signMessage was not injected")}),Ae=new class{get version(){return J(this,z)[z]}get name(){return J(this,q)[q]}get icon(){return J(this,X)[X]}get chains(){return P.slice()}get features(){return{"standard:connect":{version:"1.0.0",connect:J(this,re)[re]},"standard:disconnect":{version:"1.0.0",disconnect:J(this,oe)[oe]},"standard:events":{version:"1.0.0",on:J(this,te)[te]},"solana:signAndSendTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:J(this,le)[le]},"solana:signTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:J(this,de)[de]},"solana:signMessage":{version:"1.0.0",signMessage:J(this,ce)[ce]},"privy:":{privy:{signMessage:J(this,$)[$].signMessage,signTransaction:J(this,$)[$].signTransaction,signAndSendTransaction:J(this,$)[$].signAndSendTransaction}}}}get accounts(){return J(this,ne)[ne].slice()}get isPrivyWallet(){return J(this,ee)[ee]}constructor({name:e,icon:n,version:t,injection:a,wallets:s}){Object.defineProperty(this,ae,{value:ue}),Object.defineProperty(this,se,{value:ge}),Object.defineProperty(this,Z,{writable:!0,value:void 0}),Object.defineProperty(this,z,{writable:!0,value:void 0}),Object.defineProperty(this,q,{writable:!0,value:void 0}),Object.defineProperty(this,X,{writable:!0,value:void 0}),Object.defineProperty(this,$,{writable:!0,value:void 0}),Object.defineProperty(this,ee,{writable:!0,value:void 0}),Object.defineProperty(this,ne,{writable:!0,value:void 0}),Object.defineProperty(this,te,{writable:!0,value:void 0}),Object.defineProperty(this,ie,{writable:!0,value:void 0}),Object.defineProperty(this,re,{writable:!0,value:void 0}),Object.defineProperty(this,oe,{writable:!0,value:void 0}),Object.defineProperty(this,ce,{writable:!0,value:void 0}),Object.defineProperty(this,le,{writable:!0,value:void 0}),Object.defineProperty(this,de,{writable:!0,value:void 0}),J(this,Z)[Z]={},J(this,te)[te]=(e,n)=>(J(this,Z)[Z][e]?.push(n)||(J(this,Z)[Z][e]=[n]),()=>J(this,se)[se](e,n)),J(this,ie)[ie]=e=>{null!=e&&(J(this,ne)[ne]=e.map((({address:e})=>new k({address:e,publicKey:O.decode(e)})))),J(this,ae)[ae]("change",{accounts:this.accounts})},J(this,re)[re]=async()=>(J(this,ae)[ae]("change",{accounts:this.accounts}),{accounts:this.accounts}),J(this,oe)[oe]=async()=>{J(this,ae)[ae]("change",{accounts:this.accounts})},J(this,ce)[ce]=async(...e)=>{let n=[];for(let{account:t,...a}of e){let{signature:e}=await J(this,$)[$].signMessage({...a,address:t.address});n.push({signedMessage:a.message,signature:e})}return n},J(this,le)[le]=async(...e)=>{let n=[];for(let t of e){let{signature:e}=await J(this,$)[$].signAndSendTransaction({...t,transaction:t.transaction,address:t.account.address,chain:t.chain||"solana:mainnet",options:t.options});n.push({signature:e})}return n},J(this,de)[de]=async(...e)=>{let n=[];for(let{transaction:t,account:a,options:s,chain:i}of e){let{signedTransaction:e}=await J(this,$)[$].signTransaction({transaction:t,address:a.address,chain:i||"solana:mainnet",options:s});n.push({signedTransaction:e})}return n},J(this,q)[q]=e,J(this,X)[X]=n,J(this,z)[z]=t,J(this,$)[$]=a,J(this,ne)[ne]=[],J(this,ee)[ee]=!0,a.on("accountChanged",J(this,ie)[ie],this),J(this,ie)[ie](s)}}({name:"Privy",version:"1.0.0",icon:"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==",wallets:[],injection:we});function ye(){let{ready:e}=T(),{user:n}=v(),{signMessage:t}=pe(),{signTransaction:a}=fe(),{signAndSendTransaction:r}=function(){let e=S(),{isHeadlessSigning:n,openModal:t}=d(),{setModalData:a}=p(),{signTransaction:s}=fe(),i=M(),{user:r}=v(),{signWithUserSigner:l}=_();return{signAndSendTransaction:async({transaction:d,address:h,chain:p="solana:mainnet",options:A})=>{let y=f(r,h);if("privy"!==y?.walletClientType)throw new u("Wallet is not a Privy wallet",void 0,g.EMBEDDED_WALLET_NOT_FOUND);let v=w(y);async function T(n){if(A?.sponsor)return await(async n=>{if(!v)throw new u("Sponsoring transactions is only supported for wallets on the TEE stack",g.INVALID_DATA);let t=new o({appId:e.id,clientId:e.appClientId,storage:I}),a=await c(t,l,{chain_type:"solana",method:"signAndSendTransaction",sponsor:!0,params:{transaction:W(n).toString("base64"),encoding:"base64"},caip2:`solana:${(await i(p).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:y.id});if(a.data&&"hash"in a.data)return{signature:O.decode(a.data.hash)};throw Error("Failed to sign and send transaction")})(n);let{signedTransaction:t}=await s({transaction:n,address:h,chain:p,options:{...A,uiOptions:{...A?.uiOptions,showWalletUIs:!1}}}),{signature:a}=await i(p).sendAndConfirmTransaction(t);return{signature:a}}return n({showWalletUIs:A?.uiOptions?.showWalletUIs})?T(d):new Promise((async(n,s)=>{let i,o,{entropyId:c,entropyIdVerifier:l}=m(r,y);function f(e){return n=>{s(n instanceof u?n:new u("Failed to connect to wallet",n,e))}}let w={account:y,transaction:d,chain:p,signOnly:!1,uiOptions:A?.uiOptions||{},onConfirm:T,onSuccess:n,onFailure:f(g.TRANSACTION_FAILURE),isSponsored:!!A?.sponsor},b={recoveryMethod:y.recoveryMethod,connectingWalletAddress:y.address,entropyId:c,entropyIdVerifier:l,isUnifiedWallet:v,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:f(g.UNKNOWN_CONNECT_WALLET_ERROR)};e.fundingConfig&&(i=E({address:h,appConfig:e,methodScreen:"FundingMethodSelectionScreen",fundWalletConfig:{...A,asset:"native-currency",chain:p},externalSolanaFundingScreen:"FundSolWalletWithExternalSolanaWallet"}),o={amount:e.fundingConfig.defaultRecommendedAmount,asset:"SOL",chain:p,destinationAddress:h,afterSuccessScreen:"StandardSignAndSendTransactionScreen",sourceWalletData:void 0}),a({connectWallet:b,standardSignAndSendTransaction:w,funding:i,solanaFundingData:o}),t("EmbeddedWalletConnectingScreen")}))}}}(),l=s((()=>{let e=[...A(n).sort(((e,n)=>(e.walletIndex??0)-(n.walletIndex??0)))],t=y(n);return t.length?[...e,...t]:e}),[n]),h=s((()=>({signMessage:async({message:e,address:n,options:a})=>await t({message:e,address:n,options:a}),signTransaction:async({transaction:e,address:n,chain:t,options:s})=>await a({transaction:e,address:n,chain:t,options:s}),async signAndSendTransaction({transaction:e,address:n,chain:t,options:a}){let{signature:s}=await r({transaction:e,address:n,chain:t,options:a});return{signature:s}}})),[t,a,r]);return i((()=>{we?.setImplementation(h)}),[h]),i((()=>{var n;!e||(n=Ae.accounts).length===l.length&&n.every(((e,n)=>e.address===l[n]?.address))||we?.emit("accountChanged",l)}),[e,l]),{ready:e,wallet:Ae}}function ve(){let{client:e}=d(),{ready:n,wallet:t}=ye(),[a,s]=r([]),[o,c]=r([]);return i((()=>{let e=[t,...a.filter((e=>"solana"===e.chainType&&!!e.wallet.features)).map((e=>e.wallet))];c(e);let n=a.flatMap((n=>{let t=()=>c([...e]);return n.on("walletsUpdated",t),{connector:n,off:t}})),s=e.map((n=>n.features["standard:events"]?.on("change",(()=>{c([...e])}))));return()=>{s.forEach((e=>e?.())),n.forEach((({connector:e,off:n})=>e.off("walletsUpdated",n)))}}),[a]),i((()=>{s(e.connectors?.walletConnectors.filter((e=>"solana"===e.chainType))??[]);let n=()=>{s(e.connectors?.walletConnectors.filter((e=>"solana"===e.chainType))??[])};return e.connectors?.on("connectorInitialized",n),()=>{e.connectors?.off("connectorInitialized",n)}}),[n,e.connectors]),{ready:n,wallets:o}}function me(){let{ready:e,wallets:n}=ve();return{ready:e,wallets:s((()=>n.flatMap((e=>e.accounts.map((n=>new l({wallet:e,account:n})))))),[n])}}export{P as S,ve as a,F as g,me as u};
