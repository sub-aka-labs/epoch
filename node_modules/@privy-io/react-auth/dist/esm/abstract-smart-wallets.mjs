import{createAbstractClient as e}from"@abstract-foundation/agw-client";import{getBatchTransactionObject as a}from"@abstract-foundation/agw-client/actions";import{hexToNumber as n,createWalletClient as t,custom as r,http as s}from"viem";import{toAccount as i}from"viem/accounts";import{abstractTestnet as o,zksync as c}from"viem/chains";import{u as d,a as l,c as m,b as p}from"./get-is-unified-wallet-CNcx75Dp.mjs";import{u}from"./context-LVpDfP2H.mjs";import{u as g}from"./internal-context-Z-fyxadS.mjs";import{u as y,g as f}from"./useWallets-DlGuNtGR.mjs";import{a as h}from"./getPublicClient-B4uPLKn-.mjs";import{g as v}from"./getEmbeddedConnectedWallet-CM6cDQCS.mjs";import{c as I}from"./smart-wallets-9LKzbfWj.mjs";import"react/jsx-runtime";import"react";import"@privy-io/js-sdk-core";import"tinycolor2";import"ofetch";import"permissionless";import"permissionless/accounts";import"permissionless/clients/pimlico";import"viem/account-abstraction";function T(){let{user:T}=d(),{hideWalletUIs:S,openPrivyModal:w,chains:P,appId:W,rpcConfig:b,client:C}=g(),F=u(),{wallets:M}=y(),{setModalData:_}=l(),x=m(T),A=!!x&&p(x),q=async(a=o.id)=>{let d=v(M);if(!d)throw Error("No connected wallet found");let l="string"==typeof a?n(a):a;if(![o.id,2741,c.id].includes(l))throw Error("Error, only Abstract and ZKSync Era chains are supported");let m=P.find((e=>e.id===l));if(!m)throw Error("Chain not configured");await d.switchChain(m.id);let p=await d.getEthereumProvider(),u=t({account:d.address,transport:r(p)}),g=i({address:d.address,signMessage:u.signMessage,signTransaction:u.signTransaction,signTypedData:u.signTypedData});return await e({chain:m,transport:s(h(m,b,W)),publicTransport:s(h(m,b,W)),signer:g})};return{signMessage:async({message:e},a)=>{let n=await q(a);return new Promise((async(a,t)=>{let{entropyId:r,entropyIdVerifier:s}=f(T);S.current=!0,_({connectWallet:{recoveryMethod:x.recoveryMethod,connectingWalletAddress:x.address,isUnifiedWallet:A,entropyId:r,entropyIdVerifier:s,onCompleteNavigateTo:"SignRequestScreen",onFailure:()=>{}},signMessage:{method:"personal_sign",data:e,confirmAndSign:()=>n.signMessage({message:e}),onSuccess:e=>a(e),onFailure:t,uiOptions:{isCancellable:!0}}}),w("EmbeddedWalletConnectingScreen")})).finally((()=>{S.current=!1}))},signTypedData:async(e,a)=>{let n=await q(a);return new Promise((async(a,t)=>{S.current=!0;let{entropyId:r,entropyIdVerifier:s}=f(T);_({connectWallet:{recoveryMethod:x.recoveryMethod,connectingWalletAddress:x.address,isUnifiedWallet:A,entropyId:r,entropyIdVerifier:s,onCompleteNavigateTo:"SignRequestScreen",onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>n.signTypedData(e),onSuccess:e=>a(e),onFailure:t,uiOptions:{isCancellable:!0}}}),w("EmbeddedWalletConnectingScreen")})).finally((()=>{S.current=!1}))},sendTransaction:async e=>{let n=await q(e.chainId),t=[],r="calls"in e&&void 0!==e.calls;return t=r?[...e.calls]:[e],new Promise((async(s,i)=>{S.current=!0;let{entropyId:o,entropyIdVerifier:c}=f(T);_({connectWallet:{recoveryMethod:x.recoveryMethod,connectingWalletAddress:x.address,isUnifiedWallet:A,entropyId:o,entropyIdVerifier:c,onCompleteNavigateTo:"SendTransactionScreen",onFailure:()=>{}},sendTransaction:{transactionRequests:I({calls:t,chain:n.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),entropyId:o,entropyIdVerifier:c,transactingWalletAddress:n.account.address,transactingWalletIndex:void 0,prepareTransactionRequest:async()=>{let t=r?a(n.account.address,e):e;return await n.prepareAbstractTransactionRequest(t)},scanTransaction:async()=>{if(!C)throw Error("Privy client not found");let t=r?a(n.account.address,e):e,s=await n.prepareAbstractTransactionRequest(t);return await C.scanTransaction({metadata:{domain:F.embeddedWallets.transactionScanning.domain},chain_id:e.chainId.toString(),request:{method:"eth_sendTransaction",params:[{from:s.from,to:s.to,value:s.value?.toString(),gas:s.gas?.toString(),gasPrice:s.gasPrice?.toString(),nonce:s.nonce?.toString(),data:s.data,eip_712_meta:{paymaster_params:{paymaster:s.paymaster,paymaster_input:s.paymasterInput}}}]}})},signOnly:!1,getIsSponsored:async()=>void 0!==e.paymaster&&void 0!==e.paymasterInput,onConfirm:()=>r?n.sendTransactionBatch(e):n.sendTransaction(e),onSuccess:e=>s(e.hash),onFailure:i,uiOptions:{isCancellable:!0}}}),w("EmbeddedWalletConnectingScreen")})).finally((()=>{S.current=!1}))},signTransaction:async e=>{let n=await q(e.chainId),t=[],r="calls"in e&&void 0!==e.calls;return t=r?[...e.calls]:[e],new Promise((async(s,i)=>{S.current=!0;let{entropyId:o,entropyIdVerifier:c}=f(T);_({connectWallet:{recoveryMethod:x.recoveryMethod,connectingWalletAddress:x.address,isUnifiedWallet:A,entropyId:o,entropyIdVerifier:c,onCompleteNavigateTo:"SendTransactionScreen",onFailure:()=>{}},sendTransaction:{transactionRequests:I({calls:t,chain:n.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),entropyId:o,entropyIdVerifier:c,transactingWalletAddress:n.account.address,transactingWalletIndex:void 0,prepareTransactionRequest:async()=>{let t=r?a(n.account.address,e):e;return await n.prepareAbstractTransactionRequest(t)},scanTransaction:async()=>{if(!C)throw Error("Privy client not found");let t=r?a(n.account.address,e):e,s=await n.prepareAbstractTransactionRequest(t);return await C.scanTransaction({metadata:{domain:F.embeddedWallets.transactionScanning.domain},chain_id:e.chainId.toString(),request:{method:"eth_sendTransaction",params:[{from:s.from,to:s.to,value:s.value?.toString(),gas:s.gas?.toString(),gasPrice:s.gasPrice?.toString(),nonce:s.nonce?.toString(),data:s.data,eip_712_meta:{paymaster_params:{paymaster:s.paymaster,paymaster_input:s.paymasterInput}}}]}})},signOnly:!0,getIsSponsored:async()=>void 0!==e.paymaster&&void 0!==e.paymasterInput,onConfirm:async()=>{let t=r?a(n.account.address,e):e,s=await n.prepareAbstractTransactionRequest(t);return n.signTransaction(s)},onSuccess:e=>s(e.hash),onFailure:i,uiOptions:{isCancellable:!0}}}),w("EmbeddedWalletConnectingScreen")})).finally((()=>{S.current=!1}))}}}export{T as useAbstractSmartWallets};
