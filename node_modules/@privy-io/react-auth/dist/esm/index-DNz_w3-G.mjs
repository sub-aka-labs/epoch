import{jsxs as e,jsx as t,Fragment as n}from"react/jsx-runtime";import r,{useContext as a,createContext as i,useRef as s,useState as o,useMemo as l,useEffect as c,Suspense as d,lazy as u,useCallback as h}from"react";import p,{DEFAULT_SUPPORTED_CHAIN_IDS as w,rpc as m,PrivyClientError as y,getWallet as g,updateWallet as f,generateAuthorizationSignature as v}from"@privy-io/js-sdk-core";import{v4 as A}from"uuid";import*as k from"jose";import{base64url as T}from"jose";import{u as C,a as _,g as b,i as S,b as E,c as I,d as P,e as W,f as U,P as N,M as O,h as R,j as M,k as x,l as F,m as D}from"./get-is-unified-wallet-CNcx75Dp.mjs";import L from"eventemitter3";import{E as j,P as z,t as q,p as H,H as V,u as B,L as K,g as $,s as G,a as Y,b as J,c as Q,i as Z,d as X,e as ee,R as te,f as ne,h as re,j as ae,k as ie,l as se,m as oe,n as le,M as ce,o as de,q as ue,S as he,r as pe,v as we,w as me,x as ye}from"./useActiveWallet-RZ4w-uGq.mjs";import{u as ge,t as fe,U as ve,g as Ae}from"./useWallets-DlGuNtGR.mjs";import{P as ke,a as Te,f as Ce,b as _e,c as be,n as Se,d as Ee,u as Ie,e as Pe,I as We,g as Ue,h as Ne,i as Oe}from"./internal-context-Z-fyxadS.mjs";import{f as Re,u as Me,W as xe,i as Fe,a as De,P as Le,e as je,p as ze,b as qe,l as He}from"./prepareFundingModalData-DjTxAoJ1.mjs";import{createCoinbaseWalletSDK as Ve}from"@coinbase/wallet-sdk";import{toViemTransactionSerializable as Be,STRING_TO_NUMBER_TXN_TYPE as Ke}from"@privy-io/ethereum";import{P as $e,C as Ge,a as Ye,H as Je,O as Qe,S as Ze,u as Xe,b as et,c as tt,D as nt,d as rt,g as at,V as it,R as st,e as ot,f as lt,h as ct,i as dt,j as ut,I as ht,k as pt,l as wt,m as mt,W as yt}from"./context-LVpDfP2H.mjs";import{createStore as gt}from"mipd";import{isMobile as ft,isIOS as vt,isAndroid as At,isSafari as kt}from"react-device-detect";import{isAddress as Tt,toHex as Ct,getAddress as _t,isHex as bt,hashAuthorization as St}from"viem/utils";import{trigger as Et}from"@privy-io/popup";import{u as It,p as Pt,a as Wt,b as Ut,f as Nt,c as Ot,d as Rt,e as Mt,o as xt,g as Ft,h as Dt,i as Lt,j as jt,k as zt,l as qt,m as Ht,n as Vt,q as Bt,r as Kt,s as $t,t as Gt,v as Yt,w as Jt,x as Qt,y as Zt,z as Xt,A as en,B as tn,C as nn,D as rn,E as an,F as sn,G as on,H as ln,I as cn,J as dn,K as un,L as hn,M as pn,N as wn,O as mn,P as yn,Q as gn,R as fn,S as vn,T as An,U as kn,V as Tn,W as Cn,X as _n,Y as bn,Z as Sn,_ as En,$ as In,a0 as Pn,a1 as Wn,a2 as Un,a3 as Nn,a4 as On}from"./paths-3HW55qZg.mjs";import{o as Rn,p as Mn,d as xn,r as Fn,b as Dn,s as Ln,a as jn,c as zn,u as qn,e as Hn,S as Vn,f as Bn,P as Kn,g as $n}from"./usePrivy-Dj52a5sp.mjs";import{base64 as Gn}from"@scure/base";import{styled as Yn,createGlobalStyle as Jn,css as Qn}from"styled-components";import{u as Zn,a as Xn,p as er,e as tr,P as nr}from"./events-context-CI0iqAXA.mjs";import{create as rr}from"zustand";import{Transition as ar,Dialog as ir,TransitionChild as sr,DialogPanel as or}from"@headlessui/react";import{EthereumProvider as lr,OPTIONAL_METHODS as cr,OPTIONAL_EVENTS as dr}from"@walletconnect/ethereum-provider";import{constructURL as ur}from"@privy-io/urls";import{toHex as hr,zeroAddress as pr,getAddress as wr,createWalletClient as mr,http as yr,parseSignature as gr}from"viem";import{g as fr,a as vr}from"./getPublicClient-B4uPLKn-.mjs";import{ofetch as Ar}from"ofetch";import kr from"js-cookie";import{F as Tr}from"./frame-uzTmvtww.mjs";import{MfaAuthPasskeyVerify as Cr,MfaAuthPasskeyInit as _r,MfaAuthTotpVerify as br,MfaAuthPasskeyEnrollment as Sr,MfaAuthTotpUnenroll as Er,MfaAuthTotpEnroll as Ir,MfaAuthTotpInit as Pr}from"@privy-io/routes";import{selectPaymentRequirements as Wr,createPaymentHeader as Ur}from"x402/client";import{InvalidInputError as Nr}from"@privy-io/api-base";import{toAccount as Or}from"viem/accounts";import{u as Rr}from"./use-sign-with-user-signer-Do5Oi_rb.mjs";import"./getEmbeddedConnectedWallet-CM6cDQCS.mjs";class Mr{static parse(e){try{return new Mr(e)}catch(e){return null}}static throwIfNotWellFormedJwt(e){return k.decodeJwt(e),e}get subject(){return this._decoded.sub}get expiration(){return this._decoded.exp}get issuer(){return this._decoded.iss}get audience(){return this._decoded.aud}isExpired(e=0){return Date.now()>=1e3*(this.expiration-e)}constructor(e){this.value=e,this._decoded=k.decodeJwt(e)}}class xr extends Mr{static parse(e){try{return new xr(e)}catch(e){return null}}get appId(){return this._decoded.aid?this._decoded.aid:this.audience}}const Fr=({style:n,...r})=>/*#__PURE__*/e("svg",{viewBox:"0 0 1024 1024",fill:"none",xmlns:"http://www.w3.org/2000/svg",style:{height:"28px",width:"28px",...n},...r,children:[/*#__PURE__*/t("rect",{width:"1024",height:"1024",fill:"#0052FF",rx:100,ry:100}),/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z",fill:"white"})]}),Dr="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PScwIDAgMTAyNCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHN0eWxlPSdoZWlnaHQ6MjhweDt3aWR0aDoyOHB4Jz48cmVjdCB3aWR0aD0nMTAyNCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjMDA1MkZGJyByeD0nMTAwJyByeT0nMTAwJz48L3JlY3Q+PHBhdGggZmlsbC1ydWxlPSdldmVub2RkJyBjbGlwLXJ1bGU9J2V2ZW5vZGQnIGQ9J00xNTIgNTEyQzE1MiA3MTAuODIzIDMxMy4xNzcgODcyIDUxMiA4NzJDNzEwLjgyMyA4NzIgODcyIDcxMC44MjMgODcyIDUxMkM4NzIgMzEzLjE3NyA3MTAuODIzIDE1MiA1MTIgMTUyQzMxMy4xNzcgMTUyIDE1MiAzMTMuMTc3IDE1MiA1MTJaTTQyMCAzOTZDNDA2Ljc0NSAzOTYgMzk2IDQwNi43NDUgMzk2IDQyMFY2MDRDMzk2IDYxNy4yNTUgNDA2Ljc0NSA2MjggNDIwIDYyOEg2MDRDNjE3LjI1NSA2MjggNjI4IDYxNy4yNTUgNjI4IDYwNFY0MjBDNjI4IDQwNi43NDUgNjE3LjI1NSAzOTYgNjA0IDM5Nkg0MjBaJyBmaWxsPSd3aGl0ZSc+PC9wYXRoPjwvc3ZnPg==",Lr="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAALZJREFUaEPtmjEOhDAMBNc/O14GvOzys3CAKK6eAlmaVGl2Zc+kTOU685vkc9/bnD2prZK5/TZY24z9P+g4F5hNh7/GdoG37WlAA5CATwgCxHENYISwQAMQII5rACOEBRqAAHFcAxghLNAABIjjGsAIYYEGIEAc1wBGCAs0AAHiuAYwQligAQgQxzWAEcICDUCAOK4BjBAWaAACxHENYISwQAMQII6fBjr+VHkW3+u+tfyxMpJaDgYzYxb/ALZVAAAAAElFTkSuQmCC";let jr,zr;class qr extends j{async initialize(){await this.importPromise,await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Lr,id:"com.coinbase.wallet"}}async promptConnection(){try{await this.importPromise;let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super("base_account",e,t,n),this.connectorType="base_account",this.walletClientType="base_account",this.displayName="Base",this.setBaseAccountSdk=a,this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.baseAccountConfig={...r,appChainIds:[t.id].concat(e.map((e=>e.id)))},jr?(this.proxyProvider.setWalletProvider(jr.getProvider()),this.setBaseAccountSdk(jr)):this.importPromise=import("@base-org/account").then((({createBaseAccountSDK:e})=>{jr=e(this.baseAccountConfig),this.proxyProvider.setWalletProvider(jr.getProvider()),this.setBaseAccountSdk(jr)})).catch(console.error)}}let Hr=[1,11155111,137,10,8453,84532,42161,7777777,43114,56];class Vr extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}disconnect(){this.proxyProvider.walletProvider.disconnect(),this.onDisconnect()}get walletBranding(){return{name:this.displayName,icon:Dr,id:"com.coinbase.wallet"}}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");this.connected=!0,await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}updateConnectionPreference(e){this.coinbaseWalletConfig={...this.coinbaseWalletConfig,preference:{...this.coinbaseWalletConfig.preference,options:e}},this.walletClientType="smartWalletOnly"===e?"coinbase_smart_wallet":"coinbase_wallet",zr=Ve({...this.coinbaseWalletConfig}),this.proxyProvider.setWalletProvider(zr.getProvider())}constructor(e,t,n,r){if(super("coinbase_wallet",e,t,n),this.connectorType="coinbase_wallet",this.displayName="Coinbase Wallet",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.coinbaseWalletConfig={...r,appChainIds:[t.id].concat(e.map((e=>e.id)))},this.walletClientType="smartWalletOnly"===this.coinbaseWalletConfig.preference?.options?"coinbase_smart_wallet":"coinbase_wallet","coinbase_smart_wallet"===this.walletClientType&&(this.displayName="Coinbase Smart Wallet"),!zr){let e="eoaOnly"!==this.coinbaseWalletConfig.preference?.options?(this.coinbaseWalletConfig.appChainIds??[]).filter((e=>!Hr.includes(e))):[];e.length>0&&!e.every((e=>w.has(e)))&&console.info(`The configured chains are not supported by Coinbase Smart Wallet: ${e.join(", ")}`),zr=Ve(this.coinbaseWalletConfig)}this.proxyProvider.setWalletProvider(zr.getProvider())}}const Br=({...e})=>/*#__PURE__*/t("svg",{width:"15",height:"15",viewBox:"0 0 15 15",fill:"none",xmlns:"http://www.w3.org/2000/svg",...e,children:/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M2.37126 11.0323C2.37126 12.696 3.90598 13.4421 5.40654 13.4468C8.91753 13.4468 12.8021 11.2897 12.7819 7.67984C12.7673 5.07728 10.3748 2.86167 7.54357 2.88296C4.8495 2.88296 2.21821 4.6411 2.21803 7.03628C2.21803 7.67951 2.58722 8.30178 3.55231 8.37184C2.74763 9.16826 2.37126 10.1225 2.37126 11.0323ZM7.55283 8.68012C8.11562 8.68012 8.57186 8.13217 8.57186 7.45624C8.57186 6.78032 8.11562 6.23237 7.55283 6.23237C6.99003 6.23237 6.53379 6.78032 6.53379 7.45624C6.53379 8.13217 6.99003 8.68012 7.55283 8.68012ZM10.4747 8.68012C11.0375 8.68012 11.4937 8.13217 11.4937 7.45625C11.4937 6.78032 11.0375 6.23237 10.4747 6.23237C9.91186 6.23237 9.45562 6.78032 9.45562 7.45625C9.45562 8.13217 9.91186 8.68012 10.4747 8.68012Z",fill:e.color||"var(--privy-color-foreground-3)"})});class Kr extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return await this.isConnected()?(await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[q(e?.chainId||"0x1")]}),this.getConnectedWallet()):null}get walletBranding(){return{name:"Privy Wallet",icon:Br,id:"io.privy.wallet"}}disconnect(){this.connected=!1}async promptConnection(){}constructor({provider:e,chains:t,defaultChain:n,rpcConfig:r,imported:a,walletIndex:i}){super("privy",t,n,r),this.connectorType="embedded",this.proxyProvider=e,this.walletIndex=i,a&&(this.connectorType="embedded_imported"),this.subscribeListeners()}}async function $r(){let e=Rs();return e?e.getAccessToken():Promise.resolve(Me.get($e)||Me.get(Ge)||null)}const Gr=["eth_sign","eth_populateTransactionRequest","eth_signTransaction","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"];function Yr(e){return e?{"privy-ui":"t"}:void 0}class Jr{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new Te("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(Pt,{email:this.meta.email,code:this.meta.emailCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode)throw new Te("Email and email code must be set prior to calling authenticate.");try{return await this.api.post(Wt,{email:this.meta.email,code:this.meta.emailCode})}catch(e){throw Ce(e)}}async sendCodeEmail({email:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new Te("Auth flow has no API instance");if(e&&(this.meta.email=e),t&&(this.meta.captchaToken=t),!this.meta.email)throw new Te("Email must be set when initialzing authentication.");let r=Yr(n);try{return await this.api.post(Ut,{email:this.meta.email,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw Ce(e)}}constructor({email:e,captchaToken:t,disableSignup:n}){this.meta={email:e,captchaToken:t,disableSignup:n??!1}}}class Qr extends Jr{async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.email||!this.meta.emailCode||!this.meta.oldAddress)throw new Te("Email, email code, and an old email address must be set prior to calling update.");try{return await this.api.post(It,{oldAddress:this.meta.oldAddress,newAddress:this.meta.email,code:this.meta.emailCode})}catch(e){throw Ce(e)}}constructor(e,t,n){super({email:t,captchaToken:n}),this.meta={email:t,captchaToken:n,oldAddress:e,disableSignup:!1}}}class Zr{execute(e){return null===this.promise&&(this.promise=(async()=>{try{return await this.fn(e)}finally{this.promise=null}})()),this.promise}constructor(e){this.promise=null,this.fn=e}}class Xr{get meta(){return this._meta}async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.channelToken)throw new Te("Auth flow must be initialized first");try{let e=await this.api.post(Nt,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});if(!e)throw new Te("No response from authentication");return e}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Ot,{channel_token:this.meta.channelToken,message:this.message,signature:this.signature,fid:this.fid})}catch(e){throw Ce(e)}}async _startChannelOnce(){if(!this.api)throw new Te("Auth flow has no API instance");let e=await this.api.post(Rt,{token:this.captchaToken});ft&&!vt&&e.connect_uri&&Rn(e.connect_uri,"_blank"),this._meta={...this._meta,connectUri:e.connect_uri,channelToken:e.channel_token}}async initializeFarcasterConnect(){if(!this.api)throw new Te("Auth flow has no API instance");await this.startChannelOnce.execute()}async _pollForReady(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.channelToken)throw new Te("Auth flow must be initialized first");let e=await this.api.get(Mt,{headers:{"farcaster-channel-token":this.meta.channelToken}});return"completed"===e.state&&(this.message=e.message,this.signature=e.signature,this.fid=e.fid,!0)}constructor(e,t=!1){this._meta={disableSignup:!1},this.captchaToken=e,this.startChannelOnce=new Zr(this._startChannelOnce.bind(this)),this.pollForReady=new Zr(this._pollForReady.bind(this)),this._meta.disableSignup=t}}function ea(){return"undefined"!=typeof window&&"chrome-extension:"===window.location.protocol&&"chrome"in window}function ta(){if(!ea())return;let e=window.chrome;return e?.runtime?.id}function na(){if(!ea())return!1;let e=window.chrome;return"function"==typeof e?.identity?.launchWebAuthFlow}async function ra(e){return new Promise(((t,n)=>{na()?window.chrome.identity.launchWebAuthFlow({url:e,interactive:!0},(async e=>{try{let n=function(){if(!ea())return;let e=window.chrome;return e?.runtime?.lastError?.message}();if(n||!e){let e=`WebAuthFlow failed: ${n||"Response URI missing"}`;throw Error(e)}let r=new URL(e),a=ta();if(!a)throw Error("Invalid extension context");if("chrome-extension:"===r.protocol){if(r.hostname!==a)throw Error("Invalid responseUri origin")}else{if("https:"!==r.protocol)throw Error("Invalid responseUri protocol");{let e=r.hostname.split(".");if(3!==e.length||"chromiumapp"!==e[1]||"org"!==e[2]||e[0]!==a)throw Error("Invalid responseUri origin")}}let i=r.searchParams.get("privy_oauth_state"),s=r.searchParams.get("privy_oauth_code");if(!i||!s)throw Error("Invalid responseUri - missing required parameters");t({privyOAuthState:i,privyOAuthCode:s})}catch(e){n(e)}})):n(Error("Chrome identity API not available"))}))}function aa(e){return crypto.getRandomValues(new Uint8Array(e))}function ia(){return T.encode(aa(36))}function sa(){return ia()}async function oa(e,t="S256"){if("S256"!=t)return e;{let t=await async function(e){let t=(new TextEncoder).encode(e);return new Uint8Array(await crypto.subtle.digest("SHA-256",t))}(e);return T.encode(t)}}class la{addCaptchaToken(e){this.meta.captchaToken=e}isActive(){return!!(this.meta.authorizationCode&&this.meta.stateCode&&this.meta.provider)}async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new Te("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenticate.");if("undefined"===this.meta.authorizationCode)throw new Te("User denied confirmation during OAuth flow");let e=function(){let e=Me.get(Ye);if(!e)throw new Te("Authentication error.");return e}();try{let t=await this.api.post(xt,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"});return Me.del(Ye),Me.del(Je),Me.del(Qe),t}catch(e){let t=Ce(e);if(t.privyErrorCode)throw new Te(t.message||"Invalid code during OAuth flow.",void 0,t.privyErrorCode);if("User denied confirmation during OAuth flow"===t.message)throw new Te("Invalid code during oauth flow.",void 0,_e.OAUTH_USER_DENIED);throw new Te("Invalid code during OAuth flow.",void 0,_e.UNKNOWN_AUTH_ERROR)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.authorizationCode||!this.meta.stateCode)throw new Te("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling link.");if("undefined"===this.meta.authorizationCode)throw new Te("User denied confirmation during OAuth flow");let e=Me.get(Ye);if(!e)throw new Te("Authentication error.");try{let t=await this.api.post(Ft,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:e});return Me.del(Ye),t}catch(e){throw Ce(e)}}async getAuthorizationUrl(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.provider)throw new Te("Provider must be set when initializing OAuth authentication.");let e=ia();Me.put(Ye,e);let t=sa();Me.put(Ze,t);let n=await oa(e);this.meta.withPrivyUi||Me.put(Je,!0),this.meta.disableSignup?Me.put(Qe,!0):Me.del(Qe);let r=Yr(this.meta.withPrivyUi),a=window.location.href,i=function(){let e=ta();if(e)return`https://${e}.chromiumapp.org`}();i&&(a=i);try{return await this.api.post(Dt,{provider:this.meta.provider,redirect_to:this.meta.customOAuthRedirectUrl||a,token:this.meta.captchaToken,code_challenge:n,state_code:t},{headers:{...r}})}catch(e){throw Ce(e)}}constructor(e){this.meta=e}}function ca(){let e=new URLSearchParams(window.location.search),t=e.get("privy_oauth_code"),n=e.get("privy_oauth_state"),r=e.get("privy_oauth_provider");if(!t||!n||!r)return{inProgress:!1};let a=!1;try{a=!!window.opener.location.origin}catch{}return{inProgress:!0,authorizationCode:t,stateCode:n,provider:r,withPrivyUi:!Me.get(Je),popupFlow:null!==window.opener&&a,disableSignup:!!Me.get(Qe)}}function da(){let e=new URL(window.location.href);e.searchParams.delete("privy_oauth_code"),e.searchParams.delete("privy_oauth_provider"),e.searchParams.delete("privy_oauth_state"),Me.del(Ze),window.history.replaceState({},"",e)}class ua{async initRegisterFlow(e){if(!this.api)throw new Te("Auth flow has no API instance");this.authenticateForRegistration=!0,this.meta.initRegisterResponse=await this.initRegisterOnce.execute(e)}async initAuthenticationFlow(e){if(!this.api)throw new Te("Auth flow has no API instance");this.authenticateForRegistration=!1,this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute(e)}async initLinkFlow(){if(!this.api)throw new Te("Auth flow has no API instance");this.meta.initLinkResponse=await this.initLinkOnce.execute()}async register(){let e=await import("@simplewebauthn/browser");if(!this.api)throw new Te("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Te("WebAuthn is not supported in this browser");this.meta.initRegisterResponse||(this.meta.initRegisterResponse=await this.initRegisterOnce.execute());try{let t=this.meta.initRegisterResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(Lt,{relying_party:this.meta.initRegisterResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Te("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Ce(e)}}async authenticate(){if(this.authenticateForRegistration)return this.register();let e=await import("@simplewebauthn/browser");if(!this.api)throw new Te("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Te("WebAuthn is not supported in this browser");this.meta.initAuthenticateResponse||(this.meta.initAuthenticateResponse=await this.initAuthenticateOnce.execute());let t=this.meta.allowedCredentialsIds?.map((e=>({type:"public-key",id:e})))??this.meta.initAuthenticateResponse.options.allow_credentials;try{let n=await e.startAuthentication({optionsJSON:this._transformInitAuthenticateOptionsToCamelCase({...this.meta.initAuthenticateResponse.options,allow_credentials:t})});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(jt,{relying_party:this.meta.initAuthenticateResponse.relying_party,challenge:this.meta.initAuthenticateResponse.options.challenge,authenticator_response:this._transformAuthenticationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Te("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Ce(e)}}async link(){let e=await import("@simplewebauthn/browser");if(!this.api)throw new Te("Auth flow has no API instance");if(!e.browserSupportsWebAuthn())throw new Te("WebAuthn is not supported in this browser");this.meta.initLinkResponse||(this.meta.initLinkResponse=await this.initLinkOnce.execute());try{let t=this.meta.initLinkResponse.options,n=await e.startRegistration({optionsJSON:this._transformInitLinkOptionsToCamelCase(t)});return this.meta.setPasskeyAuthState?.({status:"submitting-response"}),await this.api.post(zt,{relying_party:this.meta.initLinkResponse.relying_party,authenticator_response:this._transformRegistrationResponseToSnakeCase(n)})}catch(e){if("NotAllowedError"===e.name)throw new Te("Passkey request timed out or rejected by user.",void 0,_e.PASSKEY_NOT_ALLOWED);throw Ce(e)}}async _initRegisterOnce(e){if(!this.api)throw new Te("Auth flow has no API instance");let t=Yr(e);return await this.api.post(qt,{token:this.meta.captchaToken},{headers:{...t}})}async _initAuthenticateOnce(e){if(!this.api)throw new Te("Auth flow has no API instance");let t=Yr(e);return await this.api.post(Ht,{token:this.meta.captchaToken},{headers:{...t}})}async _initLinkOnce(){if(!this.api)throw new Te("Auth flow has no API instance");return await this.api.post(Vt,{})}_transformInitLinkOptionsToCamelCase(e){return{rp:e.rp,user:{id:e.user.id,name:e.user.name,displayName:e.user.display_name},challenge:e.challenge,pubKeyCredParams:e.pub_key_cred_params.map((e=>({type:e.type,alg:e.alg}))),timeout:e.timeout,excludeCredentials:e.exclude_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports}))),authenticatorSelection:{authenticatorAttachment:e.authenticator_selection?.authenticator_attachment,requireResidentKey:e.authenticator_selection?.require_resident_key,residentKey:e.authenticator_selection?.resident_key,userVerification:e.authenticator_selection?.user_verification},attestation:e.attestation,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props?.rk,hmacCreateSecret:e.extensions?.hmac_create_secret},hints:this.meta.hints}}_transformRegistrationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,attestation_object:e.response.attestationObject,authenticator_data:e.response.authenticatorData},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}_transformInitAuthenticateOptionsToCamelCase(e){return{rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification}}_transformAuthenticationResponseToSnakeCase(e){return{id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}}constructor({captchaToken:e,setPasskeyAuthState:t,hints:n}){this.authenticateForRegistration=!1,this.initRegisterOnce=new Zr(this._initRegisterOnce.bind(this)),this.initAuthenticateOnce=new Zr(this._initAuthenticateOnce.bind(this)),this.initLinkOnce=new Zr(this._initLinkOnce.bind(this)),this.meta={captchaToken:e,setPasskeyAuthState:t,hints:n}}}const ha=({address:e,chainId:t,nonce:n})=>`${window.location.host} wants you to sign in with your Ethereum account:\n${e}\n\nBy signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.\n\nURI: ${window.location.origin}\nVersion: 1\nChain ID: ${t}\nNonce: ${n}\nIssued At: ${(new Date).toISOString()}\nResources:\n- https://privy.io`;class pa{get meta(){return{connectorType:this.wallet?.connectorType,walletClientType:this.wallet?.walletClientType,chainId:this.wallet?.chainId,address:this.wallet?.address,disableSignup:this._meta.disableSignup}}async authenticate(){if(!this.client)throw new Te("SiweFlow has no client instance");try{if(this.preparedMessage&&this.signature)return await this.client.authenticateWithSiweInternal({message:this.preparedMessage,signature:this.signature,chainId:this.wallet?.chainId,walletClientType:this.walletClientType??this.wallet?.walletClientType,connectorType:this.connectorType??this.wallet?.connectorType,mode:this._meta.disableSignup?"no-signup":"login-or-sign-up"});if(!this.wallet)throw new Te("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.client)throw new Te("SiweFlow has no client instance");try{if(!this.wallet)throw new Te("SiweFlow has no wallet instance");let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiweInternal({message:e,signature:t,chainId:this.wallet.chainId,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType})}catch(e){throw Ce(e)}}async sign(){if(!this.client)throw new Te("SiweFlow has no client instance");if(await this.buildMessage(),!this.preparedMessage)throw new Te("Could not prepare SIWE message");if(!this.wallet)throw new Te("SiweFlow has no wallet instance");let e=await this.wallet.sign(this.preparedMessage);return{message:this.preparedMessage,signature:e}}async _getNonceOnce(){if(!this.client)throw new Te("SiweFlow has no client instance");if(!this.wallet)throw new Te("UI SiweFlow has no wallet instance");return await this.client.generateSiweNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new Te("SiweFlow has no client instance");if(!this.wallet)throw new Te("SiweFlow has no wallet instance");let e=this.wallet.address,t=this.wallet.chainId.replace("eip155:","");return this.nonce||(this.nonce=await this.getNonceOnce.execute()),this.preparedMessage=ha({address:e,chainId:t,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a){this._meta={disableSignup:!1},this.getNonceOnce=new Zr(this._getNonceOnce.bind(this)),this.wallet=t,this.captchaToken=n,this.client=e,this._meta.disableSignup=r,this.preparedMessage=a?.message,this.signature=a?.signature,this.walletClientType=a?.walletClientType,this.connectorType=a?.connectorType}}class wa{get meta(){return{connectorType:this.wallet.connectorType,walletClientType:this.wallet.walletClientType,disableSignup:this._meta.disableSignup,messageType:this._meta.messageType,address:this.wallet?.address}}set messageType(e){this._meta.messageType=e}async authenticate(){if(!this.client)throw new Te("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up",messageType:this.meta.messageType})}catch(e){throw Ce(e)}}async link(){if(!this.client)throw new Te("SiwsFlow has no client instance");try{let{message:e,signature:t}=await this.sign();return await this.client.linkWithSiwsInternal({message:e,signature:t,walletClientType:this.wallet.walletClientType,connectorType:this.wallet.connectorType,messageType:this.meta.messageType})}catch(e){throw Ce(e)}}async sign(){let e,t;if(!this.client)throw new Te("SiwsFlow has no client instance");await this.buildMessage();let n="transaction"===this.meta.messageType;if(!this.preparedMessage)throw new Te("Could not prepare SIWS message");if(!n&&!this.wallet.provider.signMessage||n&&!this.wallet.provider.signTransaction)throw new Te("Wallet does not support the necessary signing methods");if(n&&this._plugin){let n=await this.wallet.provider.signTransaction({transaction:Gn.decode(this.preparedMessage)});e=Gn.encode(n.signedTransaction),t=this._plugin.getSignatureFromTransaction(n.signedTransaction,this.wallet.address)}else{e=this.preparedMessage;let n=await this.wallet.provider.signMessage({message:(new TextEncoder).encode(this.preparedMessage)});t=Gn.encode(n.signature)}return{message:e,signature:t}}async _getNonceOnce(){if(!this.client)throw new Te("SiwsFlow has no client instance");return await this.client.generateSiwsNonce({address:this.wallet.address,captchaToken:this.captchaToken})}async buildMessage(){if(!this.client)throw new Te("SiwsFlow has no client instance");let e=this.wallet.address;return this.nonce||(this.nonce=await this.getNonceOnce.execute()),"transaction"===this.meta.messageType&&this._plugin?this.preparedMessage=this._plugin.createSiwsMemoTransaction({address:e,nonce:this.nonce}):this.preparedMessage=Mn({address:e,nonce:this.nonce}),this.preparedMessage}constructor(e,t,n,r=!1,a="plain",i){this._meta={disableSignup:!1,messageType:"plain"},this.getNonceOnce=new Zr(this._getNonceOnce.bind(this)),this.wallet=e,this.captchaToken=n,this.client=t,this._meta.disableSignup=r,this._meta.messageType=a,this._plugin=i}}class ma{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new Te("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(Bt,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode)throw new Te("phone number and sms code must be set prior to calling authenticate.");try{return await this.api.post(Kt,{phoneNumber:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw Ce(e)}}async sendSmsCode({phoneNumber:e,captchaToken:t,withPrivyUi:n}){if(!this.api)throw new Te("Auth flow has no API instance");if(e&&(this.meta.phoneNumber=e),t&&(this.meta.captchaToken=t),!this.meta.phoneNumber)throw new Te("phone nNumber must be set when initialzing authentication.");let r=Yr(n);try{return await this.api.post($t,{phoneNumber:this.meta.phoneNumber,token:this.meta.captchaToken},{headers:{...r}})}catch(e){throw Ce(e)}}constructor({phoneNumber:e,captchaToken:t,disableSignup:n}){this.meta={phoneNumber:e,captchaToken:t,disableSignup:n??!1}}}class ya extends ma{async link(){if(!this.api)throw new Te("Auth flow has no API instance");if(!this.meta.phoneNumber||!this.meta.smsCode||!this.meta.oldPhoneNumber)throw new Te("Phone number, sms code, and an old phone number must be set prior to calling update.");try{return await this.api.post(Gt,{old_phone_number:this.meta.oldPhoneNumber,new_phone_number:this.meta.phoneNumber,code:this.meta.smsCode})}catch(e){throw Ce(e)}}constructor(e,t,n){super({phoneNumber:t,captchaToken:n}),this.meta={phoneNumber:t,captchaToken:n,oldPhoneNumber:e,disableSignup:!1}}}const ga=/*#__PURE__*/i({enabled:!1,siteKey:"",provider:void 0,appId:void 0,token:void 0,error:void 0,status:"disabled",setToken:Se,setError:Se,setExecuting:Se,waitForResult:()=>Promise.resolve(""),ref:{current:null},remove:Ee,reset:Se,execute:Se});class fa extends be{constructor(e,t,n){super(e||"Captcha failed"),this.type="Captcha",t instanceof Error&&(this.cause=t),this.privyErrorCode=n}}const va=({children:e,appId:n,captchaSiteKey:r,enabledCaptchaProvider:a})=>{let i=s(null),c=s(null),[d,u]=o(),[h,p]=o(),[w,m]=o(!1),y=l((()=>a?w||d||h?!w||d||h?d&&!h?{status:"success",token:d}:h?{status:"error",error:h}:{status:"ready"}:{status:"loading"}:{status:"ready"}:{status:"disabled"}),[a,d,h,w]),g=l((()=>a?"turnstile"===a?{remove:()=>{i.current?.remove(),m(!1),p(void 0),u(void 0)},reset:()=>{i.current?.reset(),m(!1),p(void 0),u(void 0)},execute:()=>{m(!0),i.current?.execute()},waitForResult:async()=>{try{return await H((()=>i.current?.getResponse()),{interval:200,timeout:2e4})}catch(e){throw new fa("Captcha failed",null,_e.CAPTCHA_TIMEOUT)}}}:{remove:()=>{c.current?.removeCaptcha(),m(!1),p(void 0),u(void 0)},reset:()=>{c.current?.resetCaptcha(),m(!1),p(void 0),u(void 0)},execute:()=>{m(!0),c.current?.execute()},waitForResult:async()=>{try{return await H((()=>{let e=c.current?.getResponse();if(e)return e}),{interval:200,timeout:2e4})}catch(e){throw new fa("Captcha failed",null,_e.CAPTCHA_TIMEOUT)}}}:null),[a]),f=l((()=>{if(!a||!g)return{...y,enabled:!1,siteKey:"",appId:n,setToken:Se,setError:Se,setExecuting:Se,waitForResult:()=>Promise.resolve(void 0),remove:Ee,reset:Se,execute:Se,provider:void 0,ref:{current:null}};let e={...y,enabled:!0,appId:n,setToken:u,setError:p,setExecuting:m};return"turnstile"===a?{...e,provider:"turnstile",ref:i,siteKey:r.split("t:")[1]??"",...g}:{...e,provider:"hcaptcha",ref:c,siteKey:r.split("h:")[1]??"",...g}}),[y,a,g,n,r]);/*#__PURE__*/return t(ga.Provider,{value:f,children:e})},Aa=()=>a(ga);async function ka(e){if(e.enabled){if("error"===e.status)throw new fa(e.error,null,_e.CAPTCHA_FAILURE);return"success"===e.status?e.token:(e.execute(),await e.waitForResult())}}class Ta{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Yt,{captcha_token:this.meta.captchaToken,telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Jt,{telegram_auth_result:this.meta.telegramAuthResult,telegram_web_app_data:this.meta.telegramWebAppData})}catch(e){throw Ce(e)}}constructor(e,t=!1){this.meta={disableSignup:!1},this.meta={captchaToken:e,disableSignup:!1},this.meta.disableSignup=t}}function Ca(e){let t={detail:"",retryable:!1};return e?.privyErrorCode===_e.LINKED_TO_ANOTHER_USER&&(t.detail="This account has already been linked to another user."),e?.privyErrorCode===_e.DISALLOWED_LOGIN_METHOD&&(t.detail="Login with Telegram not allowed."),e?.privyErrorCode===_e.INVALID_DATA&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.CANNOT_LINK_MORE_OF_TYPE&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.INVALID_CREDENTIALS&&(t.retryable=!0,t.detail="Something went wrong. Try again."),e?.privyErrorCode===_e.TOO_MANY_REQUESTS&&(t.detail="Too many requests. Please wait before trying again."),e?.privyErrorCode===_e.TOO_MANY_REQUESTS&&e.message.includes("rate limit")&&(t.detail="Request limit reached for Telegram. Please wait a moment and try again."),e instanceof fa&&(t.retryable=!0,t.detail="Something went wrong. Try again."),t}function _a(e){return Object.fromEntries(decodeURIComponent(e).split("&").map((e=>e.split("=").map(decodeURIComponent))))}function ba(){let e=new URL(window.location.href);e.searchParams.delete("id"),e.searchParams.delete("hash"),e.searchParams.delete("auth_date"),e.searchParams.delete("first_name"),e.searchParams.delete("last_name"),e.searchParams.delete("username"),e.searchParams.delete("photo_url"),e.hash="",window.history.replaceState({},"",e)}let Sa=/*#__PURE__*/u((()=>import("./TurnstileWrapper-Co-t5mTh.mjs"))),Ea=/*#__PURE__*/u((()=>import("./HCaptchaWrapper-CUi9LJsp.mjs")));const Ia=n=>{let r=Aa();return c((()=>r.remove),[r.remove]),r.enabled&&r.provider?/*#__PURE__*/t(d,{fallback:null,children:/*#__PURE__*/e("div",{className:"hidden h-0 w-0",children:["turnstile"===r.provider&&/*#__PURE__*/t(Sa,{...n,captchaContext:r}),"hcaptcha"===r.provider&&/*#__PURE__*/t(Ea,{...n,captchaContext:r})]})}):null};var Pa=/*#__PURE__*/Object.freeze({__proto__:null,AccountNotFoundScreen:()=>import("./AccountNotFoundScreen-C6S8_GyN.mjs"),AffirmativeConsentScreen:()=>import("./AffirmativeConsentScreen-QfJBfI_f.mjs"),AllowlistRejectionScreen:()=>import("./AllowlistRejectionScreen-CX57yv4U.mjs"),AuthenticateWithWalletScreen:()=>import("./AuthenticateWithWalletScreen-CZJ-aWhZ.mjs"),AwaitingEvmToSolBridgingScreen:()=>import("./AwaitingEvmToSolBridgingScreen-C1CMtT4Y.mjs"),AwaitingExternalEthereumTransferScreen:()=>import("./AwaitingExternalEthereumTransferScreen-DX91STcF.mjs"),AwaitingPasswordlessCodeScreen:()=>import("./AwaitingPasswordlessCodeScreen-BuExr50N.mjs"),AwaitingSolToEvmBridgingScreen:()=>import("./AwaitingSolToEvmBridgingScreen-Bm1i_2qW.mjs"),CaptchaScreen:()=>import("./CaptchaScreen-B-hFDb5f.mjs"),CoinbaseOnrampStatusScreen:()=>import("./CoinbaseOnrampStatusScreen-OHm2RUBv.mjs"),ConnectLedgerScreen:()=>import("./ConnectLedgerScreen-BHLYW-F3.mjs"),ConnectOnlyLandingScreen:()=>import("./ConnectOnlyLandingScreen-C6nzEwpN.mjs"),ConnectOnlyStatusScreen:()=>import("./ConnectOnlyStatusScreen-CremlXDY.mjs"),ConnectOrCreateScreen:()=>import("./ConnectOrCreateScreen-262UvCdD.mjs"),ConnectionStatusScreen:()=>import("./ConnectionStatusScreen-mk5beBL7.mjs"),CrossAppAuthScreen:()=>import("./CrossAppAuthScreen-BXjEJQv6.mjs"),DelegatedActionsConsentScreen:()=>import("./DelegatedActionsConsentScreen-ANmQe-9G.mjs"),DelegatedActionsRevokeScreen:()=>import("./DelegatedActionsRevokeScreen-D9X7mWmI.mjs"),EmbeddedWalletConnectingScreen:()=>import("./EmbeddedWalletConnectingScreen-2g-RrIvW.mjs"),EmbeddedWalletCreatedScreen:()=>import("./EmbeddedWalletCreatedScreen-BXTAv4_-.mjs"),EmbeddedWalletKeyExportScreen:()=>import("./EmbeddedWalletKeyExportScreen-DYVHVHOj.mjs"),EmbeddedWalletOnAccountCreateScreen:()=>import("./EmbeddedWalletOnAccountCreateScreen-CYyMoMFF.mjs"),EmbeddedWalletPasswordCreateScreen:()=>import("./RecoveryPasswordCreateScreen-D4DI5Bom.mjs"),EmbeddedWalletPasswordUpdateScreen:()=>import("./EmbeddedWalletPasswordUpdateScreen-oT5ZcPQV.mjs"),EmbeddedWalletPasswordUpdateSplashScreen:()=>import("./EmbeddedWalletPasswordUpdateSplashScreen-BQcHDyuV.mjs"),ErrorScreen:()=>import("./ErrorScreen-CLfeO5pd.mjs"),FarcasterConnectStatusScreen:()=>import("./FarcasterConnectStatusScreen-CUO9DKCJ.mjs"),FarcasterSignerStatusScreen:()=>import("./FarcasterSignerStatusScreen-B135UOnV.mjs"),FundSolWalletWithExternalSolanaWallet:()=>import("./FundSolWalletWithExternalSolanaWallet-DO3ttgom.mjs"),FundingAmountEditScreen:()=>import("./FundingEditAmountScreen-BRQb2ffL.mjs"),FundingMethodSelectionScreen:()=>import("./FundingMethodSelectionScreen-DTt1Z5RI.mjs"),InAppBrowserLoginNotPossible:()=>import("./InAppBrowserLoginNotPossible-DH96QD2c.mjs"),InstallWalletScreen:()=>import("./InstallWalletScreen-PnK6VfrP.mjs"),LandingScreen:()=>import("./LandingScreen-D_EvjOHf.mjs"),LinkConflictScreen:()=>import("./LinkConflictScreen-B94e_-2N.mjs"),LinkEmailScreen:()=>import("./LinkEmailScreen-CT8gAQr3.mjs"),LinkPasskeyScreen:()=>import("./LinkPasskeyScreen-DYfWSjKR.mjs"),LinkPhoneScreen:()=>import("./LinkPhoneScreen-ccrKA6tf.mjs"),LoginFailedScreen:()=>import("./LoginFailedScreen-BwgxhbMf.mjs"),ManualTransferScreen:()=>import("./ManualTransferScreen-DgCG2P3B.mjs"),MfaAuthEnrollmentFlowScreen:()=>import("./MfaAuthEnrollmentFlowScreen-CNVUTOnE.mjs"),MfaAuthVerifyFlowScreen:()=>import("./MfaAuthVerifyFlowScreen-2nvvFipu.mjs"),MfaEnrollmentFlowScreen:()=>import("./MfaEnrollmentFlowScreen-DfnIqNNU.mjs"),MoonpayStatusScreen:()=>import("./MoonpayStatusScreen-D5fRCEb3.mjs"),OAuthStatusScreen:()=>import("./OAuthStatusScreen-DtLgYw89.mjs"),PasskeySelectSignupOrLogin:()=>import("./PasskeySelectSignupOrLogin-QoPhmagh.mjs"),PasskeyStatusScreen:()=>import("./PasskeyStatusScreen-DzjU3ZVT.mjs"),PasswordRecoveryScreen:()=>import("./PasswordRecoveryScreen-LZYGRBkP.mjs"),RecoveryOAuthScreen:()=>import("./RecoveryOAuthStatusScreen-DKfp8Udh.mjs"),RecoverySelectionScreen:()=>import("./RecoverySelectionScreen-B2V3518x.mjs"),SendTransactionScreen:()=>import("./index-2knYP69D.mjs"),SetAutomaticRecoveryScreen:()=>import("./SetAutomaticRecoveryScreen-C6cFVbSx.mjs"),SignRequestScreen:()=>import("./SignRequestScreen-BslfKJ1N.mjs"),StandardSignAndSendTransactionScreen:()=>import("./StandardSignAndSendTransactionScreen-D4OBsj5k.mjs"),TelegramAuthScreen:()=>import("./TelegramAuthScreen-BJq5f_Rq.mjs"),TransferFromWalletScreen:()=>import("./TransferFromWalletScreen-BHH0YcI4.mjs"),UpdateEmailScreen:()=>import("./UpdateEmailScreen-CMFBvYz5.mjs"),UpdatePhoneScreen:()=>import("./UpdatePhoneScreen-DmhHcNq3.mjs"),UserLimitReachedScreen:()=>import("./UserLimitReachedScreen-DNqgCf3B.mjs"),WalletInterstitialScreen:()=>import("./WalletInterstitialScreen-RS89fm6t.mjs")});function Wa(e){Zn("configureMfa",e)}const Ua=rr((()=>({inProgressMfaFlow:void 0})));const Na=Jn`
  :root {
     ${e=>Oa(e.palette)}
  };
`;const Oa=e=>{let t=function(e){return{"--privy-color-background":e.background,"--privy-color-background-2":e.background2,"--privy-color-background-3":e.background3,"--privy-color-foreground":e.foreground,"--privy-color-foreground-2":e.foreground2,"--privy-color-foreground-3":e.foreground3,"--privy-color-foreground-4":e.foreground4,"--privy-color-foreground-accent":e.foregroundAccent,"--privy-color-accent":e.accent,"--privy-color-accent-light":e.accentLight,"--privy-color-accent-hover":e.accentHover,"--privy-color-accent-dark":e.accentDark,"--privy-color-accent-darkest":e.accentDarkest,"--privy-color-success":e.success,"--privy-color-success-dark":e.successDark,"--privy-color-success-light":e.successLight,"--privy-color-success-bg":e.successBg,"--privy-color-error":e.error,"--privy-color-error-light":e.errorLight,"--privy-color-error-bg":e.errorBg,"--privy-color-error-bg-hover":e.errorBgHover,"--privy-color-warn":e.warn,"--privy-color-warn-light":e.warnLight,"--privy-color-warn-bg":e.warnBg,"--privy-color-warning-dark":e.warningDark,"--privy-color-error-dark":e.errorDark,"--privy-color-info-bg":e.infoBg,"--privy-color-info-bg-hover":e.infoBgHover,"--privy-color-border-default":e.borderDefault,"--privy-color-border-hover":e.borderHover,"--privy-color-border-focus":e.borderFocus,"--privy-color-border-error":e.borderError,"--privy-color-border-success":e.borderSuccess,"--privy-color-border-warning":e.borderWarning,"--privy-color-border-info":e.borderInfo,"--privy-color-border-interactive":e.borderInteractive,"--privy-color-border-interactive-hover":e.borderInteractiveHover,"--privy-color-background-hover":e.backgroundHover,"--privy-color-background-clicked":e.backgroundClicked,"--privy-color-background-disabled":e.backgroundDisabled,"--privy-color-background-interactive":e.backgroundInteractive,"--privy-color-background-interactive-hover":e.backgroundInteractiveHover,"--privy-color-background-interactive-clicked":e.backgroundInteractiveClicked,"--privy-color-background-interactive-disabled":e.backgroundInteractiveDisabled,"--privy-color-foreground-hover":e.foregroundHover,"--privy-color-foreground-clicked":e.foregroundClicked,"--privy-color-foreground-disabled":e.foregroundDisabled,"--privy-color-foreground-interactive":e.foregroundInteractive,"--privy-color-foreground-interactive-hover":e.foregroundInteractiveHover,"--privy-link-navigation-color":e.linkNavigationColor,"--privy-link-navigation-decoration":e.linkNavigationDecoration,"--privy-accent-has-good-contrast":e.accentHasGoodContrast,"--privy-color-icon-default":e.iconDefault,"--privy-color-icon-muted":e.iconMuted,"--privy-color-icon-subtle":e.iconSubtle,"--privy-color-icon-inverse":e.iconInverse,"--privy-color-icon-success":e.iconSuccess,"--privy-color-icon-warning":e.iconWarning,"--privy-color-icon-error":e.iconError,"--privy-color-icon-interactive":e.iconInteractive,"--privy-color-icon-default-hover":e.iconDefaultHover,"--privy-color-icon-muted-hover":e.iconMutedHover,"--privy-color-icon-subtle-hover":e.iconSubtleHover,"--privy-color-icon-default-clicked":e.iconDefaultClicked,"--privy-color-icon-muted-clicked":e.iconMutedClicked,"--privy-color-icon-subtle-clicked":e.iconSubtleClicked,"--privy-color-icon-default-disabled":e.iconDefaultDisabled,"--privy-color-icon-muted-disabled":e.iconMutedDisabled,"--privy-color-icon-subtle-disabled":e.iconSubtleDisabled,"--privy-color-icon-error-hover":e.iconErrorHover,"--privy-color-icon-interactive-hover":e.iconInteractiveHover,"--privy-color-icon-error-clicked":e.iconErrorClicked,"--privy-color-icon-interactive-clicked":e.iconInteractiveClicked,"--privy-color-icon-muted-disabled-alt":e.iconMutedDisabledAlt,"--privy-color-icon-subtle-disabled-alt":e.iconSubtleDisabledAlt,"--privy-border-radius-xs":"6px","--privy-border-radius-sm":"8px","--privy-border-radius-md":"12px","--privy-border-radius-mdlg":"16px","--privy-border-radius-lg":"24px","--privy-border-radius-full":"9999px","--privy-height-modal-full":"620px","--privy-height-modal-compact":"480px"}}(e);return Qn`
    ${Object.entries(t).map((([e,t])=>`${e}: ${t};`)).join("\n")}
  `},Ra=Yn.div`
  // css normalize only the privy application to avoid conflicts
  // with consuming application
  ${"\n  *,\n  ::before,\n  ::after {\n    box-sizing: border-box;\n    border-width: 0;\n    border-style: solid;\n  }\n\n  line-height: 1.15;\n  -webkit-text-size-adjust: 100%;\n  -moz-tab-size: 4;\n  tab-size: 4;\n  font-feature-settings: normal;\n\n  margin: 0;\n  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n\n  abbr:where([title]) {\n    text-decoration: underline dotted;\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-size: inherit;\n    font-weight: inherit;\n    font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif,\n    'Apple Color Emoji', 'Segoe UI Emoji';\n    display: inline;\n  }\n\n  a {\n    color: inherit;\n    text-decoration: inherit;\n  }\n\n  b,\n  strong {\n    font-weight: bolder;\n  }\n\n  code,\n  kbd,\n  samp,\n  pre {\n    font-family: ui-monospace, SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;\n    font-size: 1em;\n  }\n\n  small {\n    font-size: 80%;\n  }\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n\n  button,\n  input,\n  optgroup,\n  select,\n  textarea {\n    font-family: inherit;\n    font-size: 100%;\n    font-weight: inherit;\n    line-height: inherit;\n    color: inherit;\n    margin: 0;\n    padding: 0;\n  }\n\n  button,\n  select {\n    text-transform: none;\n  }\n\n  button,\n  [type='button'],\n  [type='reset'],\n  [type='submit'] {\n    -webkit-appearance: button;\n    background-color: transparent;\n    background-image: none;\n  }\n\n  ::-moz-focus-inner {\n    border-style: none;\n    padding: 0;\n  }\n\n  :-moz-focusring {\n    outline: 1px dotted ButtonText;\n  }\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  ::-webkit-inner-spin-button,\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  [type='search'] {\n    -webkit-appearance: textfield;\n    outline-offset: -2px;\n  }\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  ::-webkit-file-upload-button {\n    -webkit-appearance: button;\n    font: inherit;\n  }\n\n  summary {\n    display: list-item;\n  }\n\n  blockquote,\n  dl,\n  dd,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  hr,\n  figure,\n  p,\n  pre {\n    margin: 0;\n  }\n\n  fieldset {\n    margin: 0;\n    padding: 0;\n  }\n\n  legend {\n    padding: 0;\n  }\n\n  ol,\n  ul,\n  menu {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  textarea {\n    resize: vertical;\n  }\n\n  input::placeholder,\n  textarea::placeholder {\n    opacity: 1;\n    color: #9ca3af;\n  }\n\n  button,\n  [role='button'] {\n    cursor: pointer;\n  }\n\n  :disabled {\n    cursor: default;\n  }\n\n  img,\n  svg,\n  video,\n  canvas,\n  audio,\n  iframe,\n  embed,\n  object {\n    display: block;\n  }\n\n  img,\n  video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  [hidden] {\n    display: none;\n  }\n"}

  // Privy styles
  color: var(--privy-color-foreground-2);

  h3 {
    font-size: 16px;
    line-height: 24px;
    font-weight: 500;
    color: var(--privy-color-foreground-2);
  }

  h4 {
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: var(--privy-color-foreground);
  }

  p {
    font-size: 13px;
    line-height: 20px;
    color: var(--privy-color-foreground-2);
  }

  button:focus,
  input:focus,
  optgroup:focus,
  select:focus,
  textarea:focus {
    outline: none;
    border-color: var(--privy-color-accent-light);
    box-shadow: 0 0 0 3px var(--privy-color-border-focus);
  }

  .mobile-only {
    @media (min-width: 441px) {
      display: none;
    }
  }

  /* Animations */

  @keyframes fadein {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
`,Ma=({children:n,open:a,onClick:i,...s})=>/*#__PURE__*/t(ar,{show:a,as:r.Fragment,children:/*#__PURE__*/e(ir,{onClose:i,...s,as:Fa,children:[/*#__PURE__*/t(sr,{as:r.Fragment,enterFrom:"entering",leaveTo:"leaving",children:/*#__PURE__*/t(xa,{id:"privy-dialog-backdrop","aria-hidden":"true"})}),/*#__PURE__*/t(Da,{children:/*#__PURE__*/t(sr,{as:r.Fragment,enterFrom:"entering",leaveTo:"leaving",children:/*#__PURE__*/t(or,{as:La,children:n})})})]})});let xa=Yn.div`
  position: fixed;
  inset: 0;

  transition: backdrop-filter 100ms ease;
  backdrop-filter: blur(3px);
  -webkit-backdrop-filter: blur(3px);

  &.entering,
  &.leaving {
    backdrop-filter: unset;
    -webkit-backdrop-filter: unset;
  }
`,Fa=Yn.div`
  position: relative;
  z-index: 999999;
`,Da=Yn.div`
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  min-height: 100vh;
`;const La=Yn.div`
  // reset some default dialog styles
  padding: 0;
  background: transparent;
  border: none;
  width: 100%;
  pointer-events: auto;

  outline: none;
  display: block;

  /*
   * Normally it is bad to mix media queries like this We are doing
   * this here specifically for animations to avoid weird jank.
   */
  /* Mobile animation is a bottom drawer */
  @media (max-width: 440px) {
    opacity: 1;
    transform: translate3d(0, 0, 0);
    transition: transform 200ms ease-in;
    position: fixed;
    bottom: 0;

    &.entering,
    &.leaving {
      opacity: 0;
      transform: translate3d(0, 100%, 0);
      transition:
        transform 150ms ease-in 0ms,
        opacity 0ms ease 150ms;
    }
  }

  /* Tablet/Desktop animation is a fade in */
  @media (min-width: 441px) {
    opacity: 1;
    transition: opacity 100ms ease-in;

    &.entering,
    &.leaving {
      opacity: 0;
      transition-delay: 5ms;
    }

    margin: auto;
    width: 360px;
    box-shadow: 0px 8px 36px rgba(55, 65, 81, 0.15);
    border-radius: var(--privy-border-radius-lg);
  }
`;Yn.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
`;const ja=()=>{let{ready:e}=C(),{currentScreen:t}=_(),[n,r]=o(null),[a,i]=o(!1),l=function(e){let[t,n]=o(!1),r=s(null),a=s(null),i=s(null);return c((()=>{if(r.current&&(clearTimeout(r.current),r.current=null),a.current&&(clearTimeout(a.current),a.current=null),e)i.current=Date.now(),r.current=setTimeout((()=>{n(!0)}),150);else if(null!==i.current){let e=Date.now()-i.current;if(e>=150){let t=Math.max(0,400-(e-150));a.current=setTimeout((()=>{n(!1),i.current=null}),t)}else r.current&&(clearTimeout(r.current),r.current=null),n(!1),i.current=null}return()=>{r.current&&clearTimeout(r.current),a.current&&clearTimeout(a.current)}}),[e]),t}(a);return c((()=>{if(!t)return r(null),void i(!1);i(!0),Pa[t]().then((n=>{(!t||e||n.default.isShownBeforeReady)&&(r((()=>n.default.component)),i(!1))})).catch((()=>{r(null),i(!1)}))}),[t,e]),{component:n,isLoading:l}};let za=/*#__PURE__*/u((()=>import("./MfaVerifyFlowScreen-BwerwBz5.mjs"))),qa=/*#__PURE__*/u((()=>(e=>Pa[e]().then((e=>({default:e.default.component}))))("MfaAuthVerifyFlowScreen"))),Ha=()=>/*#__PURE__*/t(Ya,{children:/*#__PURE__*/t(K,{})}),Va=()=>{let{currentScreen:r}=_(),a=Ua((e=>e.inProgressMfaFlow)),i=()=>Ua.setState({inProgressMfaFlow:void 0}),{component:s,isLoading:l}=ja();return function(){let{isModalOpen:e}=C(),{headless:t}=Xe(),{currentScreen:n}=_(),{status:r,execute:a,reset:i,enabled:s}=Aa(),[l,d]=o(!1);c((()=>{!e&&s&&i()}),[e,s,i]),c((()=>{n?Pa[n]().then((e=>{d(!!e.default.isCaptchaRequired)})).catch((()=>{d(!1)})):d(!1)}),[n]),c((()=>{e&&l&&!t&&"ready"===r&&s&&a()}),[e,l,t,r,s,a])}(),r||"txn"!==a?l?/*#__PURE__*/t(Ha,{}):s?
/*#__PURE__*/e(n,{children:[/*#__PURE__*/t(V,{$if:!!a,children:/*#__PURE__*/t(d,{children:/*#__PURE__*/t(s,{})})}),/*#__PURE__*/e(d,{children:["txn"===a&&/*#__PURE__*/t(za,{onClose:i}),"auth"===a&&/*#__PURE__*/t(qa,{})]})]}):null:/*#__PURE__*/t(d,{children:/*#__PURE__*/t(za,{onClose:i})})},Ba=()=>{let e=s(null);/*#__PURE__*/return t(Ga,{style:{height:B(e)},id:"privy-modal-content",children:/*#__PURE__*/t("div",{ref:e,children:/*#__PURE__*/t(Va,{})})})};const Ka=({open:e})=>{let n=Xe(),{gracefulClosePrivyModal:r}=(()=>{let{closePrivyModal:e}=Ie(),{onUserCloseViaDialogOrKeybindRef:t}=_();return{gracefulClosePrivyModal:h((()=>{if(!t?.current)return e({shouldCallAuthOnSuccess:!1});t.current()}),[e])}})(),a=Ua((e=>e.inProgressMfaFlow));return Wa({onMfaRequired:()=>{n.mfa.noPromptOnMfaRequired||Ua.setState({inProgressMfaFlow:"txn"})}}),n.render.standalone?/*#__PURE__*/t(Ra,{children:/*#__PURE__*/t($a,{id:"privy-modal-content",children:/*#__PURE__*/t(Va,{})})}):/*#__PURE__*/t(Ma,{open:!(!e&&!a),id:"privy-dialog","aria-label":"log in or sign up","aria-labelledby":"privy-dialog-title",onClick:()=>r(),children:/*#__PURE__*/t(Ra,{children:/*#__PURE__*/t(Ba,{})})})};let $a=Yn.div`
  display: flex;
  flex-direction: column;
  text-align: center;
  font-size: 14px;
  line-height: 20px;
  width: 100%;
  background: var(--privy-color-background);
  padding: 0 16px;
`,Ga=Yn($a)`
  transition: height 150ms ease-out;
  overflow-x: hidden;
  overflow-y: auto;
  scrollbar-width: none;

  // Ensure the modal gets pinned to the top if it ever gets too tall
  max-height: calc(100svh - 32px);

  border-radius: var(--privy-border-radius-lg) var(--privy-border-radius-lg) 0 0;
  box-shadow: 0px 0px 36px rgba(55, 65, 81, 0.15);

  @media (min-width: 441px) {
    box-shadow: 0px 8px 36px rgba(55, 65, 81, 0.15);
    border-radius: var(--privy-border-radius-lg);
  }
`,Ya=Yn.div`
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  padding: 2rem;
`;function Ja(e){let n=s(null),r=s();return c((()=>{r.current?.remove(),r.current=function({botUsername:e,scriptHost:t}){let n=document.createElement("script"),{origin:r}=new URL(t);return n.async=!0,n.src=`${r}/js/telegram-login.js`,n.setAttribute("data-telegram-login",e),n.setAttribute("data-request-access","write"),n.setAttribute("data-lang","en"),n}(e),n.current?.after(r.current)}),[e]),/*#__PURE__*/t("div",{ref:n,hidden:!0})}const Qa=()=>{let{ready:e}=ge(),{client:t}=Ie();return c((()=>{let n=()=>{if(!t.connectors||!e)return;let n=t.connectors.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt,id:e.meta.id})));Me.put(et,n)};return t.connectors?.on("walletsUpdated",n),()=>{t.connectors?.off("walletsUpdated",n)}}),[e,t.connectors]),null};class Za extends j{async initialize(){let e=await this.createProvider();this.provider=e,this.proxyProvider.setWalletProvider(e),this.subscribeListeners(),e.session&&(this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=$(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown"),this.connected=!0,await this.syncAccounts()),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),this.getConnectedWallet()}async isConnected(){return!!this.walletProvider?.connected}get walletBranding(){let e=this.walletProvider?.session?.peer.metadata.icons?.[0];return{name:G(this.walletProvider?.session?.peer.metadata.name||"")||"WalletConnect",icon:"string"==typeof e?e:xe,id:this.walletProvider?.session?.peer.metadata.name.toLowerCase()||"wallet_connect_v2"}}async resetConnection(e){this.walletProvider&&this.walletProvider.connected&&(await this.walletProvider.disconnect(),this.walletProvider.signer.session=void 0,this.walletClientType=e,this.redirectUri=void 0,this.fallbackUniversalRedirectUri=void 0,xn(),this.onDisconnect())}async promptConnection(){if(this.provider)return new Promise(((e,t)=>{(async()=>{let t="",n=await Promise.race([this.walletProvider?.enable(),this.proxyProvider.walletTimeout()]);if(n?.length&&(t=n[0]),!t||""===t)throw new ke("Unable to retrieve address");this.walletProvider?.session?.peer.metadata.url&&(this.walletEntry=$(this.walletProvider?.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown",this.proxyProvider.rpcTimeoutDuration=Q(this.rpcConfig,this.walletClientType)),this.connected=!0,await this.syncAccounts(n),e()})().catch((e=>{t(e?Re(e):new ke("Unknown error during connection"))}))}))}disconnect(){this.walletProvider?.disconnect().then((()=>this.onDisconnect())).catch((()=>console.warn("Unable to disconnect WalletConnect provider")))}get walletProvider(){return this.proxyProvider.walletProvider}setWalletProvider(e){this.proxyProvider.setWalletProvider(e)}async createProvider(){let e={};for(let t of this.chains){let n=Y(t.id,this.chains,this.rpcConfig,this.privyAppId);n&&(e[t.id]=n)}let t=this.shouldEnforceDefaultChainOnConnect?[this.defaultChain.id]:[],n=this.chains.map((e=>e.id)),r=await lr.init({projectId:this.walletConnectCloudProjectId,chains:t,optionalChains:n,optionalEvents:dr,optionalMethods:cr,rpcMap:e,showQrModal:!1,metadata:{description:this.privyAppName,name:this.privyAppName,url:window.location.origin,icons:[]}});return r.on("display_uri",(e=>{if(r.signer.abortPairingAttempt(),Fn(),!this.showPrivyQrModal)throw new ke("WalletConnect modal not available - Privy handles wallet connections through its own UI");if(ft&&this.walletEntry){let{redirect:t,href:n}=Dn(e,this.walletEntry);Rn(t,"_self"),Ln({href:n,name:this.walletEntry.metadata?.shortName||this.walletEntry.name});let r=jn(e,this.walletEntry);return this.redirectUri=t,this.fallbackUniversalRedirectUri=r?.redirect,this.showPrivyQrModal({native:t,universal:t})}if(this.redirectUri=void 0,this.walletEntry){let t=jn(e,this.walletEntry);this.fallbackUniversalRedirectUri=t?.redirect}this.showPrivyQrModal({native:e,universal:void 0})})),r.on("connect",(()=>{r.session?.peer.metadata.url&&(this.walletEntry=$(r.session?.peer.metadata.url),this.walletClientType=this.walletEntry?.slug||"unknown")})),r}async enableProvider(){return this.walletProvider?.connected?Promise.resolve(this.walletProvider.accounts):await(this.walletProvider?.enable())}setWalletEntry(e,t){this.walletEntry=e,this.showPrivyQrModal=t}constructor({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,shouldEnforceDefaultChainOnConnect:a,privyAppId:i,privyAppName:s,walletClientType:o}){super(o||"unknown",n,r,t),this.connectorType="wallet_connect_v2",this.privyAppId=i,this.privyAppName=s,this.walletConnectCloudProjectId=e,this.rpcConfig=t,this.shouldEnforceDefaultChainOnConnect=a,this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),o&&(this.walletEntry=J(o),this.walletClientType=o)}}const Xa=["error","invalid_request_arguments","wallet_not_on_device","invalid_recovery_pin","insufficient_funds","missing_or_invalid_mfa","mfa_verification_max_attempts_reached","mfa_timeout","twilio_verification_failed"];class ei extends Error{constructor(e,t){super(t),this.type=e}}function ti(e){let t=e.type;return"string"==typeof t&&Xa.includes(t)}function ni(e){return ti(e)&&"wallet_not_on_device"===e.type}function ri(e){return ti(e)&&("invalid_recovery_pin"===e.type||"invalid_request_arguments"===e.type)}function ai(e){return!!ti(e)&&"mfa_timeout"===e.type}function ii(e){return!!ti(e)&&"missing_or_invalid_mfa"===e.type}function si(e){return!!ti(e)&&"mfa_verification_max_attempts_reached"===e.type}function oi(e){return!(!ti(e)||!e.message.includes("code 429"))}function li(e){return!!function(e){let t=e.type;return"string"==typeof t&&"client_error"===t}(e)&&"MFA canceled"===e.message}async function ci(e,t,n,r,a,i=!1){let s=i,o=async o=>{if(s&&t&&t.length>0){o===(i?0:1)?a("configureMfa","onMfaRequired",{mfaMethods:t}):r.current?.reject(new ei("missing_or_invalid_mfa","MFA verification failed, retry."));let s=await new Promise(((e,t)=>{n.current={resolve:e,reject:t},setTimeout((()=>{let e=new ei("mfa_timeout","Timed out waiting for MFA code");r.current?.reject(e),t(e)}),3e5)}));return await e(s)}return await e()},l=null;for(let e=0;e<4;e++)try{l=await o(e),r.current?.resolve(void 0);break}catch(e){if("missing_or_invalid_mfa"!==e.type)throw r.current?.resolve(void 0),e;s=!0}if(null===l){let e=new ei("mfa_verification_max_attempts_reached","Max MFA verification attempts reached");throw r.current?.reject(e),e}return l}var di;let ui=(di=0,()=>"id-"+di++);function hi(e){return void 0!==e.error}let pi=new class{enqueue(e,t){this.callbacks[e]=t}dequeue(e,t){let n=this.callbacks[t];if(!n)throw Error(`cannot dequeue ${e} event: no event found for id ${t}`);switch(delete this.callbacks[t],e){case"privy:iframe:ready":case"privy:user-signer:sign":case"privy:wallets:add":case"privy:wallets:import":case"privy:wallets:set-recovery":case"privy:wallets:connect":case"privy:wallets:recover":case"privy:wallets:rpc":case"privy:wallet:create":case"privy:mfa:verify":case"privy:mfa:init-enrollment":case"privy:mfa:submit-enrollment":case"privy:mfa:unenroll":case"privy:mfa:clear":case"privy:auth:unlink-passkey":case"privy:farcaster:init-signer":case"privy:farcaster:sign":case"privy:solana-wallet:create":case"privy:delegated-actions:consent":return n;default:throw Error(`invalid wallet event type ${e}`)}}constructor(){this.callbacks={}}},wi=new Map,mi=(e,t)=>"bigint"==typeof t?t.toString():t;function yi(e,t,n,r){let a=n.contentWindow;if(!a)throw Error("iframe not initialized");let i=((e,t)=>`${e}${JSON.stringify(t,mi)}`)(e,t);if("privy:wallet:create"===e){let e=wi.get(i);if(e)return e}let s=new Promise(((n,i)=>{let s=ui();pi.enqueue(s,{resolve:n,reject:i}),a.postMessage({id:s,event:e,data:t},r)})).finally((()=>{wi.delete(i)}));return wi.set(i,s),s}function gi(e){let n=tt(),r=s(null),a=s(e.mfaMethods),i=Xn(),[l,d]=o(!1);return c((()=>{a.current=e.mfaMethods}),[e.mfaMethods]),c((()=>{if(!l)return;let t=r.current;if(!t)return;function n(t){var n;t&&t.origin===e.origin&&"string"==typeof(n=t.data).event&&/^privy:.+/.test(n.event)&&function(e){switch(e.event){case"privy:iframe:ready":let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data);case"privy:user-signer:sign":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:add":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:set-recovery":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:connect":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:recover":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallets:rpc":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:wallet:create":let n=pi.dequeue(e.event,e.id);return hi(e)?n.reject(new ei(e.error.type,e.error.message)):n.resolve(e.data);case"privy:wallets:import":let r=pi.dequeue(e.event,e.id);return hi(e)?r.reject(new ei(e.error.type,e.error.message)):r.resolve(e.data);case"privy:mfa:verify":let a=pi.dequeue(e.event,e.id);return hi(e)?a.reject(new ei(e.error.type,e.error.message)):a.resolve(e.data);case"privy:mfa:init-enrollment":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:submit-enrollment":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:unenroll":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:mfa:clear":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:auth:unlink-passkey":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:solana-wallet:create":let i=pi.dequeue(e.event,e.id);return hi(e)?i.reject(new ei(e.error.type,e.error.message)):i.resolve(e.data);case"privy:farcaster:init-signer":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:farcaster:sign":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}case"privy:delegated-actions:consent":{let t=pi.dequeue(e.event,e.id);return hi(e)?t.reject(new ei(e.error.type,e.error.message)):t.resolve(e.data)}default:console.warn("Unsupported wallet proxy method:",e)}}(t.data)}let s={signWithUserSigner:n=>ci((r=>yi("privy:user-signer:sign",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),addWallet:n=>ci((r=>yi("privy:wallets:add",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),setRecovery:n=>ci((r=>yi("privy:wallets:set-recovery",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),connect:n=>ci((r=>yi("privy:wallets:connect",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),recover:n=>ci((r=>yi("privy:wallets:recover",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i,!n.recoveryAccessToken&&!n.recoveryPassword&&!n.recoverySecretOverride),rpc:n=>ci((r=>yi("privy:wallets:rpc",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),create:n=>yi("privy:wallet:create",n,t,e.origin),importWallet:n=>yi("privy:wallets:import",n,t,e.origin),createSolana:n=>ci((r=>yi("privy:solana-wallet:create",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),createDelegatedAction:n=>yi("privy:delegated-actions:consent",n,t,e.origin),verifyMfa:n=>ci((r=>yi("privy:mfa:verify",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i,!0),initEnrollMfa:n=>ci((r=>yi("privy:mfa:init-enrollment",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),submitEnrollMfa:n=>ci((r=>yi("privy:mfa:submit-enrollment",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),unenrollMfa:n=>ci((r=>yi("privy:mfa:unenroll",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),clearMfa:n=>yi("privy:mfa:clear",n,t,e.origin),unlinkPasskeyAccount:n=>ci((r=>yi("privy:auth:unlink-passkey",{...n,...r},t,e.origin)),a.current,e.mfaPromise,e.mfaSubmitPromise,i),initFarcasterSigner:n=>yi("privy:farcaster:init-signer",n,t,e.origin),signFarcasterMessage:n=>yi("privy:farcaster:sign",n,t,e.origin)};window.addEventListener("message",n);let o=new AbortController;return Z((()=>yi("privy:iframe:ready",{},t,e.origin)),{abortSignal:o.signal}).then((()=>e.onLoad(s)),((...t)=>{console.warn("Privy iframe failed to load: ",...t),e.onLoadFailed()})),()=>{window.removeEventListener("message",n),o.abort()}}),[l]),n?
/*#__PURE__*/t("iframe",{ref:r,width:"0",height:"0",style:{display:"none",height:"0px",width:"0px"},onLoad:()=>d(!0),src:ur({origin:e.origin,path:`/apps/${e.appId}/embedded-wallets`,query:{caid:e.clientAnalyticsId,client_id:e.appClientId}})}):null}const fi=({address:e,user:t})=>{let n=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!n)throw new Te("Address to delegate is not associated with current user.");if(!Fe(n))throw new Te(`useDelegatedActions is not supported for ${n.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:n.address,chainType:n.chainType,walletIndex:n.walletIndex??0}},vi=({address:e,user:t})=>{let n=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!n)throw new Te("Address to delegate is not associated with current user.");let r=n.imported?n:b(t);if(!r)throw new Te("Unable to determine root address for delegated address.");if(!Fe(r))throw new Te(`useDelegatedActions is not supported for ${r.chainType} wallets. Use the useSessionSigners hook to provision server side access on behalf of your users.`);return{address:r.address,chainType:r.chainType,imported:r.imported}},Ai=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.delegated));const ki="popup-privy-oauth",Ti="PRIVY_OAUTH_USE_BROADCAST_CHANNEL";class Ci{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(xt,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider,mode:this.meta.disableSignup?"no-signup":"login-or-sign-up"})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Ft,{authorization_code:this.meta.authorizationCode,state_code:this.meta.stateCode,code_verifier:this.meta.codeVerifier,provider:this.meta.provider})}catch(e){throw Ce(e)}}constructor(e){this.meta=e}}async function _i({api:e,requesterAppId:t,providerAppId:n}){let r=(await e.get(`/api/v1/apps/${t}/cross-app/connections`)).connections.find((e=>e.provider_app_id===n));if(!r)throw new Te("Invalid connected app");return{name:r.provider_app_name,logoUrl:r.provider_app_icon_url||void 0,apiUrl:r.provider_app_custom_api_url,readOnly:r.read_only,customAuthAuthorizeUrl:r.provider_app_custom_auth_authorize_url,customAuthTransactUrl:r.provider_app_custom_auth_transact_url}}const bi=async({user:e,address:t,client:n,request:r,requesterAppId:a,reconnect:i})=>{n.createAnalyticsEvent({eventName:"cross_app_request_started",payload:{address:t,method:r.method}});let s=e?.linkedAccounts.find((e=>"cross_app"===e.type&&(e.embeddedWallets.some((e=>e.address===t))||e.smartWallets.some((e=>e.address===t)))));if(!e||!s)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Cannot request a signature with this wallet address",address:t}}),new Te("Cannot request a signature with this wallet address");let o=n.getProviderAccessToken(s.providerApp.id),l=await _i({api:n.api,requesterAppId:a,providerAppId:s.providerApp.id});if(!o){if(l.readOnly)throw console.error("cannot transact against a read-only provider app"),new Te("Cannot transact against a read-only provider app");await i({appId:s.providerApp.id,action:"link"})&&(o=n.getProviderAccessToken(s.providerApp.id))}if(!o)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Transactions require a valid token",address:t}}),new Te("Transactions require a valid token");let c=new URL(l.customAuthTransactUrl||`${l.apiUrl}/oauth/transact`);c.searchParams.set("token",o||""),c.searchParams.set("request",Si(r));let d=Et({location:c.href});if(!d)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Missing token",address:t}}),new Te("Failed to initialize signature request");return new Promise(((e,a)=>{let i=setTimeout((()=>{c(),a(new Te("Request timeout")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Request timeout",address:t}})}),12e4),o=setInterval((()=>{d.closed&&(c(),a(new Te("User rejected request")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"User rejected request",address:t}}))}),300),l=i=>{i.data&&("set"===i.data.token?.action&&void 0!==i.data.token?.value?n.storeProviderAccessToken(s.providerApp.id,i.data.token.value):"clear"===i.data.token?.action&&n.storeProviderAccessToken(s.providerApp.id,null),"PRIVY_CROSS_APP_ACTION_RESPONSE"===i.data.type&&i.data.result&&(c(),e(i.data.result),n.createAnalyticsEvent({eventName:"cross_app_request_success",payload:{address:t,method:r.method}})),"PRIVY_CROSS_APP_ACTION_ERROR"===i.data.type&&i.data.error&&(c(),a(i.data.error),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:i.data.error,address:t}})))};window.addEventListener("message",l);let c=()=>{d.close(),clearInterval(o),clearTimeout(i),window.removeEventListener("message",l)}}))};let Si=e=>JSON.stringify({content:{request:{request:Ei(e,hr)}},timestamp:Date.now(),callbackUrl:window.origin});const Ei=(e,t)=>"bigint"==typeof e?t(e):Array.isArray(e)?e.map((e=>Ei(e,t))):e&&"object"==typeof e?Object.fromEntries(Object.entries(e).map((([e,n])=>[e,Ei(n,t)]))):e;function Ii({isCreatingWallet:e,skipSplashScreen:t}){return e?"EmbeddedWalletPasswordCreateScreen":t?"EmbeddedWalletPasswordUpdateScreen":"EmbeddedWalletPasswordUpdateSplashScreen"}function Pi({walletAction:e,availableRecoveryMethods:t,legacySetWalletPasswordFlow:n,isResettingPassword:r,showAutomaticRecovery:a}){return a?"SetAutomaticRecoveryScreen":n||1===t.length?Ii({isCreatingWallet:"create"===e,skipSplashScreen:r}):"RecoverySelectionScreen"}function Wi(e){switch(e){case"user-passcode":return"PasswordRecoveryScreen";case"google-drive":case"icloud":return"RecoveryOAuthScreen";default:throw Error("Recovery method not supported")}}function Ui(e,t){if(e.onComplete)switch(t){case"external":e.fundingResult?e.onComplete({...e.fundingResult,fundingMethod:t}):e.onComplete({status:"cancelled",address:e.address,fundingMethod:t,amount:e.amount});break;case null:e.onComplete({status:"cancelled",address:e.address,fundingMethod:void 0,amount:e.amount});break;default:e.onComplete({status:"completed",address:e.address,fundingMethod:t,amount:e.amount})}}function Ni(e,t,n,r,a,i,s){return{...e,funding:e?.funding?{...e.funding,fundingResult:{status:t,address:e.funding.address,fundingMethod:void 0,transactionHash:n,amount:e.funding.amount,assetType:a?i?.symbol||"ETH":s.nativeCurrency.symbol||"ETH",metadata:{walletClientType:r}}}:void 0,solanaFundingData:e?.solanaFundingData,sendTransaction:e?.sendTransaction}}const Oi=new Map([["FundingMethodSelectionScreen",null],["TransferFromWalletScreen","external"],["FundingAmountEditScreen","external"],["ConnectOnlyLandingScreen","external"],["ConnectOnlyStatusScreen","external"],["AwaitingExternalEthereumTransferScreen","external"],["AwaitingEvmToSolBridgingScreen","external"],["AwaitingSolToEvmBridgingScreen","external"],["ManualTransferScreen","manual"],["MoonpayStatusScreen","moonpay"]]);function Ri(e){let t=e.toLowerCase();return!!window?.webkit?.messageHandlers?.ReactNativeWebView||!!window?.ReactNativeWebView||["fbav","fban","instagram","snapchat","linkedinapp"].some((e=>t.includes(e)))}async function Mi({rpc:e,address:t}){return(await e.getBalance(t,{commitment:"confirmed"}).send()).value??0n}let xi={apple_oauth:"apple",custom_auth:"custom",discord_oauth:"discord",email:"email",farcaster:"farcaster",github_oauth:"github",google_oauth:"google",instagram_oauth:"instagram",linkedin_oauth:"linkedin",passkey:"passkey",phone:"sms",spotify_oauth:"spotify",telegram:"telegram",tiktok_oauth:"tiktok",line_oauth:"line",twitch_oauth:"twitch",twitter_oauth:"twitter",wallet:"siwe",smart_wallet:"siwe",cross_app:"privy:"};const Fi=e=>{if(S(e))return{displayName:e.replace("custom:",""),loginMethod:"custom"};let t=xi[e];return"wallet"===e||"phone"===e?{displayName:e,loginMethod:t}:{displayName:t,loginMethod:t}};async function Di(e,t,n,r){let a=Be(e),{chain:i,...s}=await(async()=>r?await r():await t.prepareTransactionRequest({...a,account:{address:n,type:"json-rpc"}}))();return{...s,type:Ke[s.type]}}const Li=()=>{let e=Xe(),{user:t}=C(),{client:n,refreshSessionAndUser:r,walletProxy:a}=Ie();return{migrate:h((async()=>{if("legacy-embedded-wallets-only"===e.embeddedWallets.mode)return{success:!0,migrated:!1};if(!t)throw new Te("User must be authenticated before migrating wallets",_e.MUST_BE_AUTHENTICATED);if(!a)throw new Te("Cannot connect to wallet proxy");let i=await n.getAccessToken();if(!i)throw new Te("User must be authenticated before migrating wallets",_e.MUST_BE_AUTHENTICATED);let s=t.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&Fe(e)&&!E(e)));if(0===s.length)return{success:!0,migrated:!1};let o=s.filter((e=>e.imported)),l=s.filter((e=>!e.imported));if(l.length>0){let e=l.find((e=>"ethereum"===e.chainType&&0===e.walletIndex))??l.find((e=>"solana"===e.chainType&&0===e.walletIndex))??null;if(!e)throw new Te("Primary wallet not found");let{entropyId:t,entropyIdVerifier:n}=fe(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(r){if(!ni(r)||"privy"!==e.recoveryMethod)throw r;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!1},delegatedWallets:l.map((e=>({address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0})))})}for(let e of o){let{entropyId:t,entropyIdVerifier:n}=fe(e);try{await a.connect({accessToken:i,entropyId:t,entropyIdVerifier:n})}catch(o){if(!ni(o)||"privy"!==e.recoveryMethod)throw o;await a.recover({accessToken:i,entropyId:t,entropyIdVerifier:n})}await a.createDelegatedAction({accessToken:i,rootWallet:{address:e.address,chainType:e.chainType,imported:!0},delegatedWallets:[{address:e.address,chainType:e.chainType,walletIndex:e.walletIndex??0}]})}return await r(),{success:!0,migrated:!0}}),[e.embeddedWallets.mode,t,a,n,r])}},ji=({disabled:e})=>{let{migrate:t}=Li(),{user:n}=C(),{walletProxy:r}=Ie(),a=s(!1);return c((()=>{!e&&!a.current&&n&&r&&(a.current=!0,t().catch((e=>{console.debug("Unable to migrate wallets: ",e)})).finally((()=>{a.current=!1})))}),[n,r,e,t]),null},zi=e=>({id:e.id,raw_id:e.rawId,response:{client_data_json:e.response.clientDataJSON,authenticator_data:e.response.authenticatorData,signature:e.response.signature,user_handle:e.response.userHandle},authenticator_attachment:e.authenticatorAttachment,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},type:e.type}),qi=rr((()=>({ethereum:[]}))),Hi=()=>qi.getState().ethereum;class Vi{async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Qt,{token:this.meta.token})}catch(e){throw Ce(e)}}async link(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(Zt,{token:this.meta.token})}catch(e){throw Ce(e)}}constructor(e){this.meta={token:e}}}const Bi=(e,t)=>!I(e)&&("all-users"===t||"users-without-wallets"===t&&!Ki(e).length);let Ki=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"ethereum"===e.chainType));const $i=(e,t)=>!P(e)&&("all-users"===t||"users-without-wallets"===t&&!Gi(e).length);let Gi=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"solana"===e.chainType));const Yi=()=>{let{walletProxy:e,recoverEmbeddedWallet:t,setUser:n,refreshSessionAndUser:r,privy:a,client:i}=Ie(),s=Xe();return{create:async({walletIndex:o,chainType:l,latestUser:c,recoveryMethod:d,recoveryPassword:u,recoveryAccessToken:h,idempotencyKey:p})=>{let w=c;w||(w=await r());let m=await i.getAccessToken();if(!w||!m||!e)throw Error("User must be authenticated before creating a Privy wallet");return await zn({appConfig:s,user:w,refreshSessionAndUser:r,privy:a,accessToken:m,proxy:e,recoverEmbeddedWallet:t,setUser:n,walletIndex:o,chainType:l,recoveryMethod:d,recoveryPassword:u,recoveryAccessToken:h,idempotencyKey:p})}}};function Ji({subscribe:e,getExternalJwt:t,enabled:n=!0,onAuthenticated:r,onUnauthenticated:a,onError:i}){let{client:l,setAuthenticated:d,setUser:u,setIsNewUser:h}=Ie(),{logout:p,authenticated:w,ready:m}=qn(),{create:y}=Yi(),g=Xe();if(!l)throw new Te("`useSyncJwtBasedAuthState` must be used within a `PrivyProvider`");let[f,v]=o({status:"initial"}),A=s(),k=s(!1),T=s(t);c((()=>{T.current=t}),[t]);let C=s(r);c((()=>{C.current=r}),[r]);let _=s(a);c((()=>{_.current=a}),[a]);let b=s(i);c((()=>{b.current=i}),[i]);let S=s(y);c((()=>{S.current=y}),[y]);let E=s(g.embeddedWallets.ethereum.createOnLogin);c((()=>{E.current=g.embeddedWallets.ethereum.createOnLogin}),[g.embeddedWallets.ethereum.createOnLogin]);let I=s(g.embeddedWallets.solana.createOnLogin);c((()=>{I.current=g.embeddedWallets.solana.createOnLogin}),[g.embeddedWallets.solana.createOnLogin]);let P=s(u);c((()=>{P.current=u}),[u]);let W=s(h);c((()=>{W.current=h}),[h]);let U=s(d);return c((()=>{U.current=d}),[d]),c((()=>{if(!n||!m)return;let t=async()=>{if(!k.current){k.current=!0;try{v({status:"loading"});let e=await T.current();if(void 0!==A.current&&A.current===e)return void v({status:"done"});if(!e)return w&&(await p(),_.current?.()),A.current=e,void v({status:"done"});l.startAuthFlow(new Vi(e));let{user:t,isNewUser:n=!1}=await l.authenticate();if(!t)throw new Te("Failed to sync with custom auth provider");C.current?.({user:t,isNewUser:n}),P.current(t),W.current(n),U.current(!0);let r=Bi(t,E.current),a=$i(t,I.current);if(r&&a){let e=await S.current({chainType:"ethereum",walletIndex:0,latestUser:t});await S.current({chainType:"solana",walletIndex:0,latestUser:e.user})}else a?await S.current({chainType:"solana",walletIndex:0,latestUser:t}):r&&await S.current({chainType:"ethereum",walletIndex:0,latestUser:t});A.current=e,v({status:"done"})}catch(e){if(console.warn(e),await p().catch((()=>{})),_.current?.(),e instanceof Pe&&e.privyErrorCode===_e.LINKED_TO_ANOTHER_USER)return v({status:"initial"}),void setTimeout((()=>{t()}),0);b.current?.(e),v({status:"error",error:e})}finally{k.current=!1}}};return t(),e(t)}),[e,l,w,p,n,m]),n?{state:f}:{state:{status:"not-enabled"}}}let Qi=rr((()=>({jwtAuthFlowState:{status:"not-enabled"}})));function Zi({customAuth:e}){let{jwtAuthFlowState:t}=function({customAuth:e}){let t=Xn(),n=s(),r=h((e=>(n.current=e,()=>{n.current=void 0})),[]),a=e?.getCustomAccessToken??(()=>Promise.resolve(void 0)),{state:i}=Ji({enabled:!0===e?.enabled,subscribe:r,getExternalJwt:a,onAuthenticated:({user:e,isNewUser:n})=>{t("login","onComplete",{user:e,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:"custom",loginAccount:null}),t("customAuth","onAuthenticated",{user:e})},onUnauthenticated:()=>{t("customAuth","onUnauthenticated")},onError:e=>{t("login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR)}});return c((()=>{(async()=>{e&&!e.isLoading&&n.current?.()})()}),[e?.enabled,e?.getCustomAccessToken,e?.isLoading]),{jwtAuthFlowState:i}}({customAuth:e});return c((()=>{Qi.setState({jwtAuthFlowState:t})}),[t]),null}const Xi=/*#__PURE__*/i(!1);let es,ts,ns,rs,as;const is=n=>{let r=n.client,a=n.privy,i=Hn(),d=Xe();X(ee(d?.appearance.walletList??[]));let[u,p]=o(!1),w=Ua((e=>e.inProgressMfaFlow)),[y,g]=o(!1),[f,v]=o(null),A=qi((e=>e.ethereum)),[k,T]=o(void 0),[C,_]=o(!1),[S,P]=o(null),[F,D]=o(!1),[L,j]=o({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:Se}),[z,q]=o({status:"initial"}),[H,B]=o({status:"initial"}),[K,$]=o({status:"initial"}),[G,Y]=o({status:"initial"}),[J,Q]=o({status:"initial"}),[Z,ce]=o({status:"initial"}),[de,ue]=o(null),he=tt(),[pe,we]=o({}),[me,ye]=o(null),ge=s(null),[fe,Ee]=o(!1),Ie=s(null),Pe=s(null),Ne=s(er),[Oe,Re]=o(!1),[xe,He]=o(!1),Ve=h((e=>{He(e),!e&&S&&Pa[S]().then((e=>{e.default.isUnauthenticatedScreem&&P(null)}))}),[S]);r.onStoreCustomerAccessToken=e=>{e&&tr(Ne,"accessToken","onAccessTokenGranted",{accessToken:e})},r.onDeleteCustomerAccessToken=()=>{v(null),Ve(!1),tr(Ne,"accessToken","onAccessTokenRemoved")};let Be=s(null),Ke=s(null),$e=s(!1),Ge=({showWalletUIs:e})=>$e.current?$e.current:void 0!==e?!e:!d.embeddedWallets.showWalletUIs,Ye=e=>{P(e),setTimeout((()=>{p(!0)}),15)};c((()=>{if(!f)return void r.connectors?.removeEmbeddedWalletConnectors();let e=I(f),t=W(f),i=U(f);e&&t.length||r.connectors?.removeEmbeddedWalletConnectors(),i.length||r.connectors?.removeImportedWalletConnectors(),r.connectors?de?(e&&r.connectors.addEmbeddedWalletConnectors({walletProxy:de,user:f,embeddedWallets:t,defaultChain:d.defaultChain,appId:n.appId,privyClient:a}),i.forEach((e=>r.connectors?.addImportedWalletConnector(de,e.address,d.defaultChain,n.appId)))):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[de,f]),c((()=>{de&&ge.current?.(de)}),[de]),c((()=>{if(d.externalWallets.solana.connectors)return d.externalWallets.solana.connectors.onMount(),()=>d.externalWallets.solana.connectors?.onUnmount()}),[d.externalWallets.solana.connectors]),c((()=>{!y&&he&&async function(){let e,t=et(),n=it(),a=gt();r.initializeConnectorManager({walletConnectCloudProjectId:d.walletConnectCloudProjectId,rpcConfig:d.rpcConfig,chains:d.chains,defaultChain:d.defaultChain,store:a,walletList:d.appearance.walletList,shouldEnforceDefaultChainOnConnect:d.shouldEnforceDefaultChainOnConnect,externalWalletConfig:d.externalWallets,appName:d.name??"Privy",walletChainType:d.appearance.walletChainType,setBaseAccountSdk:T}),r.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=r.connectors.walletConnectors.length,n=r.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);n===t?Re(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:n,expected:t}),Re(!0)}),1500)})),r.connectors?.initialize().then((()=>{dt()}));let i=await r.getAuthenticatedUser(),s=!!i;d.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await r.logout(),Pt.setReadyToTrue(!0),tr(Ne,"logout","onSuccess")):(d.customAuth?.enabled||(Ve(!!i),i&&tr(Ne,"login","onComplete",{user:i,isNewUser:!1,wasAlreadyAuthenticated:!0,loginMethod:null,loginAccount:null}),v(i)),t?Ke.current=s?"link":"login":n&&!s?(Ke.current="login",we({telegramAuthModalData:{seamlessAuth:!0}}),Ye("TelegramAuthScreen")):Pt.setReadyToTrue(!!i))}()}),[r,me,y,he]),c((()=>{if(y){if(!f||!f.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void Ee(!!de);if([...A].some((e=>"privy"===e.walletClientType)))return void Ee(!0);Ee(!!de)}}),[y,f,A,de]),c((()=>{r.connectors?.setWalletList(d.appearance.walletList)}),[d.appearance.walletList.join()]);let et=()=>{let e=ca();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&e.provider.startsWith("privy:")&&!e.popupFlow&&(new BroadcastChannel(ki).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(r.startAuthFlow(new la({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl})),Ye("OAuthStatusScreen"),!0))},it=()=>{let e=function(){let e;return(e=function(){let e=new URLSearchParams(window.location.search),t=Number(e.get("id")||""),n=e.get("hash"),r=Number(e.get("auth_date")||""),a=e.get("first_name");if(t&&a&&r&&n)return Object.fromEntries(e.entries())}())?(ba(),{flowType:"login-url",authData:e}):(e=function(){let e=window.location.hash;if(!e||!e.startsWith("#tgWebAppData"))return;let t=_a(e.replace("#tgWebAppData=","")),{user:n,auth_date:r,hash:a}=t;return n&&r&&a?t:void 0}())?(ba(),{flowType:"web-app",authData:e}):void 0}();if(!e||!d.loginMethods.telegram||!d.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new Ta;return r.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},st=async(e,t,n,a)=>{if("solana_adapter"!==e)ot(await(r.connectors?.createEthereumWalletConnector({connectorType:e,walletClientType:t}))||null,t,n,a);else{let e=r.connectors?.findSolanaWalletConnector(t);if(!e)return;ot(e,t,n,a)}};async function ot(e,t,n,r){if(!e)return j({status:"disconnected",connectedWallet:null,connectError:new ke("Unable to connect to wallet."),connector:null,connectRetry:Se}),r?.(null,n);j({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:Se}),e instanceof Za&&t&&await e.resetConnection(t),j({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>ot(e,t,n,r)});try{let t=await e.connect({showPrompt:!0});if((!t||ne(t))&&d.shouldEnforceDefaultChainOnConnect&&!d.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){j((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:Se})));try{await(t?.switchChain(d.defaultChain.id)),t&&(t.chainId=se(Ct(d.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${d.defaultChain.id}`)}}return j((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:Se}))),t&&tr(Ne,"connectWallet","onSuccess",{wallet:t}),r?.(t,n)}catch(e){return e instanceof be?(console.warn(e.cause?e.cause:e.message),tr(Ne,"connectWallet","onError",e.privyErrorCode||_e.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),tr(Ne,"connectWallet","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR)),j((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),r?.(null,n)}}let lt=async(e,t,n)=>{if(null===e||!ne(e))return;let a=new pa(r,e,t,n);r.startAuthFlow(a)},ct=async(e,t,n,a="plain")=>{let s=i(Bn);if("transaction"===a&&!s)throw new Te("useSolanaLedger plugin hook must be mounted");if(null===e||!le(e))return;let o=new wa(e,r,t,n,a,s);r.startAuthFlow(o)},dt=async()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),n=e.get("privy_wallet_client"),a="true"===e.get("privy_connect_only");if(!t||!n)return;let i=oe({connectorType:t,walletClientType:n});if(!i||!i.isInstalled)return Ye("LoginFailedScreen");if(!r.connectors)throw new Te("Connector not initialized");await Ye(a?"ConnectOnlyStatusScreen":"ConnectionStatusScreen");let s=new URL(window.location.href);s.searchParams.delete("privy_connector"),s.searchParams.delete("privy_wallet_client"),s.searchParams.delete("privy_connect_only"),window.history.pushState({},"",s),st(t,n,void 0,a?void 0:"solana_adapter"===t?ct:lt)};c((()=>{y&&xe&&null===f&&r.getAuthenticatedUser().then(v)}),[y,xe,f,r]);let ut=e=>{if(!xe)throw tr(Ne,"linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Te("User must be authenticated before linking an account.")},ht=e=>{if(!xe||!f)return!1;if("privy"===e.walletClientType)return!0;for(let t of f.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},pt=()=>{qi.setState((e=>{let t=r.connectors?.wallets.filter(ne).map((e=>({...e,linked:ht(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Te("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Te("Cannot link or login with embedded wallet");(async e=>{let t;if(!r.connectors)throw new Te("Connector not initialized");t="ethereum"===e.type?r.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:r.connectors.findSolanaWalletConnector(e.walletClientType)||null,j((n=>({...n,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:Se}))),d.captcha.enabledProvider&&!xe?(we({captchaModalData:{callback:t=>ne(e)?lt(e,t):ct(e,t),userIntentRequired:!1,onSuccessNavigateTo:"ConnectionStatusScreen",onErrorNavigateTo:"ErrorScreen"}}),await Ye("CaptchaScreen")):(ne(e)?await lt(e):await ct(e),await Ye("ConnectionStatusScreen"))})(e)},fund:async t=>{await Pt.fundWallet(e.address,t)},unlink:async()=>{if(!xe)throw new Te("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Te("Cannot unlink an embedded wallet");v(await r.unlinkEthereumWallet(e.address))}})))||[];return re(e.ethereum,t)?{}:{ethereum:t}}))};c((()=>{pt()}),[f?.linkedAccounts,xe,y]),c((()=>{if(y){if(!r.connectors)throw new Te("Connector not initialized");pt(),r.connectors.on("walletsUpdated",pt)}}),[y]),c((()=>{[...d.loginMethodsAndOrder?.primary??[],...d.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>r.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!r]);let wt=({transaction:e,sponsor:t,uiOptions:i,fundWalletConfig:s,address:o,signOnly:l})=>new Promise((async(c,u)=>{let{requesterAppId:h}=i||{},p=l?"signTransaction":"sendTransaction",w=o?R(f,o):I(f);if(!w&&o){let n=M(Hi(),o);if(n){if(t)throw new Te("Cannot sponsor transactions for externally connected wallet.");try{let t=await n.getEthereumProvider(),r={...e,from:o,chainId:e.chainId||Number(n.chainId.replace("eip155:","")),value:void 0!==e.value?Ct(e.value):void 0},a=await t.request({method:"sendTransaction"===p?"eth_sendTransaction":"eth_signTransaction",params:[r]});return tr(Ne,p,"onSuccess",{hash:a}),void c({hash:a})}catch(e){return tr(Ne,p,"onError",_e.TRANSACTION_FAILURE),void u(e??new Le("Unable to "+p+e))}}}if(!w)return tr(Ne,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(new Te("No embedded or connected wallet found for address."));if(!xe||!f)return tr(Ne,p,"onError",_e.MUST_BE_AUTHENTICATED),void u(Error("User must be authenticated before signing with a Privy wallet"));let y=w.address,g=w.walletIndex??0,{entropyId:v,entropyIdVerifier:A}=Ae(f,w),k=Wt.wallets.find((e=>"privy"===e.walletClientType&&_t(e.address)===_t(y)));if(!k)return tr(Ne,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(Error("Must have a Privy wallet before signing"));let T=await k.getEthereumProvider(),C=await T.request({method:"eth_chainId"}),_=e.chainId?Number(e.chainId):je(C);(e=>{if(!d.chains.map((e=>e.id)).includes(e))throw new ke(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,_e.UNSUPPORTED_CHAIN_ID)})(_);let b={...e,from:e.from??y,chainId:_},S=await $r();if(!S||!de)return tr(Ne,p,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),void u(Error("Must have valid access token and Privy wallet to send transaction"));let P=fr(b.chainId,d.chains,d.rpcConfig,{appId:n.appId}),W=E(w),U=async({transactionRequest:e})=>{try{let n;if(!await Pt.recoverEmbeddedWallet({address:y}))throw tr(Ne,p,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),u(Error("Unable to connect to wallet")),Error("Unable to connect to wallet");if(t){let t=await(async({transactionRequest:e})=>{if(!W)throw new Te("Sponsoring is only supported for wallets on the TEE stack");if(l)throw new Te("Cannot sponsor a sign transaction request");let t=e=>null==e?void 0:Ct(e),n=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:S,requesterAppId:h,message:e})),{chain_type:"ethereum",method:"eth_sendTransaction",caip2:se(Ct(e.chainId)),sponsor:!0,params:{transaction:{from:e.from,to:e.to,chain_id:t(e.chainId),data:bt(e.data)?e.data?e.data:Ct(Uint8Array.from(e.data)):void 0,value:t(e.value)}},wallet_id:w.id});if(n.data&&"hash"in n.data)return n.data.hash;throw new Le("Unable to sign transaction")})({transactionRequest:e});return tr(Ne,"sendTransaction","onSuccess",{hash:t}),t}if(W){let t=e=>null==e?void 0:Ct(e),r=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:S,requesterAppId:h,message:e})),{chain_type:"ethereum",method:"eth_signTransaction",params:{transaction:{from:e.from,to:e.to,nonce:t(e.nonce),chain_id:t(e.chainId),data:bt(e.data)?e.data?e.data:Ct(Uint8Array.from(e.data)):void 0,value:t(e.value),type:e.type,gas_limit:t(e.gasLimit??e.gas),gas_price:t(e.gasPrice??e.gas),max_fee_per_gas:t(e.maxFeePerGas),max_priority_fee_per_gas:t(e.maxPriorityFeePerGas)}},wallet_id:w.id});if(!r.data||!("signed_transaction"in r.data))throw new Le("Unable to sign transaction");n=r.data.signed_transaction}else n=await async function({accessToken:e,entropyId:t,entropyIdVerifier:n,transactingWalletIndex:r,walletProxy:a,transactionRequest:i,requesterAppId:s}){return(await a.rpc({entropyId:t,entropyIdVerifier:n,hdWalletIndex:r??0,chainType:"ethereum",accessToken:e,requesterAppId:s,request:{method:"eth_signTransaction",params:[i]}})).response.data}({accessToken:S,entropyId:v,entropyIdVerifier:A,transactingWalletIndex:g,walletProxy:de,transactionRequest:e,requesterAppId:h});if(l)return tr(Ne,"signTransaction","onSuccess",{signature:n}),n;{let e=await P.sendRawTransaction({serializedTransaction:n});return tr(Ne,"sendTransaction","onSuccess",{hash:e}),e}}catch(e){throw tr(Ne,p,"onError",_e.TRANSACTION_FAILURE),e}};if(Ge({showWalletUIs:i?.showWalletUIs})){let e=l||t?b:await Di(b,P,b.from);try{let t=await U({transactionRequest:e});l?tr(Ne,"signTransaction","onSuccess",{signature:t}):tr(Ne,"sendTransaction","onSuccess",{hash:t}),c({hash:t})}catch(e){tr(Ne,p,"onError",_e.TRANSACTION_FAILURE),u(e)}}else{let e={connectingWalletAddress:y,recoveryMethod:w.recoveryMethod,entropyId:v,entropyIdVerifier:A,onCompleteNavigateTo:"SendTransactionScreen",isUnifiedWallet:W,onFailure:e=>{tr(Ne,p,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),u(e)}},n=(e=>!!e.fundingConfig&&De(e.fundingConfig.options).length>=1)(d)?ze({address:y,appConfig:d,fundWalletConfig:s,methodScreen:"FundingMethodSelectionScreen",chainIdOverride:b.chainId,comingFromSendTransactionScreen:!0}):void 0;we({connectWallet:e,sendTransaction:{transactionRequest:b,transactingWalletIndex:g,transactingWalletAddress:y,entropyId:v,entropyIdVerifier:A,signOnly:l,scanTransaction:async()=>{let e=await Di(b,P,b.from);return await r.scanTransaction({metadata:{domain:d.embeddedWallets.transactionScanning.domain},chain_id:e.chainId.toString(),request:{method:"eth_sendTransaction",params:[{from:e.from,to:e.to,value:e.value?.toString(),gas:e.gas?.toString(),gasPrice:e.gasPrice?.toString(),nonce:e.nonce?.toString(),data:e.data}]}})},getIsSponsored:async()=>!!t,onConfirm:({transactionRequest:e})=>U({transactionRequest:e}),onSuccess:e=>{l?tr(Ne,"signTransaction","onSuccess",{signature:e.hash}):tr(Ne,"sendTransaction","onSuccess",{hash:e.hash}),c(e)},onFailure:e=>{tr(Ne,p,"onError",_e.TRANSACTION_FAILURE),u(e)},uiOptions:i||{},fundWalletConfig:s,requesterAppId:h},funding:n}),Ye("EmbeddedWalletConnectingScreen")}}));function mt(){return new Promise((async(e,t)=>{let n=await $r();if(!n||!de)throw Error("Must have valid access token to enroll in MFA");try{await de.verifyMfa({accessToken:n}),e()}catch(e){t(e)}}))}let yt=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],ft=e=>{let t=f?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:n,loginMethod:r}=Fi(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw tr(Ne,"linkAccount","onError",_e.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:r}),new Te(`User already has an account of type ${n} linked.`)};async function vt({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){P(null);let n=t?"setWalletPassword":"setWalletRecovery";if(!xe||!f)throw tr(Ne,n,"onError",_e.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let r=b(f);if(!r||!de)throw tr(Ne,n,"onError",_e.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");let a=E(r);if(a)throw tr(Ne,n,"onError",_e.UNSUPPORTED_WALLET_TYPE),new Te("User owned wallet recovery is only supported for on-device execution and this app uses TEE execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");try{await mt()}catch(e){throw tr(Ne,n,"onError",_e.MISSING_MFA_CREDENTIALS),e}return new Promise(((i,s)=>{let o="user-passcode"===r.recoveryMethod,l=Pi({walletAction:"update",availableRecoveryMethods:d.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:o,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:u}=Ae(f),h={recoveryMethod:r.recoveryMethod,connectingWalletAddress:r.address,onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,isUnifiedWallet:a,entropyIdVerifier:u,onFailure:e=>{tr(Ne,n,"onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}};we({setWalletPassword:{onSuccess:e=>{tr(Ne,n,"onSuccess",{method:"user-passcode",wallet:e}),i(e)},onFailure:e=>{tr(Ne,n,"onError",_e.USER_EXITED_SET_PASSWORD_FLOW),s(e)},callAuthOnSuccessOnClose:!1},recoverWallet:{entropyId:c,entropyIdVerifier:u,onFailure:s},connectWallet:h,recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:o,shouldCreateEth:!1,shouldCreateSol:!1}}),Ye("EmbeddedWalletConnectingScreen")}))}async function kt({appId:e,action:t,disableSignup:n}){let a=await $r();if("link"===t&&!a)throw tr(Ne,"linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Te("User must be authenticated before linking an account.");if("login"===t&&a)throw tr(Ne,"login","onError",_e.UNKNOWN_AUTH_ERROR),new Te("Attempted to log in, but user is already logged in. Use a `link` helper instead.");Be.current=`privy:${e}`,Ke.current=t;let i=Et();return r.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(a,s)=>{let{name:o,logoUrl:l}=await _i({api:r.api,providerAppId:e,requesterAppId:d.id});we({crossAppAuth:{appId:e,name:o,logoUrl:l,action:t,popup:i,disableSignup:n,onSuccess:a,onError:s}}),Ye("CrossAppAuthScreen")}))}let St={ready:y,authenticated:xe,user:f,walletConnectors:r.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),we({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,walletChainType:e?.walletChainType,description:e?.description,hideHeader:e?.hideHeader}}),Ye("ConnectOnlyLandingScreen")},linkWallet:e=>(e&&"target"in e&&e&&(e=void 0),ut("siwe"),Be.current="siwe",Ke.current="link",we({...pe,externalConnectWallet:{...pe.externalConnectWallet,walletList:e?.walletList,walletChainType:e?.walletChainType,description:e?.description||`Link a wallet to your ${d?.name} account`}}),Ye("AuthenticateWithWalletScreen")),startCrossAppAuthFlow:kt,linkEmail:()=>{ut("email"),ft("email"),Be.current="email",Ke.current="link",Ye("LinkEmailScreen")},linkPhone:()=>{ut("sms"),ft("phone"),Be.current="sms",Ke.current="link",Ye("LinkPhoneScreen")},linkGoogle:async()=>{ut("google"),ft("google_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("google")},linkTwitter:async()=>{ut("twitter"),ft("twitter_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("twitter")},linkTwitch:async()=>{ut("twitch"),ft("twitch_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("twitch")},linkDiscord:async()=>{ut("discord"),ft("discord_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("discord")},linkGithub:async()=>{ut("github"),ft("github_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("github")},linkSpotify:async()=>{ut("spotify"),ft("spotify_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("spotify")},linkInstagram:async()=>{ut("instagram"),ft("instagram_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("instagram")},linkTiktok:async()=>{ut("tiktok"),ft("tiktok_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("tiktok")},linkLine:async()=>{ut("line"),ft("line_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("line")},linkLinkedIn:async()=>{ut("linkedin"),ft("linkedin_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("linkedin")},linkApple:async()=>{ut("apple"),ft("apple_oauth"),Ke.current="link",await Pt.initLoginWithOAuth("apple")},linkPasskey:async()=>{ut("passkey"),ft("passkey"),await Pt.initLinkWithPasskey(),Ye("LinkPasskeyScreen")},linkTelegram:async e=>{if(ut("telegram"),ft("telegram"),Ke.current="link",Be.current="telegram",e?.launchParams)if(e.launchParams.initDataRaw){let t=new Ta;r.startAuthFlow(t),t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=_a(e.launchParams.initDataRaw),we({telegramAuthModalData:{seamlessAuth:!0}}),Ye("TelegramAuthScreen")}else tr(Ne,"linkAccount","onError",_e.INVALID_DATA,{linkMethod:"telegram"});else await Pt.initLoginWithTelegram();Ye("TelegramAuthScreen")},linkFarcaster:async()=>{ut("farcaster"),ft("farcaster"),await Pt.initLoginWithFarcaster(),Ke.current="link",Be.current="farcaster",Ye("FarcasterConnectStatusScreen")},updateEmail:()=>{if(ut("email"),!f?.email)throw new Te("User does not have an email linked to their account.");Ke.current="update",Be.current="email",Ye("UpdateEmailScreen")},updatePhone:()=>{if(ut("sms"),!f?.phone)throw new Te("User does not have a phone number linked to their account.");Ke.current="update",Be.current="sms",Ye("UpdatePhoneScreen")},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!y){let e=await new Promise((e=>{ye((t=>e.bind(t)))}));if(ye(null),e)return void console.warn(t)}!f||f.isGuest?(Ke.current="login",we({login:e}),Ye("LandingScreen")):console.warn(t)},connectOrCreateWallet:async()=>{y||(await new Promise((e=>{ye((()=>e))})),ye(null)),xe?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(Ke.current="connect-or-create",Ye("ConnectOrCreateScreen"))},logout:async()=>{if(Ke.current=null,Be.current=null,f&&r.clearProviderAcccessTokens(f),P(null),await r.logout(),f&&de)try{await de.clearMfa({userId:f.id})}catch(e){}v(null),Ve(!1),B({status:"initial"}),$({status:"initial"}),q({status:"initial"}),Y({status:"initial"}),Q({status:"initial"}),ce({status:"initial"}),tr(Ne,"logout","onSuccess"),p(!1),Me.del(rt),Me.del(at(d.id))},getAccessToken:h((async()=>{let e=await r.getCustomerAccessToken();return e&&!xe&&Ve(!0),e}),[r,xe]),unlinkWallet:async e=>{let t;return v(t=e.startsWith("0x")?await r.unlinkEthereumWallet(e):await r.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await r.unlinkEmail(e);return v(t),t},unlinkPhone:async e=>{let t=await r.unlinkPhone(e);return v(t),t},unlinkGoogle:async e=>{let t=await r.unlinkOAuth("google",e);return v(t),t},unlinkTwitter:async e=>{let t=await r.unlinkOAuth("twitter",e);return v(t),t},unlinkTwitch:async e=>{let t=await r.unlinkOAuth("twitch",e);return v(t),t},unlinkDiscord:async e=>{let t=await r.unlinkOAuth("discord",e);return v(t),t},unlinkGithub:async e=>{let t=await r.unlinkOAuth("github",e);return v(t),t},unlinkSpotify:async e=>{let t=await r.unlinkOAuth("spotify",e);return v(t),t},unlinkInstagram:async e=>{let t=await r.unlinkOAuth("instagram",e);return v(t),t},unlinkTiktok:async e=>{let t=await r.unlinkOAuth("tiktok",e);return v(t),t},unlinkLine:async e=>{let t=await r.unlinkOAuth("line",e);return v(t),t},unlinkLinkedIn:async e=>{let t=await r.unlinkOAuth("linkedin",e);return v(t),t},unlinkApple:async e=>{let t=await r.unlinkOAuth("apple",e);return v(t),t},unlinkFarcaster:async e=>{let t=await r.unlinkFarcaster(e);return v(t),t},unlinkTelegram:async e=>{let t=await r.unlinkTelegram(e);return v(t),t},unlinkPasskey:async e=>{let t=await $r();if(!t)throw Error("Must have valid access token to enroll in MFA");if(!de)throw Error("Wallet proxy not initialized.");let n=d.passkeys.shouldUnenrollMfaOnUnlink;await de.unlinkPasskeyAccount({credentialId:e,accessToken:t,removeAsMfa:n});let a=await r.getAuthenticatedUser();return v(a),a},unlinkCrossAppAccount:async({subject:e})=>{let t=f?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Te("Invalid subject");r.storeProviderAccessToken(t.id,null);let n=await r.unlinkOAuth(`privy:${t.id}`,e);return v(n),n},setWalletRecovery:async e=>vt({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>vt({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t)=>new Promise((async(n,i)=>{let{requesterAppId:s}=t?.uiOptions||{},o=e.message,l=t?.address?R(f,t.address):I(f);if(!l&&void 0!==t?.address){let e=M(Hi(),t.address);if(e)try{let t=await e.getEthereumProvider(),r=await t.request({method:"personal_sign",params:[o,e.address]});return tr(Ne,"signMessage","onSuccess",{signature:r}),void n({signature:r})}catch(e){return tr(Ne,"signMessage","onError",_e.UNABLE_TO_SIGN),void i(e??new Le("Unable to sign message"))}}if(!l)throw new Te("No embedded or connected wallet found for address.");if(!xe||!f)return tr(Ne,"signMessage","onError",_e.MUST_BE_AUTHENTICATED),void i(Error("User must be authenticated before signing with a Privy wallet"));let c=l.address,d=l.walletIndex??0,{entropyId:u,entropyIdVerifier:h}=Ae(f,l),p=E(l);if("string"!=typeof o||o.length<1)return tr(Ne,"signMessage","onError",_e.INVALID_MESSAGE),void i(Error("Message must be a non-empty string"));let w=async()=>{let t;if(!xe)throw Error("User must be authenticated before signing with a Privy wallet");let n=await $r();if(!de||!n||!await Pt.recoverEmbeddedWallet({address:c}))throw Error("Unable to connect to wallet");if(r.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:c,requesterAppId:s}}),p){let r=bt(e.message,{strict:!0}),i=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:n,requesterAppId:s,message:e})),{chain_type:"ethereum",method:"personal_sign",params:r?{message:o.slice(2),encoding:"hex"}:{message:o,encoding:"utf-8"},wallet_id:l.id});if(!i.data||!("signature"in i.data))throw new Le("Unable to sign message");t=i.data.signature}else{let{response:e}=await de.rpc({accessToken:n,entropyId:u,entropyIdVerifier:h,chainType:"ethereum",hdWalletIndex:d,requesterAppId:s,request:{method:"personal_sign",params:[o,c]}});t=e.data}return r.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:c,requesterAppId:s}}),t};if(Ge({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await w();tr(Ne,"signMessage","onSuccess",{signature:e}),n({signature:e})}catch(e){tr(Ne,"signMessage","onError",_e.UNABLE_TO_SIGN),i(e??new Le("Unable to sign message"))}else we({signMessage:{method:"personal_sign",data:o,confirmAndSign:w,onSuccess:e=>{tr(Ne,"signMessage","onSuccess",{signature:e}),n({signature:e})},onFailure:e=>{tr(Ne,"signMessage","onError",_e.UNABLE_TO_SIGN),i(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:l.recoveryMethod,connectingWalletAddress:c,entropyId:u,entropyIdVerifier:h,onCompleteNavigateTo:"SignRequestScreen",isUnifiedWallet:p,onFailure:e=>{tr(Ne,"signMessage","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),Ye("EmbeddedWalletConnectingScreen")})),signTypedData:(e,t)=>new Promise((async(n,i)=>{let{requesterAppId:s}=t?.uiOptions||{},o=t?.address?R(f,t.address):I(f);if(!o&&t?.address){let r=M(Hi(),t.address);if(r)try{let t=await r.getEthereumProvider(),a=ae(e),i=await t.request({method:"eth_signTypedData_v4",params:[r.address,a]});return tr(Ne,"signTypedData","onSuccess",{signature:i}),void n({signature:i})}catch(e){return tr(Ne,"signTypedData","onError",_e.UNABLE_TO_SIGN),void i(e??new Le("Unable to sign typed data "+e))}}if(!o)throw new Te("No embedded or connected wallet found for address.");if(!xe||!f)return tr(Ne,"signTypedData","onError",_e.MUST_BE_AUTHENTICATED),void i(Error("User must be authenticated before signing with a Privy wallet"));let l=o.address,c=o.walletIndex??0,{entropyId:d,entropyIdVerifier:u}=Ae(f,o),h=E(o),p=ae(e),w=async()=>{let e;if(!xe)throw Error("User must be authenticated before signing with a Privy wallet");let t=await $r();if(!de||!t||!await Pt.recoverEmbeddedWallet({address:l}))throw Error("Unable to connect to wallet");if(r.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:l,requesterAppId:s}}),h){let{domain:n,types:r,primaryType:i,message:l}=p,c=await m(a,(async({message:e})=>await de.signWithUserSigner({accessToken:t,requesterAppId:s,message:e})),{chain_type:"ethereum",method:"eth_signTypedData_v4",params:{typed_data:{domain:n,types:r,primary_type:i,message:l}},wallet_id:o.id});if(!c.data||!("signature"in c.data))throw new Le("Unable to sign message");e=c.data.signature}else{let{response:n}=await de.rpc({accessToken:t,entropyId:d,entropyIdVerifier:u,chainType:"ethereum",hdWalletIndex:c,requesterAppId:s,request:{method:"eth_signTypedData_v4",params:[l,p]}});e=n.data}return r.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:l,requesterAppId:s}}),e};if(Ge({showWalletUIs:t?.uiOptions?.showWalletUIs}))try{let e=await w();tr(Ne,"signTypedData","onSuccess",{signature:e}),n({signature:e})}catch(e){tr(Ne,"signTypedData","onError",_e.UNABLE_TO_SIGN),i(e??new Le("Unable to sign message"))}else we({signMessage:{method:"eth_signTypedData_v4",data:p,confirmAndSign:w,onSuccess:e=>{tr(Ne,"signTypedData","onSuccess",{signature:e}),n({signature:e})},onFailure:e=>{tr(Ne,"signTypedData","onError",_e.UNABLE_TO_SIGN),i(e)},uiOptions:t?.uiOptions||{}},connectWallet:{recoveryMethod:o.recoveryMethod,connectingWalletAddress:o.address,entropyId:d,isUnifiedWallet:h,entropyIdVerifier:u,onCompleteNavigateTo:"SignRequestScreen",onFailure:e=>{tr(Ne,"signMessage","onError",_e.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}}}),Ye("EmbeddedWalletConnectingScreen")})),sendTransaction:async(e,t)=>await wt({transaction:e,sponsor:t?.sponsor,uiOptions:t?.uiOptions,fundWalletConfig:t?.fundWalletConfig,address:t?.address,signOnly:!1}),signTransaction:async(e,t)=>({signature:(await wt({transaction:e,uiOptions:t?.uiOptions,address:t?.address,signOnly:!0})).hash}),exportWallet:e=>new Promise((async(t,a)=>{if(!xe||!f)return void a(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let i=e?.address?R(f,e.address):I(f);if(!i)return void a(new Te("User must have an embedded wallet."));let s=i.address,{entropyId:o,entropyIdVerifier:l}=Ae(f,i),c=E(i);if(!s)return void a(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));if(!Tt(s))return void a(Error("Must provide a valid Ethereum address."));let d={recoveryMethod:i.recoveryMethod,connectingWalletAddress:i.address,isUnifiedWallet:c,entropyId:o,entropyIdVerifier:l,onCompleteNavigateTo:"EmbeddedWalletKeyExportScreen",onFailure:a,shouldForceMFA:!0};we(pe),await $r()&&de?de?Fe(i)?(we({keyExport:{appId:n.appId,appClientId:n.clientId,origin:r.apiUrl,address:i.address,entropyId:o,entropyIdVerifier:l,hdWalletIndex:i.walletIndex,chainType:i.chainType,walletId:i.id,isUnifiedWallet:c,imported:i.imported,onSuccess:t,onFailure:a},connectWallet:d}),Ye("EmbeddedWalletConnectingScreen")):a(Error(`Export is not supported for ${i.chainType} wallets`)):a(Error("Must have a Privy wallet before exporting")):a(Error("Must have valid access token to enroll in MFA"))})),promptMfa:mt,async init(e){switch(e){case"sms":return void await r.initMfaSmsVerification();case"passkey":return await r.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new Te("Invalid MFA code");Ie.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{Pe.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new Te("Invalid authenticator response");let n=await import("@simplewebauthn/browser"),r=zi(await n.startAuthentication({optionsJSON:t}));Ie.current?.resolve({mfaMethod:e,mfaCode:r,relyingParty:window.origin}),await new Promise(((e,t)=>{Pe.current={resolve:e,reject:t}}));break;default:throw Ie.current?.reject(new Te("Unsupported MFA method")),new Te(`Unsupported MFA method: ${e}`)}},cancel(){Ie.current?.reject(new Te("MFA canceled"))},async initEnrollmentWithSms(e){let t=await $r();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,n)=>{if(!e)return Pt.closePrivyModal(),void t();d.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),we({mfaEnrollmentFlow:{mfaMethods:d.mfa.methods,shouldUnlinkOnUnenrollMfa:d.passkeys.shouldUnlinkOnUnenrollMfa,onSuccess:t,onFailure:n}}),Ye("MfaEnrollmentFlowScreen")})),async initEnrollmentWithTotp(){let e=await $r();if(!e||!de)throw Error("Must have valid access token to enroll in MFA");let t=await de.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await $r();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),v(await r.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await $r();if(!t||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),v(await r.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e},t={}){let n=await $r();if(!n||!de)throw Error("Must have valid access token to enroll in MFA");await de.submitEnrollMfa({method:"passkey",accessToken:n,credentialIds:e,removeForLogin:t.removeForLogin}),v(await r.getAuthenticatedUser())},async unenroll(e,t={}){let n=await $r();if(!n||!de)throw Error("Must have valid access token to remove MFA");"passkey"===e?await de.submitEnrollMfa({method:"passkey",accessToken:n,credentialIds:[],removeForLogin:t.removeForLogin}):await de.unenrollMfa({method:e,accessToken:n}),v(await r.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await $r(),t=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!de||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(E(t))throw new Te("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Pt.recoverEmbeddedWallet({address:t.address}))throw Error("Unable to connect to wallet");let n=await de.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===n.status&&v(await r.getAuthenticatedUser()||f||null),we({farcasterSigner:n}),Ye("FarcasterSignerStatusScreen")},getFarcasterSignerPublicKey:async()=>{let e,t=await $r(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(E(n))throw new Te("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Pt.recoverEmbeddedWallet({address:n.address}))throw Error("Unable to connect to wallet");if(!f.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=f.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await $r(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(E(n))throw new Te("Farcaster signers are only supported for on-device execution and this app uses TEE execution. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await Pt.recoverEmbeddedWallet({address:n.address}))throw Error("Unable to connect to wallet");if(!f.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let r=await import("@simplewebauthn/browser"),a=await de.signFarcasterMessage({address:n.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:r.bufferToBase64URLString(e)},fid:BigInt(f.farcaster.fid),relyingParty:window.origin});return new Uint8Array(r.base64URLStringToBuffer(a.signature))},signMessageWithCrossAppWallet(e,{address:t,chainId:n}){let a=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return bi({user:f,client:r,address:t,requesterAppId:d.id,request:{method:a?"privy_signSmartWalletMessage":"personal_sign",params:[e,t],chainId:n},reconnect:kt})},signTypedDataWithCrossAppWallet(e,{address:t,chainId:n}){let a=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),i=ae(e);return bi({user:f,client:r,address:t,requesterAppId:d.id,request:{method:a?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,i],chainId:n},reconnect:kt})},sendTransactionWithCrossAppWallet(e,{address:t}){let n=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return bi({user:f,client:r,address:t,requesterAppId:d.id,request:{method:n?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e],chainId:e.chainId},reconnect:kt})},signTransactionWithCrossAppWallet(e,{address:t}){let n=f?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return bi({user:f,client:r,address:t,requesterAppId:d.id,request:{method:n?"privy_signSmartWalletTx":"eth_signTransaction",params:[e],chainId:e.chainId},reconnect:kt})},isModalOpen:u||!!w,mfaMethods:d.mfa.methods};es=St.signMessage,ts=St.signTypedData,rs=async(e,t)=>await wt({transaction:e,...t,signOnly:!1}),ns=async(e,t)=>({signature:(await wt({transaction:e,...t,signOnly:!0})).hash});let It=async e=>{let t,n,a;D(!0),Q({status:"loading"}),r.startAuthFlow(new la({...e,customOAuthRedirectUrl:d.customOAuthRedirectUrl}));let i=Me.get(Ze),s=e.stateCode;if(i!==s)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:i??"",returnedStateCode:s??""}}),D(!1),new Te("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);if(null!==await r.getAccessToken())try{({user:t,oAuthTokens:a}=await r.link()),Be.current=e.provider;let n=yt(t);t&&n&&tr(Ne,"linkAccount","onSuccess",{user:t,linkMethod:Be.current,linkedAccount:n})}catch(t){throw D(!1),tr(Ne,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:n,oAuthTokens:a}=await r.authenticate()),Be.current=e.provider;let i=yt(t);t&&i&&void 0!==n&&tr(Ne,"login","onComplete",{user:t,isNewUser:n,wasAlreadyAuthenticated:!1,loginMethod:Be.current,loginAccount:i})}catch(e){throw D(!1),Q({status:"error",error:e}),tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}return v(t),_(n||!1),Ve(!0),D(!1),Q({status:"done"}),a&&t&&tr(Ne,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:a,user:t}),t??void 0},Pt={privy:a,setAuthenticated:Ve,setUser:v,setIsNewUser:_,isNewUserThisSession:C,pendingTransaction:null,walletConnectionStatus:L,setWalletConnectionStatus:j,connectors:r.connectors?.walletConnectors??[],rpcConfig:d.rpcConfig,chains:d.chains,appId:n.appId,showFiatPrices:"native-token"!==d.embeddedWallets.priceDisplay.primary,clientAnalyticsId:r.clientAnalyticsId,hideWalletUIs:$e,isHeadlessSigning:h(Ge,[d.embeddedWallets.showWalletUIs]),emailOtpState:H,setEmailOtpState:B,smsOtpState:K,setSmsOtpState:$,oAuthState:J,setOAuthState:Q,telegramAuthState:Z,setTelegramAuthState:ce,siweState:G,setSiweState:Y,isHeadlessOAuthLoading:F,baseAccountSdk:k,setBaseAccountSdk:T,nativeTokenSymbolForChainId:e=>d.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(de)return de;let t=new Promise((e=>{ge.current=e})),n=new Promise((t=>setTimeout((()=>t(null)),e))),r=await Promise.race([t,n]);return ge.current=null,r},getAuthFlow:()=>r.authFlow,getAuthMeta:()=>r.authFlow?.meta,client:r,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,a=y&&xe&&f;if(a&&Be.current&&(t=yt(f)),"login"===Ke.current)e.shouldCallAuthOnSuccess&&a&&Be.current?tr(Ne,"login","onComplete",{user:f,isNewUser:C,wasAlreadyAuthenticated:!1,loginMethod:Be.current,loginAccount:t??null}):tr(Ne,"login","onError",_e.USER_EXITED_AUTH_FLOW);else if("link"===Ke.current&&t)e.isSuccess&&a&&Be.current?tr(Ne,"linkAccount","onSuccess",{user:f,linkMethod:Be.current,linkedAccount:t}):Be.current&&tr(Ne,"linkAccount","onError",_e.USER_EXITED_LINK_FLOW,{linkMethod:Be.current});else if("update"===Ke.current&&t)e.isSuccess&&a&&Be.current?tr(Ne,"update","onSuccess",{user:f,updateMethod:Be.current,updatedAccount:t}):Be.current&&tr(Ne,"update","onError",_e.USER_EXITED_UPDATE_FLOW,{linkMethod:Be.current});else if("connect-or-create"===Ke.current){let e=Hi();e[0]?tr(Ne,"connectOrCreateWallet","onSuccess",{wallet:e[0]}):tr(Ne,"connectOrCreateWallet","onError",_e.USER_EXITED_AUTH_FLOW)}let s=S&&Oi.has(S),o="ErrorScreen"===S&&pe.errorModalData&&Oi.has(pe.errorModalData.previousScreen);if((s||o)&&pe.funding){let e,t=Oi.get(S)??null;if(o&&pe.funding?.onError){let e=pe.errorModalData?.error,t=e?.privyErrorCode||_e.UNKNOWN_FUNDING_ERROR,n=new Te(e?.message||"Funding failed",e,t);pe.funding?.onError?.(n)}if("solana"===pe.funding.chainType){let n=d.solanaRpcs[pe.funding.chain];if(!n)return console.warn("Unable to load solana rpc, skipping balance"),tr(Ne,"fundSolanaWallet","onUserExited",{address:pe.funding.address,fundingMethod:t,chain:pe.funding.chain,balance:e}),p(!1),void Ui(pe.funding,t);if(i(Vn))try{e=await Mi({rpc:n.rpc,address:pe.funding.address})}catch{console.error("Unable to pull wallet balance")}else console.warn("Unable to load solana plugin, skipping balance");tr(Ne,"fundSolanaWallet","onUserExited",{address:pe.funding.address,fundingMethod:t,chain:pe.funding.chain,balance:e})}else{let r=fr(pe.funding.chain.id,d.chains,d.rpcConfig,{appId:n.appId});try{e=await r.getBalance({address:pe.funding.address})}catch{console.error("Unable to pull wallet balance")}tr(Ne,"fundWallet","onUserExited",{address:pe.funding.address,chain:pe.funding.chain,fundingMethod:t,balance:e}),Ui(pe.funding,t)}}we((e=>({...e,externalConnectWallet:{}}))),Ke.current=null,Be.current=null,_(!1),p(!1),j({status:"disconnected",connectedWallet:null,connector:null,connectError:null,connectRetry:()=>{}}),setTimeout((()=>{r.authFlow=void 0}),200)},openPrivyModal:Ye,connectWallet:ot,initLoginWithWallet:async(e,t,n,r)=>{ne(e)?(Be.current="siwe",lt(e,t,n)):(Be.current="siws",ct(e,t,n,r))},loginWithWallet:async()=>{let e,t,n;if(!y)throw new Ue;if(r.authFlow instanceof pa?e="siwe":r.authFlow instanceof wa&&(e="siws"),!e)throw new Te("Must initialize SIWE/SIWS flow first.");if(null!==await r.getAccessToken())try{({user:t}=await r.link()),Be.current=e}catch(t){throw tr(Ne,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:n}=await r.authenticate()),Be.current=e}catch(e){throw tr(Ne,"login","onError",e.privyErrorCode||_e.GENERIC_CONNECT_WALLET_ERROR),e}v(t||f||null),_(n||!1),Ve(!0)},delegateWallet:async({address:e,chainType:t,showDelegationUIs:n})=>new Promise((async(r,a)=>{let i=await $r();if(!xe||!f||!i)throw new Te("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new Te("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let s=Pt.walletProxy??await Pt.initializeWalletProxy(15e3);if(!s)throw new Te("Wallet proxy not initialized.");if((({address:e,user:t})=>!!Ai(t).find((t=>t.address===e)))({address:e,user:f}))return r();let o=R(f,e);if(!o)throw new Te("Address to delegate is not associated with current user.");if(E(o))throw new Te("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let l=fi({address:e,user:f}),c=vi({address:e,user:f}),d=async()=>{await s.createDelegatedAction({accessToken:i,rootWallet:c,delegatedWallets:[l]}),await Pt.refreshSessionAndUser()};if(await Pt.recoverEmbeddedWallet({address:e}),n)we({delegatedActions:{consent:{address:e,onDelegate:d,onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),Ye("DelegatedActionsConsentScreen");else try{await d(),r()}catch(e){a(e)}})),revokeDelegatedWallets:async({showDelegationUIs:e})=>new Promise((async(t,n)=>{if(!xe||!f)throw new Te("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");let a=Ai(f);if(0===a.length)throw new Te("User has no delegated wallets to revoke.");if(a.some(E))throw new Te("useDelegatedActions is only supported for on-device execution and this app uses TEE execution. Use the useSessionSigners hook to provision server side access on behalf of your users. Learn more at https://docs.privy.io/recipes/tee-wallet-migration-guide");let i=async()=>{await r.revokeDelegatedWallet(),await Pt.refreshSessionAndUser()};if(e)we({delegatedActions:{revoke:{onRevoke:i,onSuccess:async()=>{t()},onError:async e=>{n(e)}}}}),Ye("DelegatedActionsRevokeScreen");else try{await i(),t()}catch(e){n(e)}})),initLoginWithFarcaster:async(e,t)=>{let n=new Xr(e,t);r.startAuthFlow(n);try{Be.current="farcaster",await n.initializeFarcasterConnect()}catch(e){throw"login"===Ke.current?tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ke.current&&tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!y)throw new Ue;if(!(r.authFlow instanceof Xr))throw new Te("Must initialize Farcaster flow first.");if(null!==await r.getAccessToken())try{({user:e}=await r.link()),Be.current="farcaster"}catch(e){throw tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await r.authenticate()),Be.current="farcaster"}catch(e){throw tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(e||null),_(t||!1),Ve(!0)},async crossAppAuthFlow({appId:e,popup:t,action:n,disableSignup:a}){let i=`privy:${e}`;Be.current=i;let{url:s,stateCode:o,codeVerifier:l}=await async function({api:e,appId:t}){let n=ia(),r=sa(),a=await oa(n);try{let{url:i}=await e.post(Dt,{provider:`privy:${t}`,redirect_to:window.location.href,code_challenge:a,state_code:r});return{url:i,stateCode:r,codeVerifier:n}}catch(e){throw Ce(e)}}({api:r.api,appId:e});if(!s)throw r.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new Te("No authorization URL returned for cross-app auth.");try{let c=await async function({url:e,popup:t}){return t.location=e,new Promise(((e,n)=>{let r,a=setTimeout((()=>{n(new Te("Authorization request timed out after 2 minutes.")),i()}),12e4);function i(){t?.close(),window.removeEventListener("message",o)}let s=setInterval((()=>{t?.closed&&!r&&(i(),clearInterval(s),clearTimeout(a),n(new Te("User rejected request")))}),300);function o(t){t.data&&("PRIVY_OAUTH_RESPONSE"===t.data.type&&t.data.stateCode&&t.data.authorizationCode&&(clearTimeout(a),e(t.data),i()),"PRIVY_OAUTH_ERROR"===t.data.type&&(clearTimeout(a),n(new Te(t.data.error)),i()),t.data.type===Ti&&((r=new BroadcastChannel(ki)).onmessage=o))}window.addEventListener("message",o)}))}({url:s,popup:t,provider:i}),d=c.stateCode,u=c.authorizationCode;if(d!==o)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:i,storedStateCode:o??"",returnedStateCode:d??""}}),new Te("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);let h=await async function({appId:e,stateCode:t,codeVerifier:n,authorizationCode:r,action:a,client:i,disableSignup:s}){if(!r||!t)throw new Te("[Cross-App AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if("undefined"===r)throw new Te("User denied confirmation during cross-app auth flow");try{let o=new Ci({authorizationCode:r,stateCode:t,codeVerifier:n,provider:`privy:${e}`,disableSignup:!!s});i.startAuthFlow(o);let l="link"===a?await i.link():await i.authenticate(),c=l.oAuthTokens?.accessToken;return console.debug(),c}catch(e){let t=Ce(e);if(t.privyErrorCode===_e.ACCOUNT_TRANSFER_REQUIRED)throw t;if(t.privyErrorCode)throw new Te(t.message||"Invalid code during cross-app auth flow.",void 0,t.privyErrorCode);if("User denied confirmation during cross-app auth flow"===t.message)throw new Te("Invalid code during cross-app auth flow.",void 0,_e.OAUTH_USER_DENIED);throw new Te("Invalid code during cross-app auth flow.",void 0,_e.UNKNOWN_AUTH_ERROR)}}({appId:e,codeVerifier:l,stateCode:d,authorizationCode:u,action:n,client:r,disableSignup:a});h&&r.storeProviderAccessToken(e,h);let p=await Pt.refreshSessionAndUser();if(!p)throw new Te("Unable to update user");return r.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),p}catch(e){throw r.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:i}}),e}},async initLoginWithOAuth(e,t,n){if(Be.current=e,!qe())return void Ye("InAppBrowserLoginNotPossible");if("google"===e&&!d.allowOAuthInEmbeddedBrowsers&&Ri(window.navigator.userAgent))return void Ye("InAppBrowserLoginNotPossible");"twitter"===e&&window.opener&&window.opener.postMessage({type:Ti},"*"),Me.del(Je),Me.del(Qe);let a=new la({provider:e,disableSignup:!!n,withPrivyUi:!0,customOAuthRedirectUrl:d.customOAuthRedirectUrl});t&&a.addCaptchaToken(t),r.startAuthFlow(a);let i=await r.authFlow.getAuthorizationUrl();if(i&&i.url)if("twitter"===e&&At&&(i.url=i.url.replace("x.com","twitter.com")),"chrome-extension:"===window.location.protocol&&na())try{let{privyOAuthCode:e,privyOAuthState:t}=await ra(i.url);Ye("OAuthStatusScreen"),a.meta.stateCode=t,a.meta.authorizationCode=e}catch(e){throw console.error("OAuth in chrome extension flow failed:",e),e}else window.location.assign(i.url)},async initLoginWithTelegram(e,t){if(!y)throw new Ue;Be.current="telegram";let n=new Ta(e,t);r.startAuthFlow(n),ce({status:"loading"}),n.meta.telegramWebAppData=void 0,n.meta.telegramAuthResult=await new Promise(((e,t)=>d.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:d.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(n=>n?e(n):("link"===Ke.current?tr(Ne,"linkAccount","onError",_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}):"login"===Ke.current?tr(Ne,"login","onError",_e.INVALID_CREDENTIALS):"update"===Ke.current&&tr(Ne,"login","onError",_e.FAILED_TO_UPDATE_ACCOUNT),t(new Te("Telegram auth failed or was canceled by the client"))))):t(new Te("Telegram was not initialized")):t(new Te("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,n;if(!(r.authFlow instanceof Ta))throw new Te("Must initialize Telegram flow before calling loginWithTelegram");r.authFlow.meta.captchaToken||=e?.captchaToken;let a=await $r(),i=e?.intent||Ke.current;if("login"===i)try{let e=await r.authenticate();t=e.user,n=e.isNewUser,Be.current="telegram"}catch(e){throw tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}else{if("link"!==i)throw new Te("Unknown auth intent");try{t=(await r.link()).user,Be.current="telegram"}catch(e){throw tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}v(t),_(n||!1),Ve(!0),ce({status:"done"});let s=t?.linkedAccounts.find((({type:e})=>"telegram"===e))||null;return{user:t,isNewUser:n||!1,wasAlreadyAuthenticated:!!a,loginAccount:s}},async loginWithOAuth(e){let t,n,a;if(!(r.authFlow instanceof la))throw new Te("Must initialize OAuth flow before calling loginWithOAuth");let i=Me.get(Ze),s=r.authFlow.meta.stateCode;if(i!==s)throw r.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:i??"",returnedStateCode:s??""}}),new Te("Unexpected auth flow. This may be a phishing attempt.",void 0,_e.OAUTH_UNEXPECTED);if(null!==await r.getAccessToken())try{let n=await r.link();t=n.user,a=n.oAuthTokens,Be.current=e}catch(t){throw tr(Ne,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let i=await r.authenticate();t=i.user,n=i.isNewUser,a=i.oAuthTokens,Be.current=e}catch(t){throw"login"===Ke.current?tr(Ne,"login","onError",t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ke.current&&tr(Ne,"linkAccount","onError",t.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return v(t),_(n||!1),Ve(!0),a&&t&&tr(Ne,"oAuthAuthorization","onOAuthTokenGrant",{oAuthTokens:a,user:t}),a},passkeyAuthState:z,setPasskeyAuthState:q,async initSignupWithPasskey({captchaToken:e,withPrivyUi:t}){let n=new ua({captchaToken:e,setPasskeyAuthState:q,hints:d.passkeys.registration?.hints});r.startAuthFlow(n),Ke.current="login";try{Be.current="passkey",q({status:"generating-challenge"}),await n.initRegisterFlow(t),q({status:"awaiting-passkey"})}catch(e){throw q({status:"error",error:e}),tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}},async signupWithPasskey(){let e,t;if(!y)throw new Ue;if(!(r.authFlow instanceof ua))throw new Te("Must initialize Passkey flow first.");if("passkey"!==Be.current){let e=new Te("Must init login with Passkey flow first.");throw q({status:"error",error:e}),e}let n=await $r();try{Be.current="passkey",q({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await r.authenticate())}catch(e){throw q({status:"error",error:e}),tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(e),_(t||!1),Ve(!0),q({status:"done"});let a=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!n,loginAccount:a}},async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let n=new ua({captchaToken:e,setPasskeyAuthState:q,hints:void 0});r.startAuthFlow(n),Ke.current="login";try{Be.current="passkey",q({status:"generating-challenge"}),await n.initAuthenticationFlow(t),q({status:"awaiting-passkey"})}catch(e){throw q({status:"error",error:e}),tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(e){let t,n;if(!y)throw new Ue;if(!(r.authFlow instanceof ua))throw new Te("Must initialize Passkey flow first.");if(e?.credentialIds&&(r.authFlow.meta.allowedCredentialsIds=e.credentialIds),"passkey"!==Be.current){let e=new Te("Must init login with Passkey flow first.");throw q({status:"error",error:e}),e}let a=await $r();try{Be.current="passkey",q({status:"awaiting-passkey"}),({user:t,isNewUser:n}=await r.authenticate())}catch(e){throw q({status:"error",error:e}),tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}v(t),_(n||!1),Ve(!0),q({status:"done"});let i=t?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:t,isNewUser:n||!1,wasAlreadyAuthenticated:!!a,loginAccount:i}},async initLinkWithPasskey(e){let t=new ua({captchaToken:e,hints:d.passkeys.registration?.hints});r.startAuthFlow(t),Ke.current="link",Be.current="passkey",q({status:"generating-challenge"});try{await t.initLinkFlow(),q({status:"awaiting-passkey"})}catch(e){throw tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),q({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!y)throw new Ue;if(!(r.authFlow instanceof ua))throw new Te("Must initialize Passkey flow first.");if("passkey"!==Be.current)throw new Te("Must init login with Passkey flow first.");try{Be.current="passkey",({user:e}=await r.link())}catch(e){throw tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return v(e||f||null),q({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,n){if(!qe())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&!d.allowOAuthInEmbeddedBrowsers&&Ri(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let a=new la({provider:e,withPrivyUi:!1,disableSignup:n??!1,customOAuthRedirectUrl:d.customOAuthRedirectUrl});t&&a.addCaptchaToken(t),Q({status:"loading"});let i=await r.startAuthFlow(a).getAuthorizationUrl();if(i?.url)if("chrome-extension:"===window.location.protocol&&na())try{let{privyOAuthCode:e,privyOAuthState:t}=await ra(i.url);a.meta.stateCode=t,a.meta.authorizationCode=e,await It(a.meta)}catch(e){throw Q({status:"error",error:e}),e}else window.location.assign(i.url)},loginWithHeadlessOAuth:It,initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:n,withPrivyUi:a})=>{let i=new Jr({email:e,captchaToken:t,disableSignup:n});r.startAuthFlow(i);try{Be.current="email",B({status:"sending-code"});let e=await i.sendCodeEmail({withPrivyUi:a});if(e?.ssoRedirectUrl)return window.location.href=e.ssoRedirectUrl,void await ie(1e4);B({status:"awaiting-code-input"})}catch(e){throw B({status:"error",error:e}),"login"===Ke.current?tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ke.current&&tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async({oldAddress:e,newAddress:t,captchaToken:n})=>{let a=new Qr(e,t,n);r.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){throw tr(Ne,"update","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:Be.current}),e}},initUpdatePhone:async(e,t,n)=>{let a=new ya(e,t,n);r.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){tr(Ne,"update","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:Be.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:n,withPrivyUi:a})=>{$({status:"sending-code"});let i=new ma({phoneNumber:e,captchaToken:t,disableSignup:n});r.startAuthFlow(i);try{Be.current="sms",await i.sendSmsCode({withPrivyUi:a}),$({status:"awaiting-code-input"})}catch(e){throw $({status:"error",error:e}),"login"===Ke.current?tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR):"link"===Ke.current&&tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(r.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(r.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,n;function a(e){r.authFlow instanceof Jr?B(e):r.authFlow instanceof ma&&$(e)}if(a({status:"submitting-code"}),!y){let e=new Ue;throw a({status:"error",error:e}),e}if(r.authFlow instanceof Jr)r.authFlow.meta.emailCode=e.trim();else{if(!(r.authFlow instanceof ma)){let e=new Te("Must initialize a passwordless code flow first");throw a({status:"error",error:e}),e}r.authFlow.meta.smsCode=e.trim()}let i=await $r();if("link"===Ke.current)try{({user:t}=await r.link())}catch(e){throw a({status:"error",error:e}),tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:Be.current}),e}else if("update"===Ke.current)try{({user:t}=await r.link())}catch(e){throw a({status:"error",error:e}),tr(Ne,"update","onError",e.privyErrorCode||_e.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:Be.current}),e}else try{({user:t,isNewUser:n}=await r.authenticate())}catch(e){throw a({status:"error",error:e}),tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}let s=t||f;v(s||null),_(n||!1),Ve(!0),a({status:"done"});let o=null;return r.authFlow instanceof Jr?o=s?.linkedAccounts.find((({type:e})=>"email"===e))||null:r.authFlow instanceof ma&&(o=s?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:s,isNewUser:n||!1,wasAlreadyAuthenticated:!!i,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:n})=>{Ke.current=xe?"link":"login",Be.current="siwe",Y({status:"generating-message"});let a=await r.generateSiweNonce({address:e,captchaToken:n});return Y({status:"awaiting-signature"}),ha({address:e,chainId:t.replace("eip155:",""),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let n=await r.generateSiweNonce({address:e});return ha({address:e,chainId:t.replace("eip155:",""),nonce:n})},linkSmartWallet:async({message:e,signature:t,smartWalletType:n,smartWalletVersion:a})=>{let i;i=await r.linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:a}),v((i=await Pt.refreshSessionAndUser()??i)||f||null)},loginWithSiwe:async({message:e,signature:t,captchaToken:n,disableSignup:a,walletClientType:i,connectorType:s})=>{let o,l=null;try{if(f)throw Error("User already authenticated");let c=new pa(r,void 0,n,a,{message:e,signature:t,walletClientType:i,connectorType:s});r.startAuthFlow(c),Be.current="siwe",Ke.current="login",Y({status:"submitting-signature"});let d=await r.authenticate();if(({user:l,isNewUser:o}=d),!l)throw Error("Authentication failed - no user returned")}catch(e){throw tr(Ne,"login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),Y({status:"error",error:e}),e}return v(l),_(o||!1),Ve(!0),Y({status:"done"}),Ke.current=null,Be.current=null,{user:l,isNewUser:o||!1}},linkWithSiwe:async({message:e,signature:t,chainId:n,walletClientType:a,connectorType:i})=>{let s;ut("siwe");let o=null;try{Y({status:"submitting-signature"}),s=await r.linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:a,connectorType:i}),s=await Pt.refreshSessionAndUser()??s,Y({status:"done"}),(o=yt(s)||null)&&tr(Ne,"linkAccount","onSuccess",{user:s,linkMethod:"siwe",linkedAccount:o})}catch(e){throw tr(Ne,"linkAccount","onError",e.privyErrorCode||_e.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),Ke.current=null,Be.current=null,Y({status:"error",error:e}),e}let l=s||f;return v(l||null),Ke.current=null,Be.current=null,{user:l,linkedAccount:o}},refreshSessionAndUser:async()=>{let e=await r.getAuthenticatedUser();return Ve(!!e),v(e),e},walletProxy:de,createAnalyticsEvent:({eventName:e,payload:t,timestamp:n})=>r.createAnalyticsEvent({eventName:e,payload:t,timestamp:n}),acceptTerms:async()=>{let e=await r.acceptTerms();return v(e),e},getUsdTokenPrice:e=>r.getUsdTokenPrice(e),getUsdPriceForSol:()=>r.getUsdPriceForSol(),getSplTokenMetadata:e=>r.getSplTokenMetadata(e),recoverEmbeddedWallet:async e=>new Promise((async(t,n)=>{if(!f)return void t(!0);let a=e?.address?R(f,e.address):b(f)||U(f).at(0)||x(f).at(0);if(!a||E(a))return void t(!0);let i=await $r();if(!i||!de||!a)return void n(Error("Must have valid access token and Privy wallet to recover wallet"));let{entropyId:s,entropyIdVerifier:o}=Ae(f,a);try{await de.connect({accessToken:i,entropyId:s,entropyIdVerifier:o}),t(!0)}catch(e){if(ni(e)&&"privy"===a.recoveryMethod){let e;r.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:a.address}});try{e=await de.recover({entropyId:s,entropyIdVerifier:o,accessToken:i})}catch(e){return void n(e)}e.entropyId||n(Error("Unable to recover wallet")),r.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:a.address}}),t(!0)}else ni(e)&&"privy"!==a.recoveryMethod&&"privy-v2"!==a.recoveryMethod?(we({recoverWallet:{entropyId:s,entropyIdVerifier:o,onFailure:n,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:"recover",shouldCreateEth:!1,shouldCreateSol:!1}}),Ye(Wi(a.recoveryMethod))):n(e)}})),setReadyToTrue:e=>{g(!0),me?.(e)},updateWallets:()=>pt(),fundWallet:async(e,t)=>{let n="FundingMethodSelectionScreen";return new Promise(((r,a)=>{we({funding:{...ze({address:e,appConfig:d,fundWalletConfig:t,methodScreen:n,onComplete:r,onError:a})}}),Ye(n)}))},openModal:Ye,requestFarcasterSignerStatus:async e=>{let t=await $r(),n=f?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!de||!n)throw Error("Must have an embedded wallet to use Farcaster signers");if(!f?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let a=await r.requestFarcasterSignerStatus(e);return"approved"===a.status&&v(await r.getAuthenticatedUser()||f||null),a},connectCoinbaseSmartWallet:async()=>{d.externalWallets.coinbaseWallet.config.preference={...d.externalWallets.coinbaseWallet.config.preference,options:"smartWalletOnly"};let e=r.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||r.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),ot(e);await st("coinbase_wallet","coinbase_smart_wallet")},connectBaseAccount:async()=>{let e=r.connectors?.findWalletConnector("base_account","base_account");if(e)return ot(e);await st("base_account","base_account")},initiateAccountTransfer:async({nonce:e,account:t,accountType:n,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l})=>{let c=await r.sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:a,telegramAuthResult:i,telegramWebAppData:s,farcasterEmbeddedAddress:o,oAuthUserInfo:l});return v(c),c},inProgressAuthFlowRef:Ke,inProgressLoginOrLinkMethodRef:Be};as=Pt.recoverEmbeddedWallet,Pt.recoverEmbeddedWallet;let Wt=l((()=>({wallets:A,ready:fe&&Oe})),[A,fe,Oe]),Ut=r.authFlow instanceof Ta,{siteKey:Nt,enabledProvider:Ot}=d.captcha,Rt=!d.headless&&Ot&&!xe&&(y||Ut);/*#__PURE__*/return t(Xi.Provider,{value:!0,children:/*#__PURE__*/t(N.Provider,{value:St,children:/*#__PURE__*/t(nr.Provider,{value:Ne,children:/*#__PURE__*/t(ve.Provider,{value:Wt,children:/*#__PURE__*/t(va,{appId:d.id,captchaSiteKey:Nt,enabledCaptchaProvider:Ot,children:/*#__PURE__*/e(We.Provider,{value:Pt,children:[/*#__PURE__*/t(te,{children:/*#__PURE__*/e(O,{data:pe,setModalData:we,setInitialScreen:P,initialScreen:S,authenticated:xe,open:u,children:[n.children,/*#__PURE__*/t(Zi,{customAuth:d.customAuth}),Rt&&/*#__PURE__*/t(Ia,{delayedExecution:!1}),/*#__PURE__*/t(Qa,{}),/*#__PURE__*/t(ji,{disabled:d.embeddedWallets.disableAutomaticMigration}),/*#__PURE__*/t(Na,{palette:d.appearance.palette||{}}),!d.render.standalone&&/*#__PURE__*/t(Ka,{open:u})]})}),/*#__PURE__*/t(gi,{appId:n.appId,appClientId:n.clientId,clientAnalyticsId:r.clientAnalyticsId,origin:r.apiUrl,mfaMethods:f?.mfaMethods,mfaPromise:Ie,mfaSubmitPromise:Pe,onLoad:ue,onLoadFailed:()=>null}),d.loginConfig.telegramAuthConfiguration&&
/*#__PURE__*/t(V,{$if:!0,children:/*#__PURE__*/t(Ja,{scriptHost:n.apiUrl||nt,botUsername:d.loginConfig.telegramAuthConfiguration.botName})})]})})})})})})},ss=e=>as(e);class os extends Error{constructor(e,t,n){super(e),this.code=t,this.data=n}}class ls extends L{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new os(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await $r()||!this.address)throw new os("Disconnected",4900);let{hash:n}=await((e,t)=>rs(e,t))(t,{address:this.address});return n}async handleSignTransaction(e){if(!e.params||!Array.isArray(e.params))throw new os(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await $r()||!this.address)throw new os("Disconnected",4900);let{signature:n}=await((e,t)=>ns(e,t))(t,{address:this.address});return n}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new os(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new os(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.publicClient=fr(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],n=e.params[1],{signature:r}=await((e,t)=>es(e,t))({message:t},{address:n});return r}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],n="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1],{signature:r}=await((e,t)=>ts(e,t))(ae(n),{address:t});return r}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:q(this.chainId)};return await this.publicClient.estimateGas({account:t.from??this.address,...Be(t)})}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return q(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"eth_signTransaction":return this.handleSignTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!(e=>Gr.includes(e))(e.method))return this.publicClient.request({method:e.method,params:e.params});{let t=await $r();if(await ss({address:this.address}),!t||!this.address)throw new os("Disconnected",4900);try{let n={method:e.method,params:e.params},r=this.walletAccount;return r&&E(r)?this.handleWalletApiRequest(n,r,t):(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:n})).response.data}catch(e){throw console.error(e),new os("Disconnected",4900)}}}async handleWalletApiRequest(e,t,n){let r=this.privyClient;if(!r)throw new os("Disconnected",4900);if("secp256k1_sign"===e.method){let a=await m(r,(async({message:e})=>this.walletProxy.signWithUserSigner({accessToken:n,message:e})),{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:t.id,params:{hash:e.params[0]}});if("secp256k1_sign"!==a.method)throw new os(`Invalid params for ${e.method}`,4200);return a.data.signature}throw new os(`Method not supported: ${e.method}`,4200)}constructor({walletProxy:e,address:t,entropyId:n,entropyIdVerifier:r,rpcConfig:a,chains:i,appId:s,chainId:o=1,walletIndex:l,privyClient:c,walletAccount:d}){super(),this.walletProxy=e,this.address=t,this.entropyId=n,this.entropyIdVerifier=r,this.chainId=o,this.rpcConfig=a,this.chains=i,this.publicClient=fr(o,this.chains,a,{appId:s}),this.rpcTimeoutDuration=Q(a,"privy"),this.appId=s,this.walletIndex=l,this.privyClient=c,this.walletAccount=d}}const cs=({style:e,...n})=>/*#__PURE__*/t("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",stroke:"currentColor",strokeWidth:1.5,viewBox:"0 0 24 24",style:{...e},...n,children:/*#__PURE__*/t("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25m18 0A2.25 2.25 0 0018.75 3H5.25A2.25 2.25 0 003 5.25m18 0V12a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 12V5.25"})}),ds=({style:n,...r})=>/*#__PURE__*/e("svg",{xmlns:"http://www.w3.org/2000/svg",width:"108",height:"108",viewBox:"0 0 108 108",fill:"none",style:{height:"28px",width:"28px",...n},...r,children:[/*#__PURE__*/t("rect",{width:"108",height:"108",rx:"23",fill:"#AB9FF2"}),/*#__PURE__*/t("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M46.5267 69.9229C42.0054 76.8509 34.4292 85.6182 24.348 85.6182C19.5824 85.6182 15 83.6563 15 75.1342C15 53.4305 44.6326 19.8327 72.1268 19.8327C87.768 19.8327 94 30.6846 94 43.0079C94 58.8258 83.7355 76.9122 73.5321 76.9122C70.2939 76.9122 68.7053 75.1342 68.7053 72.314C68.7053 71.5783 68.8275 70.7812 69.0719 69.9229C65.5893 75.8699 58.8685 81.3878 52.5754 81.3878C47.993 81.3878 45.6713 78.5063 45.6713 74.4598C45.6713 72.9884 45.9768 71.4556 46.5267 69.9229ZM83.6761 42.5794C83.6761 46.1704 81.5575 47.9658 79.1875 47.9658C76.7816 47.9658 74.6989 46.1704 74.6989 42.5794C74.6989 38.9885 76.7816 37.1931 79.1875 37.1931C81.5575 37.1931 83.6761 38.9885 83.6761 42.5794ZM70.2103 42.5795C70.2103 46.1704 68.0916 47.9658 65.7216 47.9658C63.3157 47.9658 61.233 46.1704 61.233 42.5795C61.233 38.9885 63.3157 37.1931 65.7216 37.1931C68.0916 37.1931 70.2103 38.9885 70.2103 42.5795Z",fill:"#FFFDF8"})]});function us(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}var hs=0;class ps extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return{name:this.providerDetail.info.name,icon:this.providerDetail.info.icon,id:this.providerDetail.info.rdns}}disconnect(){console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`)}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(a||"unknown",e,t,n),this.connectorType="injected",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.providerDetail=r;let i=r.provider;this.proxyProvider.setWalletProvider(i)}}var ws="__private_"+hs+++"__walletBranding";class ms extends j{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return us(this,ws)[ws]??{name:"Browser Extension",icon:cs,id:"extension"}}disconnect(){console.warn("Programmatic disconnect with browser wallets is not yet supported.")}async promptConnection(){try{let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}constructor(e,t,n,r,a){super(a??"unknown",e,t,n),Object.defineProperty(this,ws,{writable:!0,value:void 0}),this.connectorType="injected",this.proxyProvider=new z(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.proxyProvider.setWalletProvider(r),"metamask"===a?us(this,ws)[ws]={name:"MetaMask",icon:ce,id:"io.metamask"}:"phantom"===a&&(us(this,ws)[ws]={name:"Phantom",icon:ds,id:"phantom"})}}class ys extends ps{disconnect(){console.warn("MetaMask does not support programmatic disconnect.")}async promptConnection(){try{ft||await this.proxyProvider.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]});let e=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!e||0===e.length||!e[0])throw new ke("Unable to retrieve accounts");await this.syncAccounts([e[0]])}catch(e){throw Re(e)}}}class gs extends L{get wallets(){let e=new Set;return this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let n=`${t.address}${t.walletClientType}${t.connectorType}${t.meta.id}`;return!e.has(n)&&(e.add(n),!0)}))}async initialize(e){if(this.initialized&&!e||(e&&this.removeAllConnectors(),this.externalWalletConfig.disableAllExternalWallets))return;let t=de({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:n})=>{this.createEthereumWalletConnector({connectorType:"injected",walletClientType:e,providers:{eip6963InjectedProvider:t,legacyInjectedProvider:n}})}))}));for(let e of(this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector({connectorType:"coinbase_wallet",walletClientType:"coinbase_wallet"}),this.walletList.includes("base_account")&&this.createEthereumWalletConnector({connectorType:"base_account",walletClientType:"base_account"}),Object.values(ue)))!e.isInstalled&&this.walletList.includes(e.client)&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&e.chainTypes.includes("ethereum")&&this.createEthereumWalletConnector({connectorType:"null",walletClientType:e.client,walletConfig:e}),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&e.chainTypes.includes("solana")&&this.addSolanaWalletConnector(new he({id:e.client,name:e.name})));this.externalWalletConfig.walletConnect.enabled&&(this.walletList.includes("wallet_connect_qr")||ee(this.walletList))&&"solana-only"!==this.walletChainType&&this.createEthereumWalletConnector({connectorType:"wallet_connect_v2",walletClientType:"unknown"});let n=this.walletList.includes("wallet_connect_qr_solana")||ee(this.walletList)&&"ethereum-only"!==this.walletChainType,r=this.externalWalletConfig.solana.connectors?.get()||[],a=async e=>{if(!n)return;let t=e.find((e=>"walletconnect_solana"===e.walletBranding?.id));t&&t.wallet&&await t.wallet.initialize({walletConnectCloudProjectId:this.walletConnectCloudProjectId,privyAppName:this.privyAppName})};a(r),r.filter((e=>n||"walletconnect_solana"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{a(e),e?.filter((e=>n||"walletconnect_solana"!==e.walletBranding?.id)).forEach(this.addSolanaWalletConnector)})),await t,this.initialized=!0}findWalletConnector(e,t,n){return"wallet_connect_v2"===e?this.walletConnectors.filter(pe).find((t=>t.connectorType===e&&(!n||t.wallets.some((e=>e.address===n)))))??null:this.walletConnectors.filter(pe).find((r=>r.connectorType===e&&r.walletClientType===t&&(!n||r.wallets.some((e=>e.address===n)))))??null}findSolanaWalletConnector(e){return this.walletConnectors.filter(we).find((t=>"unknown"===t.walletClientType?t.walletBranding.id===e:t.walletClientType===e))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}findImportedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded_imported"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&("solana"===e.type&&"unknown"===t.walletClientType&&"unknown"===e.walletClientType?e.meta.id===t.id:t.walletClientType===e.walletClientType)));t&&(e.connectedAt=t.connectedAt)})),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&this.emit("walletsUpdated")}addEmbeddedWalletConnectors({walletProxy:e,user:t,embeddedWallets:n,defaultChain:r,appId:a,privyClient:i}){let{entropyId:s,entropyIdVerifier:o}=Ae(t);for(let t of n){let n=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===t.walletIndex));if(n&&pe(n))n.proxyProvider.walletProxy=e;else{let n=new Kr({provider:new ls({walletProxy:e,address:t.address,entropyId:s,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id,walletIndex:t.walletIndex,privyClient:i,walletAccount:t}),chains:this.chains,defaultChain:r,rpcConfig:this.rpcConfig,imported:!1,walletIndex:t.walletIndex});this.addWalletConnector(n)}}}addImportedWalletConnector(e,t,n,r){let a=this.findWalletConnector("embedded_imported","privy",t);if(a&&pe(a))a.proxyProvider.walletProxy=e;else{let a=new Kr({provider:new ls({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:r,chainId:n.id}),chains:this.chains,walletIndex:0,defaultChain:n,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(a)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.storedConnections=He(),this.emit("walletsUpdated")}removeImportedWalletConnectors(){let e=this.findImportedWalletConnectors();e.length&&(e.forEach((e=>{let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1)})),this.storedConnections=He(),this.emit("walletsUpdated"))}async createEthereumWalletConnector({connectorType:e,walletClientType:t,providers:n,walletConfig:r}){let a=this.findWalletConnector(e,t);if(a&&pe(a))return a instanceof Za&&a.resetConnection(t),a;let i=(()=>"injected"!==e?"coinbase_wallet"===e?new Vr(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.coinbaseWallet.config):"base_account"===e?new qr(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig.baseAccount.config,this.setBaseAccountSdk):"null"!==e?new Za({walletConnectCloudProjectId:this.walletConnectCloudProjectId,rpcConfig:this.rpcConfig,chains:this.chains,defaultChain:this.defaultChain,shouldEnforceDefaultChainOnConnect:this.shouldEnforceDefaultChainOnConnect,privyAppId:this.privyAppId,privyAppName:this.privyAppName,walletClientType:t}):r?new me({id:r.client,name:r.name,defaultChain:this.defaultChain,walletClientType:r.client}):null:"metamask"===t&&n?.eip6963InjectedProvider?new ys(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,"metamask"):"metamask"===t&&n?.legacyInjectedProvider?new ms(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,"metamask"):"phantom"===t&&n?.legacyInjectedProvider?new ms(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider,"phantom"):n?.legacyInjectedProvider&&"unknown_browser_extension"===t?new ms(this.chains,this.defaultChain,this.rpcConfig,n?.legacyInjectedProvider):n?.eip6963InjectedProvider?new ps(this.chains,this.defaultChain,this.rpcConfig,n?.eip6963InjectedProvider,t):void 0)();return i&&this.addWalletConnector(i),i||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}setWalletList(e){this.walletList=e,this.initialized&&this.initialize(!0).catch(console.error)}removeAllConnectors(){for(let e of this.walletConnectors)e.removeAllListeners();this.walletConnectors=[]}constructor(e,t,n,r,a,i,s,o,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{let t=this.findSolanaWalletConnector(e.walletClientType);if(!t||"null"===t.connectorType){if("null"===t?.connectorType){let e=this.walletConnectors.indexOf(t);this.walletConnectors.splice(e,1)}this.addWalletConnector(e)}},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=n,this.chains=r,this.defaultChain=a,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=s,this.shouldEnforceDefaultChainOnConnect=o,this.externalWalletConfig=l,this.privyAppName=c,this.walletChainType=u||"ethereum-only",this.setBaseAccountSdk=d,this.storedConnections=He()}}const fs=rr((()=>({identityToken:null})));function vs(){let{identityToken:e}=fs();return{identityToken:e}}let As=[Xt,en,tn];class ks{async get(e,t){try{return await this.baseFetch(e,t)}catch(e){throw Ce(e)}}async post(e,t,n){try{return await this.baseFetch(e,{method:"POST",...t?{body:t}:{},...n})}catch(e){throw Ce(e)}}async delete(e,t){try{return await this.baseFetch(e,{method:"DELETE",...t})}catch(e){throw Ce(e)}}constructor({appId:e,appClientId:t,client:n,defaults:r}){this.appId=e,this.appClientId=t,this.clientAnalyticsId=n.clientAnalyticsId,this.sdkVersion=it,this.client=n,this.defaults=r,this.fallbackApiUrl=n.fallbackApiUrl,this.baseFetch=Ar.create({baseURL:this.defaults.baseURL,timeout:this.defaults.timeout,retry:3,retryDelay:500,retryStatusCodes:[408,409,425,500,502,503,504],credentials:"include",onRequest:async({request:e,options:t})=>{let n=new Headers(t.headers);n.set("privy-app-id",this.appId),this.appClientId&&n.set("privy-client-id",this.appClientId),n.set("privy-ca-id",this.clientAnalyticsId||""),n.set("privy-client",`react-auth:${this.sdkVersion}`);let r=As.includes(e.toString());if(!n.has("authorization")){let e=await this.client.getAccessToken({disableAutoRefresh:r});null!==e&&n.set("authorization",`Bearer ${e}`)}t.headers=n,t.retryDelay&&"number"==typeof t.retryDelay&&(t.retryDelay=3*t.retryDelay)},onRequestError:({error:e})=>{if(e instanceof DOMException&&"AbortError"===e.name)throw new Ne}})}}const Ts=e=>({rpId:e.rp_id,challenge:e.challenge,allowCredentials:e.allow_credentials?.map((e=>({id:e.id,type:e.type,transports:e.transports})))||[],timeout:e.timeout,extensions:{appid:e.extensions?.app_id,credProps:e.extensions?.cred_props,hmacCreateSecret:e.extensions?.hmac_create_secret},userVerification:e.user_verification});class Cs{getOrCreateGuestCredential(e){let t=at(e);if(qe()){if(Me.get(t))return Me.get(t);{let e=T.encode(aa(32));return Me.put(t,e),e}}return T.encode(aa(32))}async authenticate(){if(!this.api)throw new Te("Auth flow has no API instance");try{return await this.api.post(nn,{guest_credential:this.meta.guestCredential})}catch(e){throw Ce(e)}}async link(){throw Error("Linking is not supported for the guest flow")}constructor(e){this.meta={guestCredential:this.getOrCreateGuestCredential(e)}}}function _s(){return!(kt&&window.location.origin.startsWith("http://localhost"))}var bs,Ss=((bs={}).PRIVY="privy_access_token",bs.CUSTOMER="customer_access_token",bs);class Es{get token(){return this.privyAccessToken||this.customerAccessToken}getToken(e){return"privy_access_token"===e?this.privyAccessToken:this.customerAccessToken}get customerAccessToken(){return this._getToken(Ge)}get privyAccessToken(){return this._getToken($e)}_getToken(e){try{let t=Me.get(e);return"string"==typeof t?Mr.throwIfNotWellFormedJwt(t):null}catch(e){return console.error(e),this.destroyLocalState(),null}}get refreshToken(){try{let e=Me.get(st);return"string"==typeof e?e:null}catch(e){return console.error(e),this.destroyLocalState(),null}}getProviderAccessToken(e){try{let t=Me.get(ot(e));if("string"!=typeof t)return null;{let n=new Mr(t);return n.isExpired()?(Me.del(ot(e)),null):n.value}}catch(e){return console.error(e),null}}get mightHaveServerCookies(){try{let e=kr.get(lt);return void 0!==e&&e.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e="privy_access_token"){let t="string"==typeof this.getToken(e),n="string"==typeof this.refreshToken&&this.refreshToken!==ct;return this.mightHaveServerCookies||t&&n}hasActiveAccessToken(e){let t=Mr.parse(this.getToken(e));return null!==t&&!t.isExpired(30)}authenticate(e){return this.authenticateOnce.execute(e)}link(e){return this.linkOnce.execute(e)}refresh(){return this.refreshOnce.execute()}destroy(){return this.destroyOnce.execute()}storeProviderAccessToken(e,t){"string"==typeof t?Me.put(ot(e),t):Me.del(ot(e))}updateIdentityToken(e){"string"==typeof e?this.storeIdentityToken(e):this.clearIdentityToken()}async _authenticate(e){try{let t=await e.authenticate(),{user:n,is_new_user:r,oauth_tokens:a}=t;this.handleTokenResponse(t);let i=a?{provider:a.provider,accessToken:a.access_token,accessTokenExpiresInSeconds:a.access_token_expires_in_seconds,refreshToken:a.refresh_token,refreshTokenExpiresInSeconds:a.refresh_token_expires_in_seconds,scopes:a.scopes}:void 0;return this._trackAuthenticateEvents(e,r),{user:F(n),isNewUser:r,oAuthTokens:i}}catch(e){throw console.warn("Error authenticating session"),Oe(e)}}_trackAuthenticateEvents(e,t){let n=function(e){return e instanceof Jr?"email":e instanceof ma?"sms":e instanceof pa?"siwe":e instanceof Cs?"guest":e instanceof Vi?"custom_auth":e instanceof la?e.meta.provider:null}(e);n&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate",payload:{method:n,isNewUser:t}}),"siwe"===n&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate_siwe",payload:{connectorType:e.meta.connectorType,walletClientType:e.meta.walletClientType}})}async _link(e){try{let t=await e.link(),n=t.oauth_tokens,r=n?{provider:n.provider,accessToken:n.access_token,accessTokenExpiresInSeconds:n.access_token_expires_in_seconds,refreshToken:n.refresh_token,refreshTokenExpiresInSeconds:n.refresh_token_expires_in_seconds,scopes:n.scopes}:void 0;return{user:F(t),oAuthTokens:r}}catch(e){throw console.warn("Error linking account"),Oe(e)}}async _refresh(){if(!this.api)throw new Te("Session has no API instance");if(!this.client)throw new Te("Session has no PrivyClient instance");await this.client.getAccessToken({disableAutoRefresh:!0});let e=this.token,t=this.refreshToken;if(this.client.useServerCookies&&!this.mightHaveServerCookies&&this.token&&window.location.origin===this.client.apiUrl)return this.destroyLocalState(),null;try{let n;if(!(e&&t||this.mightHaveServerCookies))return null;{let r={};e&&(r.authorization=`Bearer ${e}`),n=await this.api.post(Xt,t?{refresh_token:t}:{},{headers:r})}return this.handleTokenResponse(n),F(n.user)}catch(e){if(e instanceof Pe&&e.privyErrorCode===_e.MISSING_OR_INVALID_TOKEN)return console.warn("Unable to refresh tokens - token is missing or no longer valid"),this.destroyLocalState(),null;throw Oe(e)}}handleTokenResponse(e){e.session_update_action&&"set"!==e.session_update_action?"clear"===e.session_update_action?this.destroyLocalState():"ignore"===e.session_update_action&&(e.token&&(this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token)),e.identity_token&&this.storeIdentityToken(e.identity_token)):this._storeAllTokens(e)}_storeAllTokens(e){this.storeRefreshToken(e.refresh_token),this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),e.identity_token&&this.storeIdentityToken(e.identity_token)}async _destroy(){try{await(this.api?.post(en,{refresh_token:this.refreshToken}))}catch(e){console.warn("Error destroying session")}this.destroyLocalState()}destroyLocalState(){this.storeRefreshToken(null),this.storeCustomerAccessToken(null),this.storePrivyAccessToken(null),this.clearIdentityToken()}storeCustomerAccessToken(e){if("string"==typeof e){let t=Me.get(Ge);if(Me.put(Ge,e),!this.client?.useServerCookies){let t=Mr.parse(e)?.expiration;kr.set(dt,e,{sameSite:"Strict",secure:_s(),expires:t?new Date(1e3*t):void 0})}t!==e&&this.client?.onStoreCustomerAccessToken?.(e)}else Me.del(Ge),kr.remove(dt),this.client?.onDeleteCustomerAccessToken?.()}storeRefreshToken(e){"string"==typeof e?(Me.put(st,e),this.client?.useServerCookies||kr.set(lt,"t",{sameSite:"Strict",secure:_s(),expires:30})):(Me.del(st),kr.remove(ut),kr.remove(lt))}storePrivyAccessToken(e){"string"==typeof e?Me.put($e,e):Me.del($e)}storeIdentityToken(e){if(fs.setState({identityToken:e}),this.client?.useServerCookies)return;Me.put(ht,e);let t=Mr.parse(e)?.expiration;kr.set(pt,e,{sameSite:"Strict",secure:_s(),expires:t?new Date(1e3*t):void 0})}clearIdentityToken(){Me.del(ht),fs.setState({identityToken:null}),kr.remove(pt)}constructor(){this.authenticateOnce=new Zr((async e=>this._authenticate(e))),this.linkOnce=new Zr((async e=>this._link(e))),this.refreshOnce=new Zr(this._refresh.bind(this)),this.destroyOnce=new Zr(this._destroy.bind(this))}}let Is,Ps;var Ws=0,Us="__private_"+Ws+++"__getOrGenerateClientAnalyticsId";class Ns{getAppId(){return this.appId}initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:n,defaultChain:r,store:a,walletList:i,shouldEnforceDefaultChainOnConnect:s,externalWalletConfig:o,appName:l,walletChainType:c,setBaseAccountSdk:d}){this.connectors||(this.connectors=new gs(this.appId,e,t,n,r,a,i,s,o,l,d,c))}generateApi(){let e=new ks({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Te("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Te("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post(rn,{action:"verify"})}catch(e){throw Ce(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(an,{});return Ts(e.options)}catch(e){throw Ce(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(sn,{});return F(e)}catch(e){throw Oe(e)}}async unlinkEmail(e){try{let t=await this.api.post(on,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkPhone(e){try{let t=await this.api.post(ln,{phoneNumber:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(cn,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(dn,{address:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkOAuth(e,t){try{let n=await this.api.post(un,{provider:e,subject:t});return await this.getAuthenticatedUser()??F(n)}catch(e){throw Oe(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(hn,{fid:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async unlinkTelegram(e){try{let t=await this.api.post(pn,{telegram_user_id:e});return await this.getAuthenticatedUser()??F(t)}catch(e){throw Oe(e)}}async revokeDelegatedWallet(){try{await this.api.post(wn,{})}catch(e){throw Oe(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:n,options:r}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(tn,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:n?n.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:r?.keepAlive??!1})}catch(e){console.log("Unable to submit event. This is not an issue.")}}async signMoonpayOnRampUrl(e){try{return this.api.post(mn,e)}catch(e){throw Oe(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(yn,e)}catch(e){throw Oe(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${gn}?partnerUserId=${e}`)}catch(e){throw Oe(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(Ss.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(Ss.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?xr.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async getSplTokenMetadata({mintAddress:e,cluster:t}){try{return await this.api.get(`/api/v1/spl_token_info?mint_address=${e}&cluster=${t}`)}catch(n){return void console.error(`Unable to fetch token metadata for ${t}:${e}`)}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(fn,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i}){return await this.api.post(vn,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){return await this.api.post(An,{message:e,signature:t,chainId:n,walletClientType:r,connectorType:a})}async linkSmartWallet({message:e,signature:t,smartWalletType:n,smartWalletVersion:r}){try{let a=await this.api.post(kn,{message:e,signature:t,smart_wallet_type:n,smart_wallet_version:r});return F(a)}catch(e){throw Oe(e)}}async linkWithSiwe({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:n,walletClientType:r,connectorType:a});return F(i)}catch(e){throw Oe(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(Tn,{address:e,token:t})).nonce}catch(e){throw Oe(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i="plain"}){return await this.api.post(Cn,{message:e,signature:t,walletClientType:n,connectorType:r,mode:a,message_type:i})}async authenticateWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i="plain"}){let s=await this.authenticateWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,mode:a,messageType:i});this.session.handleTokenResponse(s);let o=F(s.user);if(!o)throw Error("Authentication failed - no user returned");return{user:o,isNewUser:s.is_new_user||!1}}async sendAccountTransferRequest({nonce:e,account:t,accountType:n,externalWalletMetadata:r,telegramAuthResult:a,telegramWebAppData:i,farcasterEmbeddedAddress:s,oAuthUserInfo:o}){try{let l,c;switch(n){case"email":l=Wn,c={nonce:e,email:t};break;case"sms":l=Pn,c={nonce:e,phoneNumber:t};break;case"siwe":if(l=In,!r)throw Error("Wallet parameters must be defined");c={nonce:e,address:t,...r};break;case"farcaster":l=En,c={nonce:e,farcaster_id:t,farcaster_embedded_address:s};break;case"telegram":l=Sn,c={nonce:e,telegram_auth_result:a,telegram_web_app_data:i};break;case"siws":l=bn,c={nonce:e,address:t,...r};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:l=_n,c={nonce:e,userInfo:o}}let d=await this.api.post(l,c);return await this.getAuthenticatedUser()??F(d)}catch(e){throw Oe(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a="plain"}){return await this.api.post(Un,{message:e,signature:t,walletClientType:n,connectorType:r,message_type:a})}async linkWithSiws({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a="plain"}){try{let i=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:n,connectorType:r,messageType:a});return F(i)}catch(e){throw Oe(e)}}async updateUserAndIdToken(){try{let e=await this.api.get(Nn);return this.session.updateIdentityToken(e.identity_token),F(e.user)}catch(e){throw Oe(e)}}async scanTransaction(e){try{return await this.api.post(On,e)}catch(e){throw Oe(e)}}constructor({apiUrl:e=nt,appId:t,appClientId:n,timeout:r=wt}){Object.defineProperty(this,Us,{value:Os}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==nt&&e.startsWith("https://privy."),this.timeout=r,this.appId=t,this.appClientId=n,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Us)[Us](),Is||(Is=new Es),this.session=Is,this.api=this.generateApi(),this.session.client=this}}function Os(){if("undefined"==typeof window)return null;try{let e=Me.get(rt);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=A();try{return Me.put(rt,e),e}catch(t){return e}}function Rs(){if(!Ps)throw new Te("No global PrivyClient instance found. Please ensure you have initialized the PrivyProvider.");return Ps}async function Ms(){return await(Ps?.updateUserAndIdToken()),Ps?.useServerCookies?fs.getState().identityToken:Promise.resolve(Me.get(ht)||null)}const xs=({config:e,...n})=>{(()=>{if(a(Xi))throw new Te("Multiple PrivyProvider instances found","Found multiple instances of PrivyProvider, ensure there is only one mounted in your application tree.")})(),function(){if("undefined"==typeof window)return;let e=["localhost","127.0.0.1"].includes(window.location.hostname),t="https:"===window.location.protocol||"chrome-extension:"===window.location.protocol;if(!e&&!t)throw new Te("Embedded wallet is only available over HTTPS")}(),function(e){if("string"!=typeof e||25!==e.length)throw new Te("Cannot initialize the Privy provider with an invalid Privy app ID")}(n.appId),function(e){Ps||(Ps=new Ns({appId:e.appId,appClientId:e.clientId,apiUrl:e.apiUrl}))}(n);let r=l((()=>new p({appId:n.appId,clientId:n.clientId,storage:Me,baseUrl:n.apiUrl,sdkVersion:"react-auth:3.12.0"})),[]),i=Rs(),s=Object.assign({},e);/*#__PURE__*/return t(mt,{client:r,legacyClient:i,appClientId:n.clientId,clientConfig:s,children:/*#__PURE__*/t(Kn,{children:/*#__PURE__*/t(is,{...n,client:i,privy:r})})})},Fs=()=>{let{user:e}=C(),{walletProxy:t}=Ie();return{recover:h((async n=>{if(!t)throw Error("Wallet proxy is not ready");let r=await $r();if(!e||!r)throw new Te("User must be logged in before attempting to modify the recovery method.");let{entropyId:a,entropyIdVerifier:i}=Ae(e);try{await t.recover({entropyId:a,entropyIdVerifier:i,accessToken:r,...n})}catch{throw new Te("Unable to recover wallets")}}),[t,e])}};function Ds(){let{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:i}=a(N);return{promptMfa:e,init:t,submit:n,cancel:r,mfaMethods:i}}function Ls(){let{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:i,submitEnrollmentWithPasskey:s,unenroll:o,enrollInMfa:l}=a(N);return{initEnrollmentWithSms:e,initEnrollmentWithTotp:t,initEnrollmentWithPasskey:n,submitEnrollmentWithSms:r,submitEnrollmentWithTotp:i,submitEnrollmentWithPasskey:s,unenrollWithSms:()=>o("sms"),unenrollWithTotp:()=>o("totp"),unenrollWithPasskey:e=>o("passkey",e),showMfaEnrollmentModal:()=>l(!0),closeMfaEnrollmentModal:()=>l(!1)}}function js(){let e=Rs();return e?e.getCustomerAccessToken():Promise.resolve(Me.get(Ge)||null)}const zs=()=>{let{client:e,setAuthenticated:t,setUser:n}=Ie();return l((()=>({init:async()=>{if(!e)throw new Te("Must initialize Privy client first.");let t=new Tr;return e.startAuthFlow(t),await t.init()},login:async({fid:r,message:a,signature:i})=>{if(!e)throw new Te("Must initialize Privy client first.");if(!(e.authFlow instanceof Tr))throw new Te("Must initialize Farcaster Mini App flow first.");e.authFlow.setAuthData({message:a,signature:i,fid:r});let{user:s}=await e.authenticate();if(!s)throw new Te("Failed to login with Farcaster V2");return n(s),t(!0),{user:s}}})),[e,n,t])},qs=()=>l((()=>({getAccessTokenForProvider:({appId:e})=>{try{let t=Me.get(ot(e));if("string"!=typeof t)return{token:null};{let n=new Mr(t);return n.isExpired()?(Me.del(ot(e)),{token:null}):{token:n.value}}}catch(e){return console.error(e),{token:null}}}})),[]),Hs=e=>{Zn("login",e);let t=Aa(),n=tt(),{ready:r,user:a}=C(),{initLoginWithHeadlessOAuth:i,loginWithHeadlessOAuth:s,oAuthState:o,setOAuthState:l,isHeadlessOAuthLoading:d}=Ie(),u=h((async e=>{try{if(t.enabled&&"success"!==t.status)throw new fa(t.error,null,_e.CAPTCHA_FAILURE);return await i(e.provider,t.token,e.disableSignup)}catch(e){throw l({status:"error",error:e}),e}}),[i,t]),p=h((async()=>{let e=ca();try{if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");let t=e.provider;if(S(t)){if(a&&a.linkedAccounts.some((e=>e.type===t)))return console.warn("User is already logged in with this OAuth provider"),a}else if(a&&t in a&&a[t])return console.warn("User is already logged in with this OAuth provider"),a;if(e.popupFlow)return}catch(e){throw l({status:"error",error:e}),e}try{return await s(e)}catch(e){throw l({status:"error",error:e}),e}finally{da()}}),[s]);return c((()=>{let e=ca();r&&n&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&p().catch((()=>{}))}),[r,n]),{initOAuth:u,loading:d,state:o}},Vs=e=>{let t=Aa(),{emailOtpState:n,setEmailOtpState:r,initLoginWithEmail:a,loginWithCode:i}=Ie();return{sendCode:h((async({email:n,disableSignup:i})=>{try{if(!n)throw Error("Email required to send OTP code");let e=await ka(t);return await a({email:n,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a,t]),loginWithCode:h((async({code:t})=>{try{let{user:n,isNewUser:r,wasAlreadyAuthenticated:a,linkedAccount:s}=await i(t);e?.onComplete?.({user:n,isNewUser:r,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:s})}catch(t){throw r({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),t}}),[i]),state:n}},Bs=e=>{let t=Aa(),{initSignupWithPasskey:n,signupWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:i}=Ie();return{signupWithPasskey:h((async()=>{try{let a=await ka(t);await n({captchaToken:a,withPrivyUi:!1});let{user:i,isNewUser:s,wasAlreadyAuthenticated:o,loginAccount:l}=await r();e?.onComplete?.({user:i,isNewUser:s,wasAlreadyAuthenticated:o,loginMethod:"passkey",loginAccount:l})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),t}}),[r,t]),state:a}},Ks=e=>{let t=Aa(),{initLoginWithPasskey:n,loginWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:i}=Ie();return{loginWithPasskey:h((async a=>{try{let i=await ka(t);await n({captchaToken:i,withPrivyUi:!1});let{user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginAccount:c}=await r(a);e?.onComplete?.({user:s,isNewUser:o,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(a){throw i({status:"error",error:a}),e?.onError?.(a.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),a}}),[r,t]),state:a}},$s=e=>{let{initLinkWithPasskey:t,linkWithPasskey:n,passkeyAuthState:r,setPasskeyAuthState:a}=Ie();return{linkWithPasskey:h((async()=>{try{await t();let r=await n();if(!r)throw Error("Error, user not found");let a=r.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:r,linkMethod:"passkey",linkedAccount:a})}catch(t){throw a({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[n]),state:r}},Gs=e=>{let t=Aa(),{smsOtpState:n,setSmsOtpState:r,initLoginWithSms:a,loginWithCode:i}=Ie();return{sendCode:h((async({phoneNumber:n,disableSignup:i})=>{try{if(!n)throw Error("SMS required to send OTP code");let e=await ka(t);return await a({phoneNumber:n,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a,t]),loginWithCode:h((async({code:t})=>{try{let{user:n,isNewUser:r,wasAlreadyAuthenticated:a,linkedAccount:s}=await i(t);e?.onComplete?.({user:n,isNewUser:r,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:s})}catch(t){throw r({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),t}}),[i]),state:n}},Ys=e=>{let{connectOrCreateWallet:t}=C();return Zn("connectOrCreateWallet",e),{connectOrCreateWallet:t}},Js=e=>{let t=Aa(),{siweState:n,setSiweState:r,linkWithSiwe:a,generateSiweMessage:i}=Ie();return{generateSiweMessage:h((async({address:t,chainId:n})=>{try{if(!t||!n)throw Error("wallet address and chainId required to generate nonce");return await i({address:t,chainId:n}).then((e=>e))}catch(t){throw r({status:"error",error:t}),e?.onError?.(t.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[i]),linkWithSiwe:h((async({signature:n,message:i,chainId:s,walletClientType:o,connectorType:l})=>{try{if(t.enabled&&"success"!==t.status)throw new fa(t.error,null,_e.CAPTCHA_FAILURE);let{user:r,linkedAccount:c}=await a({message:i,signature:n,chainId:s,walletClientType:o,connectorType:l});c&&e?.onSuccess?.({user:r,linkMethod:"siwe",linkedAccount:c})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),n}}),[a,t.status]),state:n}},Qs=e=>{let t=Aa(),{siweState:n,setSiweState:r,client:a,generateSiweMessage:i,loginWithSiwe:s}=Ie();return{generateSiweNonce:h((async n=>{try{let e=await ka(t);r({status:"generating-message"});let i=await a.generateSiweNonce({address:n?.address,captchaToken:e});return r({status:"awaiting-signature"}),i}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[a,t]),generateSiweMessage:h((async({address:n,chainId:a})=>{try{let e=await ka(t);return await i({address:n,chainId:a,captchaToken:e})}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[i,t]),loginWithSiwe:h((async({message:n,signature:a,disableSignup:i,walletClientType:o,connectorType:l})=>{try{let r=await ka(t),{user:c,isNewUser:d}=await s({message:n,signature:a,captchaToken:r,disableSignup:i,walletClientType:o,connectorType:l});return e?.onComplete?.({user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),c}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),n}}),[s,t]),state:n}},Zs=()=>{let e=Aa(),{client:t,setAuthenticated:n,setUser:r,setIsNewUser:a}=Ie(),{authenticated:i}=qn();return{generateSiwsMessage:h((async({address:n})=>{let r=await ka(e),a=await t.generateSiwsNonce({address:n,captchaToken:r});return Mn({address:n,nonce:a})}),[e,t]),loginWithSiws:h((async({message:e,signature:s,disableSignup:o,walletClientType:l,connectorType:c})=>{if(i)throw Error("User already authenticated");let{user:d,isNewUser:u}=await t.authenticateWithSiws({message:e,signature:s,walletClientType:l,connectorType:c,mode:o?"no-signup":"login-or-sign-up",messageType:"plain"});if(!d)throw Error("Authentication failed - no user returned");return r(d),a(u||!1),n(!0),d}),[i,t,n,r,a])}},Xs=()=>{let e=Aa(),{client:t,setUser:n,refreshSessionAndUser:r}=Ie(),{authenticated:a}=qn();return{generateSiwsMessage:h((async({address:n})=>{let r=await ka(e),a=await t.generateSiwsNonce({address:n,captchaToken:r});return Mn({address:n,nonce:a})}),[e,t]),linkWithSiws:h((async({signature:i,message:s,walletClientType:o,connectorType:l})=>{if(!a)throw Error("User must be authenticated before linking");await ka(e);let c=await t.linkWithSiws({message:s,signature:i,walletClientType:o,connectorType:l,messageType:"plain"}),d=(e=>{if(!e)return;let t=e.linkedAccounts;return t&&0!==t.length?t[t.length-1]:void 0})(c=await r()??c)||null;return n(c||null),{user:c,linkedAccount:d}}),[a,e,t,r,n])}};function eo(){let{signTransaction:e}=a(N);return{signTransaction:e}}function to(e){let{linkEmail:t,linkPhone:n,linkWallet:r,linkGoogle:i,linkApple:s,linkTwitter:o,linkTwitch:l,linkDiscord:c,linkGithub:d,linkLinkedIn:u,linkTiktok:h,linkLine:p,linkSpotify:w,linkInstagram:m,linkTelegram:y,linkFarcaster:g,linkPasskey:f}=a(N);return Zn("linkAccount",e),{linkEmail:t,linkPhone:n,linkWallet:r,linkGoogle:i,linkApple:s,linkTwitter:o,linkTwitch:l,linkDiscord:c,linkGithub:d,linkLinkedIn:u,linkTiktok:h,linkLine:p,linkSpotify:w,linkInstagram:m,linkFarcaster:g,linkTelegram:y,linkPasskey:f}}function no(e){let{updateEmail:t,updatePhone:n}=a(N);return Zn("update",e),{updateEmail:t,updatePhone:n}}const ro=e=>{let{user:t}=C(),{loginWithCode:n,emailOtpState:r,setEmailOtpState:a,client:i,inProgressAuthFlowRef:s,inProgressLoginOrLinkMethodRef:o}=Ie();return{state:r,sendCode:h((async({newEmailAddress:n})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");let e=new Qr(t.email.address,n);i.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(n){a({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email]),verifyCode:h((async({code:r})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");s.current="update",o.current="email";let{user:a,linkedAccount:i}=await n(r);return e?.onSuccess?.({user:a,updateMethod:"email",updatedAccount:i}),{user:a}}catch(r){a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email])}},ao=()=>{let{connectCoinbaseSmartWallet:e}=Ie();return{connectCoinbaseSmartWallet:e}},io=()=>{let{connectBaseAccount:e}=Ie();return{connectBaseAccount:e}},so=()=>{let{baseAccountSdk:e}=Ie();return{baseAccountSdk:e}},oo=()=>{let{setModalData:e}=_(),{openModal:t,privy:n,closePrivyModal:r}=Ie(),{user:a}=C();return l((()=>({verify:async({standalone:i=!0}={standalone:!0})=>new Promise(((s,o)=>a?0===a.mfaMethods.length?s():(e((e=>({...e,mfaVerify:{onSuccess:async()=>{i?await r({shouldCallAuthOnSuccess:!1,isSuccess:!0}):Ua.setState({inProgressMfaFlow:void 0}),s()},onFailure:async e=>{i?await r({shouldCallAuthOnSuccess:!1,isSuccess:!1}):Ua.setState({inProgressMfaFlow:void 0}),o(e)},sendSmsCode:async()=>{throw Error("Not enabled")},verifySmsCode:async()=>{throw Error("Not enabled")},verifyTotpCode:async e=>{await n.fetchPrivyRoute(br,{body:{code:e}})},generateOptions:async()=>Ts((await n.fetchPrivyRoute(_r,{body:{}})).options),verifyPasskey:async e=>{let t=await import("@simplewebauthn/browser"),r=await t.startAuthentication({optionsJSON:e});await n.fetchPrivyRoute(Cr,{body:{authenticator_response:zi(r)}})}}}))),void(i?t("MfaAuthVerifyFlowScreen"):Ua.setState({inProgressMfaFlow:"auth"}))):o(Error("Must be logged in to verify MFA"))))})),[n,e,t,r])},lo=()=>{let e=Xe(),{setModalData:t}=_(),{verify:n}=oo(),{openModal:r,privy:a,closePrivyModal:i,refreshSessionAndUser:s,setUser:o}=Ie();return l((()=>({enroll:async l=>new Promise(((c,d)=>{t({mfaEnroll:{onSuccess:async e=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!0}),c(e)},onFailure:async e=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}),d(e)},onBack:l?.onBack?async()=>{await i({shouldCallAuthOnSuccess:!1,isSuccess:!1}),d(Error("User canceled MFA enrollment flow.")),l.onBack?.()}:void 0,verify:()=>n({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:e.mfa.methods,sendSmsCode:async()=>{throw Error("Not enabled")},enrollSms:async()=>{throw Error("Not enabled")},unenrollSms:async()=>{throw Error("Not enabled")},generateTotpSecret:async()=>await a.fetchPrivyRoute(Pr,{body:{}}),enrollTotp:async e=>{await a.fetchPrivyRoute(Ir,{body:{code:e}});let t=await s();return o(t),t},unenrollTotp:async()=>{await a.fetchPrivyRoute(Er,{body:{}});let e=await s();return o(e),e},enrollPasskey:async e=>{await a.fetchPrivyRoute(Sr,{body:{credential_ids:e,remove_for_login:!0}});let t=await s();return o(t),t}}}),r("MfaAuthEnrollmentFlowScreen")}))})),[a,t,r,i])},co=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:n,signTypedDataWithCrossAppWallet:r,sendTransactionWithCrossAppWallet:a,signTransactionWithCrossAppWallet:i}=C();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:"login"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:"link"}),unlinkCrossAppAccount:t,signMessage:n,signTypedData:r,sendTransaction:a,signTransaction:i}};function uo(e){let{sendTransaction:t}=a(N);return Zn("sendTransaction",e),{sendTransaction:t}}function ho(){let e=Xe(),t=Xn(),{client:n,setUser:r,setAuthenticated:a,setIsNewUser:i,initializeWalletProxy:s}=Ie(),{create:o}=$n();return{createGuestAccount:async()=>{if(!e.id||!n)throw Error("SDK not yet ready");n.startAuthFlow(new Cs(e.id));try{let l=await n.authenticate(),c=l.user,d=l.isNewUser??!1;if(!c)throw new Te("Unable to authenticate guest account");let u=await n.getAccessToken(),h=await s(yt);if(u&&h)try{let t=Bi(c,e.embeddedWallets.ethereum.createOnLogin),n=$i(c,e.embeddedWallets.solana.createOnLogin);t&&n?(c=(await o({chainType:"ethereum",latestUser:c})).user,c=(await o({chainType:"solana",latestUser:c})).user):n?c=(await o({chainType:"solana",latestUser:c})).user:t?c=(await o({chainType:"ethereum",latestUser:c})).user:r(c)}catch(e){r(c),console.warn("Unable to create embedded wallet for guest account")}return i(d),a(!0),t("login","onComplete",{user:c,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),c}catch(e){throw t("login","onError",e.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),e}}}}function po(e){let{setWalletRecovery:t}=a(N);return Zn("setWalletRecovery",e),{setWalletRecovery:t}}function wo(e){let{signMessage:t}=a(N);return Zn("signMessage",e),{signMessage:t}}const mo=()=>{let{ready:e,wallets:t}=ge(),{user:n}=C(),{rpcConfig:r,chains:a,appId:i}=Ie();return{signAuthorization:h((async(s,o)=>{let l;if(!n)throw Error("User must be authenticated before signing with a Privy wallet");if(!e)throw Error("Wallets are not ready");let c=o?.address??I(n)?.address??pr,d=t.find((e=>wr(e.address)===wr(c)));if(!d)throw Error("Signing wallet not found.");let u=s.chainId??Number(d.chainId.split(":")[1]);if(0===u)l={chainId:0,address:s.contractAddress,nonce:s.nonce??0};else{let e=a.find((e=>e.id===u));if(!e)throw Error("Error, chain not configured in PrivyProvider config");let t=mr({account:c,chain:e,transport:yr(vr(e,r,i))});l=await t.prepareAuthorization({...s})}let h=await d.getEthereumProvider(),p=await h.request({method:"secp256k1_sign",params:[St(l)]});return{...l,...gr(p)}}),[e,t,n,a])}};function yo(e){let{signTypedData:t}=a(N);return Zn("signTypedData",e),{signTypedData:t}}const go=async({wallet:e})=>{let t=await e.getEthereumProvider();return Or({address:e.address,sign:async({hash:n})=>{if("privy"!==e.walletClientType)throw new y({error:"Unprefixed signing is not supported by external wallets.",code:"unsupported_wallet_type"});return await t.request({method:"secp256k1_sign",params:[n]})},signMessage:async({message:n})=>await t.request({method:"personal_sign",params:[n,e.address]}),signTypedData:async n=>await t.request({method:"eth_signTypedData_v4",params:[e.address,n]}),signTransaction:async e=>await t.request({method:"eth_signTransaction",params:[e]})})},fo=()=>{let{wallets:e}=ge();return l((()=>({wrapFetchWithPayment:({walletAddress:t,fetch:n,maxValue:r=BigInt(1e5),paymentRequirementsSelector:a=Wr,config:i})=>{let s=t||e[0]?.address;if(!s)throw new Nr("No wallet available for payment");let o=e.find((e=>D(e.address,s)));if(!o)throw new Nr(`Wallet ${s} not found in connected wallets`);return async(e,t)=>{let s=await n(e,t);if(402!==s.status)return s;if(t?.__is402Retry)throw Error("Payment already attempted for this request");let{x402Version:l,accepts:c}=await s.json(),d=a(c,void 0,"exact");if(BigInt(d.maxAmountRequired)>r)throw new Nr("Payment amount exceeds maximum allowed");let u=await go({wallet:o}),h=await Ur(u,l,d,i),p={...t,headers:{...t?.headers||{},"X-PAYMENT":h,"Access-Control-Expose-Headers":"X-PAYMENT-RESPONSE"},__is402Retry:!0};return await n(e,p)}}})),[e])},vo=()=>{let{isModalOpen:e}=a(N);return{isOpen:e}};function Ao(e){let{getAccessToken:t}=a(N);return Zn("accessToken",e),{getAccessToken:t}}function ko(e){let{authenticated:t,user:n}=C(),{initLoginWithOAuth:r}=Ie(),a=Xn();return Zn("oAuthAuthorization",e),{reauthorize:e=>To(t,n,r,a,e.provider)}}let To=async(e,t,n,r,a)=>{if(!e)throw r("linkAccount","onError",_e.MUST_BE_AUTHENTICATED,{linkMethod:a}),new Te("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(a))))throw new Te(`OAuth account of type ${a} not linked to the account.`);await n(a)};function Co(e){let{client:t}=Ie(),[n,r]=o({status:"initial"});return{linkWithCustomJwt:h((async n=>{try{r({status:"initial"}),t.startAuthFlow(new Vi(n)),r({status:"loading"});let{user:a}=await t.link();if(!a)throw Error("Error, user not found");let i=a.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return r({status:"done"}),e?.onSuccess?.({user:a,linkMethod:"custom",linkedAccount:i}),{user:a}}catch(n){throw r({status:"error",error:n}),e?.onError?.(n.privyErrorCode||_e.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),n}}),[t.startAuthFlow,t.link]),state:n}}const _o=e=>{let t=Qi((e=>e.jwtAuthFlowState));return Zn("customAuth",e),{status:t}};function bo({isAuthenticated:e,isLoading:t,...n}){let r=s();c((()=>{t||r.current?.()}),[e,t]);let a=h((e=>(r.current=e,()=>{r.current=void 0})),[]);return Ji({...n,subscribe:a})}function So(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:n}=C();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:n}}const Eo=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=Ie();return{delegateWallet:async({address:e,chainType:n})=>await t({address:e,chainType:n,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},Io=()=>{let{user:e}=C(),t=Ie(),{signWithUserSigner:n}=Rr(),r=async({wallet:r,additional_signers:a})=>{let i=await t.client.getAccessToken();if(!e||!i)throw new Te("User must be authenticated and have an embedded wallet to delegate actions.");if(!r.id)throw new Te("Wallet to add signers to must have ID on server");if(!t.walletProxy)throw new Te("Wallet proxy not initialized.");await f(t.privy,{wallet_id:r.id},n,{additional_signers:a})};return{addSessionSignersInternal:async({address:n,signers:a})=>{let i=await t.client.getAccessToken();if(!e||!i)throw new Te("User must be authenticated and have an embedded wallet to add a session signer.");let s=t.walletProxy??await t.initializeWalletProxy(15e3);if(!s)throw new Te("Wallet proxy not initialized.");let o=R(e,n);if(!o)throw new Te("Address to add signers too is not associated with current user.");if(E(o)){if(0===a.length)throw new Te("Must specify at least one signer to add.");let e=[...(await g(t.privy,{wallet_id:o.id})).additional_signers,...ye(a)];await r({wallet:o,additional_signers:e})}else{if(o.delegated)return{user:e};if(a.length>0)throw new Te("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let r=fi({address:n,user:e}),l=vi({address:n,user:e});await t.recoverEmbeddedWallet({address:n}),await s.createDelegatedAction({accessToken:i,rootWallet:l,delegatedWallets:[r]})}let l=await t.refreshSessionAndUser();if(!l)throw Error("Could not refresh user");return{user:l}},removeSessionSignersInternal:async({address:n})=>{let a=await t.client.getAccessToken();if(!e||!a)throw new Te("User must be authenticated and have an embedded wallet to delegate actions.");if(!(t.walletProxy??await t.initializeWalletProxy(15e3)))throw new Te("Wallet proxy not initialized.");let i=R(e,n);if(!i)throw new Te("Address to remove signers from is not associated with current user.");E(i)?await r({wallet:i,additional_signers:[]}):await t.client.revokeDelegatedWallet();let s=await t.refreshSessionAndUser();if(!s)throw Error("Could not refresh user");return{user:s}}}},Po=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=Io();return{addSessionSigners:async({address:t,signers:n})=>e({address:t,signers:n}),removeSessionSigners:async({address:e})=>t({address:e})}},Wo=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=Io();return{addSigners:async({address:t,signers:n})=>e({address:t,signers:n}),removeSigners:async({address:e})=>t({address:e})}},Uo=()=>{let{signWithUserSigner:e}=Rr();return l((()=>({async generateAuthorizationSignature(t){let{targetAppId:n,...r}=t,{signature:a}=await v((async({message:t})=>e({message:t,targetAppId:n})),r);return{signature:a}}})),[e])},No=()=>{let{setUser:e,client:t}=a(We),{user:n}=a(N);return{user:n,refreshUser:h((async()=>{let n=await(t?.updateUserAndIdToken());return e(n??null),n}),[t,e])}},Oo=e=>{let t=Aa(),{initLoginWithTelegram:n,loginWithTelegram:r,telegramAuthState:a,setTelegramAuthState:i}=Ie();return{login:h((async a=>{try{if(t.enabled&&"success"!==t.status)throw new fa(t.error,null,_e.CAPTCHA_FAILURE);await n(t.token,a?.disableSignup);let{user:i,isNewUser:s,loginAccount:o,wasAlreadyAuthenticated:l}=await r({intent:"login"});e?.onComplete?.({user:i,isNewUser:s,wasAlreadyAuthenticated:l,loginMethod:"telegram",loginAccount:o})}catch(a){throw i({status:"error",error:a}),e?.onError?.(a.privyErrorCode||_e.UNKNOWN_AUTH_ERROR),a}}),[n,r,t]),state:a}},Ro=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=Ie();return{delegateWallet:async({address:e,chainType:n})=>await t({address:e,chainType:n,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},Mo=Ka;export{Gs as $,Ri as A,cs as B,fa as C,Dr as D,Lr as E,Pi as F,ds as G,Fr as H,xs as I,Ia as J,gs as K,Fs as L,Ns as M,Ms as N,js as O,ei as P,zs as Q,Zr as R,wa as S,vs as T,qs as U,Hs as V,Za as W,Vs as X,Bs as Y,Ks as Z,$s as _,Aa as a,Ys as a0,Js as a1,Qs as a2,Zs as a3,Xs as a4,eo as a5,Wa as a6,to as a7,no as a8,ro as a9,Oo as aA,Ro as aB,Mo as aC,Ka as aD,go as aE,Li as aF,ao as aa,io as ab,so as ac,oo as ad,lo as ae,co as af,uo as ag,ho as ah,po as ai,wo as aj,mo as ak,yo as al,fo as am,vo as an,Ao as ao,ko as ap,Co as aq,_o as ar,Ji as as,bo as at,So as au,Eo as av,Po as aw,Wo as ax,Uo as ay,No as az,pa as b,Wi as c,Ls as d,ni as e,oi as f,ii as g,ai as h,li as i,si as j,$i as k,da as l,Ca as m,ri as n,ia as o,Di as p,sa as q,oa as r,Bi as s,Fi as t,Ds as u,Yi as v,Ii as w,Mi as x,Ni as y,Br as z};
