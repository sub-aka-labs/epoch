import{jsxs as e,Fragment as t,jsx as a}from"react/jsx-runtime";import r from"@heroicons/react/24/outline/CheckCircleIcon";import{useState as i,useEffect as n}from"react";import{parseEther as o,createWalletClient as s,custom as d,publicActions as c,createPublicClient as l,http as m,encodeFunctionData as u,formatUnits as p}from"viem";import{addToDefaultChains as h}from"@privy-io/js-sdk-core";import{b as f,c as g,R as v}from"./Layouts-BlFm53ED.mjs";import{B as y}from"./ModalHeader-rCMpqA2a.mjs";import{C}from"./ScreenHeader-CHmc4-Lu.mjs";import{t as I}from"./FundWalletMethodHeader-PIxwFzzh.mjs";import{N as j}from"./index-Dq_xe9dz.mjs";import{u as w,t as T}from"./context-LVpDfP2H.mjs";import{u as b,a as E,b as S}from"./internal-context-Z-fyxadS.mjs";import{Q as N,D as A}from"./useActiveWallet-RZ4w-uGq.mjs";import{a as k}from"./get-is-unified-wallet-CNcx75Dp.mjs";import{u as x}from"./useGetTokenPrice-DERdsrmf.mjs";import{u as B}from"./useWallets-DlGuNtGR.mjs";import{E as F,a as M}from"./transfer-6YztDh-t.mjs";import{f as P}from"./formatErc20TokenAmount-BuPk9xcy.mjs";import{c as U,a as W,g as L,s as H}from"./ethers-BQ45eiVv.mjs";import{O as $}from"./analytics-mkkvFRju.mjs";import{t as q,g as D,c as R,u as _}from"./reservoir-0wfhnc0j.mjs";import{y as Q}from"./index-DNz_w3-G.mjs";import{g as O,B as V}from"./BridgeNetworkSelectionView-DQGcampg.mjs";import{g as G}from"./getErc20Balance-DA4dGV9O.mjs";import{a as z}from"./getPublicClient-B4uPLKn-.mjs";import{T as J}from"./TransferOrBridgeLoadingScreen-VLQTcf_6.mjs";import"styled-components";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/QuestionMarkCircleIcon";import"@heroicons/react/24/outline/XMarkIcon";import"tinycolor2";import"ofetch";import"zustand";import"react-device-detect";import"./prepareFundingModalData-DjTxAoJ1.mjs";import"eventemitter3";import"./events-context-CI0iqAXA.mjs";import"viem/utils";import"./useGetSolPrice-DwwjjGbd.mjs";import"uuid";import"jose";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"mipd";import"@privy-io/popup";import"./paths-3HW55qZg.mjs";import"./usePrivy-Dj52a5sp.mjs";import"@scure/base";import"@headlessui/react";import"@walletconnect/ethereum-provider";import"@privy-io/urls";import"js-cookie";import"./frame-uzTmvtww.mjs";import"@privy-io/routes";import"x402/client";import"@privy-io/api-base";import"viem/accounts";import"./use-sign-with-user-signer-Do5Oi_rb.mjs";import"./getEmbeddedConnectedWallet-CM6cDQCS.mjs";import"./Row-C9vrS4Zi.mjs";import"./ErrorMessage-D8VaAP5m.mjs";import"./Value-tcJV9e0L.mjs";import"./LoadingSkeleton-U6-3yFwI.mjs";import"./Subtitle-CV-2yKE4.mjs";import"./Title-BnzYV3Is.mjs";import"@heroicons/react/24/outline/WalletIcon";import"./getChainName-DjpPdUSc.mjs";import"./Chip-D2-wZOHJ.mjs";import"./NetworkIcon-B48ilzF8.mjs";import"@heroicons/react/24/outline/GlobeAltIcon";import"./shared-FM0rljBt.mjs";import"@heroicons/react/24/outline/ChevronDownIcon";import"./styles-BNn7MnP1.mjs";import"./LinkPasskeyScreen-DYfWSjKR.mjs";import"lucide-react";import"./TodoList-CgrU7uwu.mjs";import"./ScreenLayout-DF3DCKOK.mjs";import"./Screen-CV2tt2Ap.mjs";import"./InjectedWalletIcon-DLcYOGDj.mjs";import"./Address-QmAVCQtO.mjs";const X={component:()=>{let{rpcConfig:X,appId:Y,closePrivyModal:Z,createAnalyticsEvent:K}=b(),{navigate:ee,setModalData:te,data:ae}=k(),re=w(),{wallets:ie}=B(),[ne,oe]=i(!1),[se,de]=i(0n),[ce,le]=i(!1),[me,ue]=i(null),[pe,he]=i(null),[fe,ge]=i([]),[ve,ye]=i(0),[Ce,Ie]=i(!1),[je,we]=i(!1),[Te,be]=i(!1),[Ee,Se]=i(!1),[Ne,Ae]=i(),[ke,xe]=i();if(!ae?.funding||"ethereum"!==ae.funding.chainType)throw Error("Invalid funding data");let{erc20ContractInfo:Be,chain:Fe,connectedWallet:Me}=ae.funding,Pe=ae.funding.address,Ue=ae.funding.erc20Address,[We,Le]=i(ae.funding.amount);n((()=>{Ue&&!Be&&ue(Error("Unable to fetch token details"))}),[]);let He=!!Ue&&!!Be,$e=He?BigInt(parseFloat(We)*10**Be.decimals):o(We),qe=("ethereum"===Me?.type?Me:void 0)??ie[0],De=N(qe?.walletClientType||"unknown"),Re=De?.name||"wallet",[_e,Qe]=i(null);n((()=>{(async()=>{if(!qe)return;let e=await qe.getEthereumProvider();Qe(s({account:qe.address,transport:d(e)}).extend(c))})().catch(console.error)}),[qe]);let[Oe,Ve]=i(0n);n((()=>{l({chain:Fe,transport:m(z(Fe,X,Y))}).getBalance({address:Pe}).then(Ve).catch(console.error)}),[]);let[Ge,ze]=i(0n);n((()=>{He&&G({chain:Fe,address:Pe,appId:Y,rpcConfig:X,erc20Address:Ue}).then((e=>ze(e.balance))).catch(console.error)}),[]);let{tokenPrice:Je}=x(Fe.id),[Xe,Ye]=i({to:Pe,chain:Fe,value:$e,data:void 0});n((()=>{(async()=>{let e,t;if(!_e||!qe||Ce||Te)return;Ie(!0);let a=l({chain:Xe.chain,transport:m(z(Xe.chain,X,Y))});if(He&&!Xe.data)return await a.simulateContract({address:Ue,chain:Xe.chain,abi:F,functionName:"transfer",args:[Pe,$e],account:qe.address}).catch((e=>{if("ContractFunctionZeroDataError"===e?.cause?.name||e?.message?.includes("returned no data"))return a.simulateContract({address:Ue,chain:Xe.chain,abi:M,functionName:"transfer",args:[Pe,$e],account:qe.address}).catch((e=>{console.warn("Simulated token transfer failed with error, fetching bridge options.",e)}));console.warn("Simulated token transfer failed with error, fetching bridge options.",e)}))?(Ie(!1),void Ye({to:Ue,chain:Xe.chain,data:u({abi:F,functionName:"transfer",args:[Pe,$e]}),value:"0x0"})):(Ie(!1),void le(!0));try{e=await a.prepareTransactionRequest({account:qe.address,to:Xe.to,chain:Xe.chain,data:Xe.data,value:BigInt(Xe.value??0)})}catch(e){if(console.error(e),fe.length>1)he(e.shortMessage??"Something went wrong");else if(je&&0===fe.length)return void ue(new E(`Wallet ${A(qe.address)} does not have enough funds.`,void 0,S.INSUFFICIENT_BALANCE))}if(!e)return Ie(!1),void le(!0);Ie(!1),be(!0),oe(!0),de(e.gas);try{await _e.switchChain({id:Xe.chain.id})}catch(e){await _e.addChain({chain:Xe.chain}),await _e.switchChain({id:Xe.chain.id})}try{t=await _e.sendTransaction(e)}catch(e){if(console.error(e),"TransactionExecutionError"===e.name)if(fe.length<1){let t=e.shortMessage;(e.shortMessage.includes("rejected the request")||e.details.includes("rejected the request"))&&(t="User rejected the request."),ue(new E(t,void 0,S.TRANSACTION_FAILURE))}else he(e.shortMessage??"Something went wrong")}if(t)return await _e.waitForTransactionReceipt({hash:t}),be(!1),je?(Ae(t),void xe("pending")):(Se(!0),te(Q(ae,"completed",t,qe?.walletClientType,He,Be,Fe)),void K({eventName:$,payload:{provider:"external",status:"success",txHash:t,address:qe.address,chainId:Xe.chain.id,chainType:"ethereum",value:Xe.value?p(BigInt(Xe.value),Be?.decimals??18):void 0,token:Be?.symbol??Ue??"ETH",destinationAddress:Pe,destinationChainId:Fe.id,destinationChainType:"ethereum",destinationValue:$e?p($e,Be?.decimals??18):void 0,destinationToken:Be?.symbol??Ue??Fe.nativeCurrency.name}}));be(!1)})().catch(console.error)}),[_e,Xe]),n((()=>{(async()=>{if(!ce||!_e||!qe)return;let e=h(re.chains).filter((e=>e.id!==Fe.id&&!!e.testnet==!!Fe.testnet));He&&e.unshift(Fe);let t=await O({chains:e,address:qe.address,appId:Y,rpcConfig:X,includeUsdc:ae.funding?.isUSDC}),a=He?t.filter((e=>e.balance>0n)):t.filter((e=>e.balance>$e)),r=He&&t.every((e=>0n===e.balance));if(a.length<1)return void ue(new E(r?`Wallet ${A(qe.address)} doesn't have enough funds to cover gas fees. Top up your wallet and try again.`:`Wallet ${A(qe.address)} does not have enough funds.`,void 0,S.INSUFFICIENT_BALANCE));a.sort(((e,t)=>Number(He?(t.erc20Balance??0n)-(e.erc20Balance??0n):t.balance-e.balance)));let i=a.flatMap((e=>{let t=[{...e,isErc20Quote:!1,isTestnet:!!Fe.testnet,input:q({appId:Y,amount:$e.toString(),user:qe.address,recipient:Pe,destinationChainId:Fe.id,destinationCurrency:Ue,originChainId:e.chain.id})}];return He&&Ue&&(e.erc20Balance??0n)>=$e&&t.push({...e,isErc20Quote:!0,isTestnet:!!Fe.testnet,input:q({appId:Y,amount:$e.toString(),user:qe.address,recipient:Pe,destinationChainId:Fe.id,destinationCurrency:Ue,originChainId:e.chain.id,originCurrency:e.erc20Address})}),t})),n=(await Promise.allSettled(i.map((async e=>({...e,quote:await D(e)}))))).filter((e=>"fulfilled"===e.status)).map((e=>e.value));if(n.length<1)return void ue(new E(`Wallet ${A(qe.address)} does not have enough funds.`,void 0,S.INSUFFICIENT_BALANCE));let o=n.map((e=>({bridgeTx:R(e.quote),balance:e.balance,chain:e.chain,erc20Balance:e.erc20Balance,isErc20Quote:e.isErc20Quote}))).filter((e=>!!e.bridgeTx));if(o.length>1)return void ge(o);let s=o[0];s?(we(!0),Ye({data:s.bridgeTx.data,to:s.bridgeTx.to,value:s.bridgeTx.value,chain:s.chain})):ue(new E(`Wallet ${A(qe.address)} does not have enough funds.`,void 0,S.INSUFFICIENT_BALANCE))})().catch(console.error)}),[ce]),_({transactionHash:Ne,isTestnet:!!Fe.testnet,bridgingStatus:ke,setBridgingStatus:xe,onSuccess({transactionHash:e}){we(!1),Se(!0),te(Q(ae,"completed",e,qe?.walletClientType,He,Be,Fe)),K({eventName:$,payload:{provider:"external",status:"success",txHash:e,address:qe?.address,chainId:Xe.chain.id,chainType:"ethereum",value:Xe.value?p(BigInt(Xe.value),Be?.decimals??18):void 0,token:Be?.symbol??Ue??"ETH",destinationAddress:Pe,destinationChainId:Fe.id,destinationChainType:"ethereum",destinationValue:$e?p($e,Be?.decimals??18):void 0,destinationToken:Be?.symbol??Ue??Fe.nativeCurrency.name}})},onFailure({error:e}){we(!1),ue(e)}}),n((()=>{me&&(te({funding:ae?.funding,solanaFundingData:ae?.solanaFundingData,sendTransaction:ae?.sendTransaction,errorModalData:{error:me,previousScreen:"TransferFromWalletScreen"}}),ee("ErrorScreen",!1))}),[me]);let Ze=!He&&Je?U(We??"0",Je):void 0,Ke=He?se:H([se,$e]),et=Ke&&Je?W(Ke,Je):void 0,tt=Ke?L(Ke,ae?.funding?.erc20Address?ae?.funding?.erc20ContractInfo?.symbol||"ETH":ae?.funding?.chain.nativeCurrency.symbol||"ETH"):void 0,at=se&&Je?W(se,Je):void 0,rt=se?L(se,Fe?.nativeCurrency?.symbol||"ETH"):void 0;if(n((()=>{if(!Ee)return;let e=setTimeout(Z,T);return()=>clearTimeout(e)}),[Ee]),Ee/*#__PURE__*/)return e(t,{children:[/*#__PURE__*/a(I,{}),/*#__PURE__*/a(f,{}),/*#__PURE__*/e(g,{children:[/*#__PURE__*/a(r,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),/*#__PURE__*/a(C,{title:"Success!",description:`Youâ€™ve successfully added ${We} ${He?Be.symbol:Fe.nativeCurrency.symbol} to your ${re.name} wallet. It may take a minute before the funds are available to use.`})]}),/*#__PURE__*/a(v,{}),/*#__PURE__*/a(y,{})]});let it=He?`${P({amount:Ge,decimals:Be.decimals})}  ${Be.symbol}`:L(Oe,Fe.nativeCurrency.symbol,3,!0),nt=fe[ve];return fe.length>1&&nt?/*#__PURE__*/a(V,{displayName:Re,configuredFundingChain:Fe,erc20ContractInfo:Be,formattedBalance:it,fundingAmount:We,fundingCurrency:He?Be.symbol:Fe.nativeCurrency.symbol,fundingAmountInUsd:Ze,options:fe,selectedOption:nt,isPreparing:Ce,isSubmitting:Te,addressToFund:Pe,fundingWalletAddress:qe?.address||"",errorMessage:pe,onSubmit:()=>{ae.funding?.amount!==We?async function(){if(qe&&nt)try{let e=await D({isTestnet:!!Fe.testnet,input:q({appId:Y,amount:$e.toString(),user:qe.address,recipient:Pe,destinationChainId:Fe.id,destinationCurrency:Ue,originChainId:nt.chain.id})}),t=R(e);if(!t)throw Error("Invalid transaction request");we(!0),Ye({data:t.data,to:t.to,value:t.value,chain:nt.chain})}catch(e){console.error(e),ue(new E("Unable to fetch quotes for bridging",e,S.INSUFFICIENT_BALANCE))}}().catch(console.error):Ye({to:nt.bridgeTx.to,data:nt.bridgeTx.data,value:nt.bridgeTx.value,chain:nt.chain})},onSelect:e=>{e!==ve&&(he(null),ye(e))},onAmountChange:Le}):ne&&se&&qe&&ae?.funding?/*#__PURE__*/a(J,{walletClientType:qe?.walletClientType||"unknown",displayName:Re,addressToFund:Pe,isBridging:je,isErc20Flow:He,totalPriceInUsd:et,totalPriceInNativeCurrency:tt,gasPriceInUsd:at,gasPriceInNativeCurrency:rt,chainId:Fe.id,chainName:Fe.name}):
/*#__PURE__*/e(t,{children:[/*#__PURE__*/a(I,{}),/*#__PURE__*/a(j,{}),/*#__PURE__*/a("div",{style:{marginTop:"1rem"}}),/*#__PURE__*/a(y,{})]})}};export{X as AwaitingExternalEthereumTransferScreen,X as default};
