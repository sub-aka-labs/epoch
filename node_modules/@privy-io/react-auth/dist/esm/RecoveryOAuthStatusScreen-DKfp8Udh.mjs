import{jsxs as e,Fragment as t,jsx as r}from"react/jsx-runtime";import{useState as o,useEffect as a,useCallback as i}from"react";import{M as c,P as s,B as l}from"./ModalHeader-rCMpqA2a.mjs";import{C as n}from"./ScreenHeader-CHmc4-Lu.mjs";import{q as d}from"./context-LVpDfP2H.mjs";import{o as p,q as u,r as m,v as h,R as v,l as w}from"./index-DNz_w3-G.mjs";import{a as y,f,b as _,u as A}from"./internal-context-Z-fyxadS.mjs";import{a as E,u as g,g as C}from"./get-is-unified-wallet-CNcx75Dp.mjs";import{a8 as b,a9 as R,aa as k}from"./paths-3HW55qZg.mjs";import{g as T}from"./useWallets-DlGuNtGR.mjs";import{a as O}from"./events-context-CI0iqAXA.mjs";import{A as N,G as S,R as I}from"./styles-BsotlekN.mjs";import"styled-components";import"./useActiveWallet-RZ4w-uGq.mjs";import"zustand";import"react-device-detect";import"./prepareFundingModalData-DjTxAoJ1.mjs";import"@privy-io/js-sdk-core";import"eventemitter3";import"viem";import"viem/utils";import"./getPublicClient-B4uPLKn-.mjs";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/QuestionMarkCircleIcon";import"@heroicons/react/24/outline/XMarkIcon";import"tinycolor2";import"uuid";import"jose";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"mipd";import"@privy-io/popup";import"./usePrivy-Dj52a5sp.mjs";import"@scure/base";import"@headlessui/react";import"@walletconnect/ethereum-provider";import"@privy-io/urls";import"ofetch";import"js-cookie";import"./frame-uzTmvtww.mjs";import"@privy-io/routes";import"x402/client";import"@privy-io/api-base";import"viem/accounts";import"./use-sign-with-user-signer-Do5Oi_rb.mjs";import"./getEmbeddedConnectedWallet-CM6cDQCS.mjs";async function M({url:e,popup:t,provider:r}){return t.location=e,new Promise(((e,r)=>{function o(){t?.close(),window.removeEventListener("message",a)}function a(t){t.data&&("PRIVY_OAUTH_RESPONSE"===t.data.type&&t.data.stateCode&&t.data.authorizationCode&&(e(t.data),o()),"https://cdn.apple-cloudkit.com"===t.origin&&t.data.ckSession&&(e({type:"PRIVY_OAUTH_RESPONSE",ckWebAuthToken:t.data.ckSession}),o()),"PRIVY_OAUTH_ERROR"===t.data.type&&(r(t.data.error),o()))}window.addEventListener("message",a)}))}async function x({api:e,provider:t,stateCode:r,codeVerifier:o,authorizationCode:a}){if(!a||!r)throw new y("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if("undefined"===a)throw new y("User denied confirmation during OAuth flow");try{return(await e.post(b,{authorization_code:a,state_code:r,code_verifier:o,provider:t})).access_token}catch(e){let t=f(e);if(t.privyErrorCode)throw new y(t.message||"Invalid code during OAuth flow.",void 0,t.privyErrorCode);if("User denied confirmation during OAuth flow"===t.message)throw new y("Invalid code during oauth flow.",void 0,_.OAUTH_USER_DENIED);throw new y("Invalid code during OAuth flow.",void 0,_.UNKNOWN_AUTH_ERROR)}}async function U({api:e,provider:t}){let r=p(),o=u(),a=await m(r);try{return"icloud"===t?{url:(await e.post(R,{client_type:"web"})).url}:{url:(await e.post(k,{redirect_to:window.location.href,code_challenge:a,state_code:o})).url,codeVerifier:r,stateCode:o,provider:t}}catch(e){throw f(e)}}let j={"google-drive":{name:"Google Drive",component:S},icloud:{name:"iCloud",component:N}};const W={component:()=>{let{logout:p}=g(),{navigate:u,setModalData:m,data:f}=E(),{closePrivyModal:b,createAnalyticsEvent:R}=A(),{execute:k}=(()=>{let{client:e,walletProxy:t,refreshSessionAndUser:r}=A(),{data:o}=E(),{user:a}=g(),i=O(),{create:c}=h();return{execute:async({provider:s,action:l,popup:n,shouldCreateEth:d,shouldCreateSol:p})=>{let u,m;if(!e)throw new y("Missing client");function h(t){if(!t&&e)throw e.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:s}}),new y("Recovery OAuth failed")}switch(s){case"google-drive":{let t,r,{url:o,codeVerifier:a,stateCode:i}=await U({api:e.api,provider:s});h(o);try{let a=await M({url:o,popup:n,provider:s});if(t=a.stateCode,r=a.authorizationCode,t!==i)throw e.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:s,storedStateCode:i??"",returnedStateCode:t??""}}),new y("Unexpected auth flow. This may be a phishing attempt.",void 0,_.OAUTH_UNEXPECTED)}catch(t){throw e.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:t.toString(),provider:s}}),new y("Recovery OAuth failed")}[u,m]=await Promise.all([e.getAccessToken(),x({api:e.api,provider:s,codeVerifier:a,stateCode:t,authorizationCode:r})]);break}case"icloud":{let{url:t}=await U({api:e.api,provider:s});h(t);let{ckWebAuthToken:r}=await M({url:t,popup:n,provider:s});m=r,u=await e.getAccessToken()}}if(!t)throw new y("Cannot connect to wallet proxy");if(!u)throw new y("Unable to authorize user");switch(l){case"recover":{let r=o?.recoverWallet?.entropyId,a=o?.recoverWallet?.entropyIdVerifier;if(!r||!a)throw new y("Recovery OAuth failed");e.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:r,recoveryMethod:s}}),await t.recover({accessToken:u,entropyId:r,entropyIdVerifier:a,recoveryAccessToken:m}),e.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:r,recoveryMethod:s}});break}case"create-wallet":{let t;if(e.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),d&&p)t=await c({recoveryMethod:s,recoveryAccessToken:m,chainType:"ethereum",walletIndex:0,latestUser:a}),t=await c({chainType:"solana",walletIndex:0,latestUser:t.user});else if(p)t=await c({recoveryMethod:s,recoveryAccessToken:m,chainType:"solana",walletIndex:0,latestUser:a});else{if(!d)throw Error("Invalid args to create wallet");t=await c({recoveryMethod:s,recoveryAccessToken:m,chainType:"ethereum",walletIndex:0,latestUser:a})}if(!t)throw i("createWallet","onError",_.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");e.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:t.account.address}}),i("createWallet","onSuccess",{wallet:t.account});break}case"set-recovery":{let o=C(a);if(!o)throw i("setWalletRecovery","onError",_.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");e.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:o.address,existingRecoveryMethod:o.recoveryMethod,targetRecoveryMethod:s}});let{entropyId:c,entropyIdVerifier:l}=T(a);await t.setRecovery({accessToken:u,entropyId:c,entropyIdVerifier:l,recoveryMethod:s,recoveryAccessToken:m});let n=C(await r());if(!n)throw i("createWallet","onError",_.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");e.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:o.address,existingRecoveryMethod:o.recoveryMethod,targetRecoveryMethod:s}}),i("setWalletRecovery","onSuccess",{method:s,wallet:n});break}default:throw new y("Unsupported recovery action")}}}})(),[N,S]=o(!1),{provider:W,action:D,isInAccountCreateFlow:P,shouldCreateEth:V,shouldCreateSol:L}=f?.recoveryOAuthStatus,[z,H]=o(void 0),[$,F]=o("create-wallet"===D);if("user-passcode"===W)throw Error("RecoveryOAuthScreen should never be called with a wallet that specifies recoveryMethod: `user-passcode`");let B=j[W].name,G=j[W].component,K=f?.recoverWallet?.onCompleteNavigateTo,Y=new v((async(e="create-wallet")=>(F(!0),new Promise(((t,r)=>{setTimeout((async()=>{try{let r=window.open();await k({provider:W,action:e,popup:r,shouldCreateEth:V,shouldCreateSol:L}),S(!0),t()}catch(t){H({message:`${"recover"===e?"Recovery":"Back up"} with ${B} unsuccessful`,detail:"recover"===D?`Please verify that you are selecting the ${B} account associated with your backup.`:"",retryable:!0}),r()}}),0)})))));a((()=>{"recover"!==D&&Y.execute(P?"create-wallet":"set-recovery")}),[]),a((()=>{if(!N)return;let e=setTimeout((()=>{P?(m({createWallet:{onSuccess:()=>{},onFailure:e=>{R({eventName:"embedded_wallet_creation_failure_logout",payload:{error:e,screen:"RecoveryOAuthScreen"}}),p()},callAuthOnSuccessOnClose:!0,shouldCreateEth:!1,shouldCreateSol:!1}}),u("EmbeddedWalletCreatedScreen")):b({shouldCallAuthOnSuccess:!1})}),d);return()=>clearTimeout(e)}),[N]);let q=i((async()=>{await Y.execute("recover"),K?u(K):S(!0)}),[]),X="google-drive"===W?"Google Drive":"Apple iCloud",Q=N&&`Successfully ${"recover"===D?"recovered":"backed up"} with ${X}.`||z&&z.message||`${"recover"===D?"Recovering":"Backing up"} with ${X}...`,J=z?z.detail:"";/*#__PURE__*/return e(t,{children:[/*#__PURE__*/r(c,{}),$?/*#__PURE__*/r(t,{children:/*#__PURE__*/e(I,{children:[/*#__PURE__*/r(n,{title:Q,icon:/*#__PURE__*/r(G,{style:{width:"38px",height:"38px"}}),description:J}),z&&z?.retryable?/*#__PURE__*/r(s,{onClick:()=>{w(),H(void 0),"create-wallet"===D?Y.execute("create-wallet"):q()},disabled:!N&&!z?.retryable,children:"Try again"}):null]})}):/*#__PURE__*/e(I,{children:[/*#__PURE__*/r(n,{title:"Confirm it's really you",icon:/*#__PURE__*/r(G,{style:{height:42,width:48}}),description:`To confirm your identity, please log in to ${X} where your account is backed up.`}),/*#__PURE__*/e(s,{onClick:q,children:["Confirm with ",X]})]}),/*#__PURE__*/r(l,{})]})}};export{W as RecoveryOAuthScreen,W as default};
