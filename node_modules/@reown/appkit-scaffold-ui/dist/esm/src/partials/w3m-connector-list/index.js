var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { LitElement, html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { ConstantsUtil as CommonConstantsUtil } from '@reown/appkit-common';
import { ApiController, AssetController, AssetUtil, ConnectionController, ConnectorController, CoreHelperUtil, RouterController } from '@reown/appkit-controllers';
import { customElement } from '@reown/appkit-ui';
import '@reown/appkit-ui/wui-flex';
import { HelpersUtil } from '@reown/appkit-utils';
import { ConnectorUtil } from '../../utils/ConnectorUtil.js';
import styles from './styles.js';
let W3mConnectorList = class W3mConnectorList extends LitElement {
    constructor() {
        super();
        this.unsubscribe = [];
        this.connectors = ConnectorController.state.connectors;
        this.recommended = ApiController.state.recommended;
        this.featured = ApiController.state.featured;
        this.explorerWallets = ApiController.state.explorerWallets;
        this.connections = ConnectionController.state.connections;
        this.connectorImages = AssetController.state.connectorImages;
        this.loadingTelegram = false;
        this.unsubscribe.push(ConnectorController.subscribeKey('connectors', val => (this.connectors = val)), ConnectionController.subscribeKey('connections', val => (this.connections = val)), AssetController.subscribeKey('connectorImages', val => (this.connectorImages = val)), ApiController.subscribeKey('recommended', val => (this.recommended = val)), ApiController.subscribeKey('featured', val => (this.featured = val)), ApiController.subscribeKey('explorerFilteredWallets', val => {
            this.explorerWallets = val?.length ? val : ApiController.state.explorerWallets;
        }), ApiController.subscribeKey('explorerWallets', val => {
            if (!this.explorerWallets?.length) {
                this.explorerWallets = val;
            }
        }));
        if (CoreHelperUtil.isTelegram() && CoreHelperUtil.isIos()) {
            this.loadingTelegram = !ConnectionController.state.wcUri;
            this.unsubscribe.push(ConnectionController.subscribeKey('wcUri', val => (this.loadingTelegram = !val)));
        }
    }
    disconnectedCallback() {
        this.unsubscribe.forEach(unsubscribe => unsubscribe());
    }
    render() {
        return html `
      <wui-flex flexDirection="column" gap="2"> ${this.connectorListTemplate()} </wui-flex>
    `;
    }
    mapConnectorsToExplorerWallets(connectors, explorerWallets) {
        return connectors.map(connector => {
            if (connector.type === 'MULTI_CHAIN' && connector.connectors) {
                const connectorIds = connector.connectors.map(c => c.id);
                const connectorNames = connector.connectors.map(c => c.name);
                const connectorRdns = connector.connectors.map(c => c.info?.rdns);
                const explorerWallet = explorerWallets?.find(wallet => connectorIds.includes(wallet.id) ||
                    connectorNames.includes(wallet.name) ||
                    (wallet.rdns &&
                        (connectorRdns.includes(wallet.rdns) || connectorIds.includes(wallet.rdns))));
                connector.explorerWallet = explorerWallet ?? connector.explorerWallet;
                return connector;
            }
            const explorerWallet = explorerWallets?.find(wallet => wallet.id === connector.id ||
                wallet.rdns === connector.info?.rdns ||
                wallet.name === connector.name);
            connector.explorerWallet = explorerWallet ?? connector.explorerWallet;
            return connector;
        });
    }
    processConnectorsByType(connectors, shouldFilter = true) {
        const sorted = ConnectorUtil.sortConnectorsByExplorerWallet([...connectors]);
        return shouldFilter ? sorted.filter(ConnectorUtil.showConnector) : sorted;
    }
    connectorListTemplate() {
        const mappedConnectors = this.mapConnectorsToExplorerWallets(this.connectors, this.explorerWallets ?? []);
        const byType = ConnectorUtil.getConnectorsByType(mappedConnectors, this.recommended, this.featured);
        const announced = this.processConnectorsByType(byType.announced.filter(c => c.id !== 'walletConnect'));
        const injected = this.processConnectorsByType(byType.injected);
        const multiChain = this.processConnectorsByType(byType.multiChain.filter(c => c.name !== 'WalletConnect'), false);
        const custom = byType.custom;
        const recent = byType.recent;
        const external = this.processConnectorsByType(byType.external.filter(c => c.id !== CommonConstantsUtil.CONNECTOR_ID.COINBASE_SDK));
        const recommended = byType.recommended;
        const featured = byType.featured;
        const connectorTypeOrder = ConnectorUtil.getConnectorTypeOrder({
            custom,
            recent,
            announced,
            injected,
            multiChain,
            recommended,
            featured,
            external
        });
        const wcConnector = this.connectors.find(c => c.id === 'walletConnect');
        const isMobile = CoreHelperUtil.isMobile();
        const items = [];
        for (const type of connectorTypeOrder) {
            switch (type) {
                case 'walletConnect': {
                    if (!isMobile && wcConnector) {
                        items.push({ kind: 'connector', subtype: 'walletConnect', connector: wcConnector });
                    }
                    break;
                }
                case 'recent': {
                    const filteredRecent = ConnectorUtil.getFilteredRecentWallets();
                    filteredRecent.forEach(w => items.push({ kind: 'wallet', subtype: 'recent', wallet: w }));
                    break;
                }
                case 'injected': {
                    multiChain.forEach(c => items.push({ kind: 'connector', subtype: 'multiChain', connector: c }));
                    announced.forEach(c => items.push({ kind: 'connector', subtype: 'announced', connector: c }));
                    injected.forEach(c => items.push({ kind: 'connector', subtype: 'injected', connector: c }));
                    break;
                }
                case 'featured': {
                    featured.forEach(w => items.push({ kind: 'wallet', subtype: 'featured', wallet: w }));
                    break;
                }
                case 'custom': {
                    const filteredCustom = ConnectorUtil.getFilteredCustomWallets(custom ?? []);
                    filteredCustom.forEach(w => items.push({ kind: 'wallet', subtype: 'custom', wallet: w }));
                    break;
                }
                case 'external': {
                    external.forEach(c => items.push({ kind: 'connector', subtype: 'external', connector: c }));
                    break;
                }
                case 'recommended': {
                    const cappedRecommended = ConnectorUtil.getCappedRecommendedWallets(recommended);
                    cappedRecommended.forEach(w => items.push({ kind: 'wallet', subtype: 'recommended', wallet: w }));
                    break;
                }
                default:
                    console.warn(`Unknown connector type: ${type}`);
            }
        }
        return items.map((item, displayIndex) => {
            if (item.kind === 'connector') {
                return this.renderConnector(item, displayIndex);
            }
            return this.renderWallet(item, displayIndex);
        });
    }
    renderConnector(item, index) {
        const connector = item.connector;
        const imageSrc = AssetUtil.getConnectorImage(connector) || this.connectorImages[connector?.imageId ?? ''];
        const connectionsByNamespace = this.connections.get(connector.chain) ?? [];
        const isAlreadyConnected = connectionsByNamespace.some(c => HelpersUtil.isLowerCaseMatch(c.connectorId, connector.id));
        let tagLabel = undefined;
        let tagVariant = undefined;
        if (item.subtype === 'multiChain') {
            tagLabel = 'multichain';
            tagVariant = 'info';
        }
        else if (item.subtype === 'walletConnect') {
            tagLabel = 'qr code';
            tagVariant = 'accent';
        }
        else if (item.subtype === 'injected' || item.subtype === 'announced') {
            tagLabel = isAlreadyConnected ? 'connected' : 'installed';
            tagVariant = isAlreadyConnected ? 'info' : 'success';
        }
        else {
            tagLabel = undefined;
            tagVariant = undefined;
        }
        const hasWcConnection = ConnectionController.hasAnyConnection(CommonConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        const disabled = item.subtype === 'walletConnect' || item.subtype === 'external' ? hasWcConnection : false;
        return html `
      <w3m-list-wallet
        displayIndex=${index}
        imageSrc=${ifDefined(imageSrc)}
        .installed=${true}
        name=${connector.name ?? 'Unknown'}
        .tagVariant=${tagVariant}
        tagLabel=${ifDefined(tagLabel)}
        data-testid=${`wallet-selector-${connector.id.toLowerCase()}`}
        size="sm"
        @click=${() => this.onClickConnector(item)}
        tabIdx=${ifDefined(this.tabIdx)}
        ?disabled=${disabled}
        rdnsId=${ifDefined(connector.explorerWallet?.rdns || undefined)}
        walletRank=${ifDefined(connector.explorerWallet?.order)}
      >
      </w3m-list-wallet>
    `;
    }
    onClickConnector(item) {
        const redirectView = RouterController.state.data?.redirectView;
        if (item.subtype === 'walletConnect') {
            ConnectorController.setActiveConnector(item.connector);
            if (CoreHelperUtil.isMobile()) {
                RouterController.push('AllWallets');
            }
            else {
                RouterController.push('ConnectingWalletConnect', { redirectView });
            }
            return;
        }
        if (item.subtype === 'multiChain') {
            ConnectorController.setActiveConnector(item.connector);
            RouterController.push('ConnectingMultiChain', { redirectView });
            return;
        }
        if (item.subtype === 'injected') {
            ConnectorController.setActiveConnector(item.connector);
            RouterController.push('ConnectingExternal', {
                connector: item.connector,
                redirectView,
                wallet: item.connector.explorerWallet
            });
            return;
        }
        if (item.subtype === 'announced') {
            if (item.connector.id === 'walletConnect') {
                if (CoreHelperUtil.isMobile()) {
                    RouterController.push('AllWallets');
                }
                else {
                    RouterController.push('ConnectingWalletConnect', { redirectView });
                }
                return;
            }
            RouterController.push('ConnectingExternal', {
                connector: item.connector,
                redirectView,
                wallet: item.connector.explorerWallet
            });
            return;
        }
        RouterController.push('ConnectingExternal', {
            connector: item.connector,
            redirectView
        });
    }
    renderWallet(item, index) {
        const wallet = item.wallet;
        const imageSrc = AssetUtil.getWalletImage(wallet);
        const hasWcConnection = ConnectionController.hasAnyConnection(CommonConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);
        const disabled = hasWcConnection;
        const loading = this.loadingTelegram;
        const tagLabel = item.subtype === 'recent' ? 'recent' : undefined;
        const tagVariant = item.subtype === 'recent' ? 'info' : undefined;
        return html `
      <w3m-list-wallet
        displayIndex=${index}
        imageSrc=${ifDefined(imageSrc)}
        name=${wallet.name ?? 'Unknown'}
        @click=${() => this.onClickWallet(item)}
        size="sm"
        data-testid=${`wallet-selector-${wallet.id}`}
        tabIdx=${ifDefined(this.tabIdx)}
        ?loading=${loading}
        ?disabled=${disabled}
        rdnsId=${ifDefined(wallet.rdns || undefined)}
        walletRank=${ifDefined(wallet.order)}
        tagLabel=${ifDefined(tagLabel)}
        .tagVariant=${tagVariant}
      >
      </w3m-list-wallet>
    `;
    }
    onClickWallet(item) {
        const redirectView = RouterController.state.data?.redirectView;
        if (item.subtype === 'featured') {
            ConnectorController.selectWalletConnector(item.wallet);
            return;
        }
        if (item.subtype === 'recent') {
            if (this.loadingTelegram) {
                return;
            }
            ConnectorController.selectWalletConnector(item.wallet);
            return;
        }
        if (item.subtype === 'custom') {
            if (this.loadingTelegram) {
                return;
            }
            RouterController.push('ConnectingWalletConnect', { wallet: item.wallet, redirectView });
            return;
        }
        if (this.loadingTelegram) {
            return;
        }
        const connector = ConnectorController.getConnector({
            id: item.wallet.id,
            rdns: item.wallet.rdns
        });
        if (connector) {
            RouterController.push('ConnectingExternal', { connector, redirectView });
        }
        else {
            RouterController.push('ConnectingWalletConnect', { wallet: item.wallet, redirectView });
        }
    }
};
W3mConnectorList.styles = styles;
__decorate([
    property({ type: Number })
], W3mConnectorList.prototype, "tabIdx", void 0);
__decorate([
    state()
], W3mConnectorList.prototype, "connectors", void 0);
__decorate([
    state()
], W3mConnectorList.prototype, "recommended", void 0);
__decorate([
    state()
], W3mConnectorList.prototype, "featured", void 0);
__decorate([
    state()
], W3mConnectorList.prototype, "explorerWallets", void 0);
__decorate([
    state()
], W3mConnectorList.prototype, "connections", void 0);
__decorate([
    state()
], W3mConnectorList.prototype, "connectorImages", void 0);
__decorate([
    state()
], W3mConnectorList.prototype, "loadingTelegram", void 0);
W3mConnectorList = __decorate([
    customElement('w3m-connector-list')
], W3mConnectorList);
export { W3mConnectorList };
//# sourceMappingURL=index.js.map